<html>
<head>
<link rel="stylesheet" type="text/css" href="new.css">
<title>functional.h</title>
</head>

<body>  

<pre class="sourcecode"><code>
<font color="#003399"><i>// functional standard header</i></font>
<b>#pragma</b> once
<b>#ifndef</b> _FUNCTIONAL_
<b>#define</b> _FUNCTIONAL_
<b>#include</b> &lt;xstddef&gt;

<b>#pragma</b> pack(push,8)
<b>#pragma</b> <b>warning</b>(push,3)

 <b>#pragma</b> <b>warning</b>(<b>disable</b>: 4244)
_STD_BEGIN

		<font color="#003399"><i>// TEMPLATE STRUCT unary_function</i></font>
<b>template</b>&lt;<b>class</b> _Arg,
	<b>class</b> _Result&gt;
	<b>struct</b> unary_function
	{	<font color="#003399"><i>// base class for unary functions</i></font>
	<b>typedef</b> _Arg argument_type;
	<b>typedef</b> _Result result_type;
	};

		<font color="#003399"><i>// TEMPLATE STRUCT binary_function</i></font>
<b>template</b>&lt;<b>class</b> _Arg1,
	<b>class</b> _Arg2,
	<b>class</b> _Result&gt;
	<b>struct</b> binary_function
	{	<font color="#003399"><i>// base class for binary functions</i></font>
	<b>typedef</b> _Arg1 first_argument_type;
	<b>typedef</b> _Arg2 second_argument_type;
	<b>typedef</b> _Result result_type;
	};

		<font color="#003399"><i>// TEMPLATE STRUCT plus</i></font>
<b>template</b>&lt;<b>class</b> _Ty&gt;
	<b>struct</b> plus
		: <b>public</b> binary_function&lt;_Ty, _Ty, _Ty&gt;
	{	<font color="#003399"><i>// functor for operator+</i></font>
	_Ty <b>operator</b>()(<b>const</b> _Ty&amp; _Left, <b>const</b> _Ty&amp; _Right) <b>const</b>
		{	<font color="#003399"><i>// apply operator+ to operands</i></font>
		<b>return</b> (_Left + _Right);
		}
	};

		<font color="#003399"><i>// TEMPLATE STRUCT minus</i></font>
<b>template</b>&lt;<b>class</b> _Ty&gt;
	<b>struct</b> minus
		: <b>public</b> binary_function&lt;_Ty, _Ty, _Ty&gt;
	{	<font color="#003399"><i>// functor for operator-</i></font>
	_Ty <b>operator</b>()(<b>const</b> _Ty&amp; _Left, <b>const</b> _Ty&amp; _Right) <b>const</b>
		{	<font color="#003399"><i>// apply operator- to operands</i></font>
		<b>return</b> (_Left - _Right);
		}
	};

		<font color="#003399"><i>// TEMPLATE STRUCT multiplies</i></font>
<b>template</b>&lt;<b>class</b> _Ty&gt;
	<b>struct</b> multiplies
		: <b>public</b> binary_function&lt;_Ty, _Ty, _Ty&gt;
	{	<font color="#003399"><i>// functor for operator*</i></font>
	_Ty <b>operator</b>()(<b>const</b> _Ty&amp; _Left, <b>const</b> _Ty&amp; _Right) <b>const</b>
		{	<font color="#003399"><i>// apply operator* to operands</i></font>
		<b>return</b> (_Left * _Right);
		}
	};

		<font color="#003399"><i>// TEMPLATE STRUCT divides</i></font>
<b>template</b>&lt;<b>class</b> _Ty&gt;
	<b>struct</b> divides
		: <b>public</b> binary_function&lt;_Ty, _Ty, _Ty&gt;
	{	<font color="#003399"><i>// functor for operator/</i></font>
	_Ty <b>operator</b>()(<b>const</b> _Ty&amp; _Left, <b>const</b> _Ty&amp; _Right) <b>const</b>
		{	<font color="#003399"><i>// apply operator/ to operands</i></font>
		<b>return</b> (_Left / _Right);
		}
	};

		<font color="#003399"><i>// TEMPLATE STRUCT modulus</i></font>
<b>template</b>&lt;<b>class</b> _Ty&gt;
	<b>struct</b> modulus
		: <b>public</b> binary_function&lt;_Ty, _Ty, _Ty&gt;
	{	<font color="#003399"><i>// functor for operator%</i></font>
	_Ty <b>operator</b>()(<b>const</b> _Ty&amp; _Left, <b>const</b> _Ty&amp; _Right) <b>const</b>
		{	<font color="#003399"><i>// apply operator% to operands</i></font>
		<b>return</b> (_Left % _Right);
		}
	};

		<font color="#003399"><i>// TEMPLATE STRUCT negate</i></font>
<b>template</b>&lt;<b>class</b> _Ty&gt;
	<b>struct</b> negate
		: <b>public</b> unary_function&lt;_Ty, _Ty&gt;
	{	<font color="#003399"><i>// functor for unary operator-</i></font>
	_Ty <b>operator</b>()(<b>const</b> _Ty&amp; _Left) <b>const</b>
		{	<font color="#003399"><i>// apply operator- to operand</i></font>
		<b>return</b> (-_Left);
		}
	};

		<font color="#003399"><i>// TEMPLATE STRUCT equal_to</i></font>
<b>template</b>&lt;<b>class</b> _Ty&gt;
	<b>struct</b> equal_to
		: <b>public</b> binary_function&lt;_Ty, _Ty, <b>bool</b>&gt;
	{	<font color="#003399"><i>// functor for operator==</i></font>
	<b>bool</b> <b>operator</b>()(<b>const</b> _Ty&amp; _Left, <b>const</b> _Ty&amp; _Right) <b>const</b>
		{	<font color="#003399"><i>// apply operator== to operands</i></font>
		<b>return</b> (_Left == _Right);
		}
	};

		<font color="#003399"><i>// TEMPLATE STRUCT not_equal_to</i></font>
<b>template</b>&lt;<b>class</b> _Ty&gt;
	<b>struct</b> not_equal_to
		: <b>public</b> binary_function&lt;_Ty, _Ty, <b>bool</b>&gt;
	{	<font color="#003399"><i>// functor for operator!=</i></font>
	<b>bool</b> <b>operator</b>()(<b>const</b> _Ty&amp; _Left, <b>const</b> _Ty&amp; _Right) <b>const</b>
		{	<font color="#003399"><i>// apply operator= to operands</i></font>
		<b>return</b> (_Left != _Right);
		}
	};

		<font color="#003399"><i>// TEMPLATE STRUCT greater</i></font>
<b>template</b>&lt;<b>class</b> _Ty&gt;
	<b>struct</b> greater
		: <b>public</b> binary_function&lt;_Ty, _Ty, <b>bool</b>&gt;
	{	<font color="#003399"><i>// functor for operator&gt;</i></font>
	<b>bool</b> <b>operator</b>()(<b>const</b> _Ty&amp; _Left, <b>const</b> _Ty&amp; _Right) <b>const</b>
		{	<font color="#003399"><i>// apply operator&gt; to operands</i></font>
		<b>return</b> (_Left &gt; _Right);
		}
	};

		<font color="#003399"><i>// TEMPLATE STRUCT less</i></font>
<b>template</b>&lt;<b>class</b> _Ty&gt;
	<b>struct</b> less
		: <b>public</b> binary_function&lt;_Ty, _Ty, <b>bool</b>&gt;
	{	<font color="#003399"><i>// functor for operator&lt;</i></font>
	<b>bool</b> <b>operator</b>()(<b>const</b> _Ty&amp; _Left, <b>const</b> _Ty&amp; _Right) <b>const</b>
		{	<font color="#003399"><i>// apply operator&lt; to operands</i></font>
		<b>return</b> (_Left &lt; _Right);
		}
	};

		<font color="#003399"><i>// TEMPLATE STRUCT greater_equal</i></font>
<b>template</b>&lt;<b>class</b> _Ty&gt;
	<b>struct</b> greater_equal
		: <b>public</b> binary_function&lt;_Ty, _Ty, <b>bool</b>&gt;
	{	<font color="#003399"><i>// functor for operator&gt;=</i></font>
	<b>bool</b> <b>operator</b>()(<b>const</b> _Ty&amp; _Left, <b>const</b> _Ty&amp; _Right) <b>const</b>
		{	<font color="#003399"><i>// apply operator&gt;= to operands</i></font>
		<b>return</b> (_Left &gt;= _Right);
		}
	};

		<font color="#003399"><i>// TEMPLATE STRUCT less_equal</i></font>
<b>template</b>&lt;<b>class</b> _Ty&gt;
	<b>struct</b> less_equal
		: <b>public</b> binary_function&lt;_Ty, _Ty, <b>bool</b>&gt;
	{	<font color="#003399"><i>// functor for operator&lt;=</i></font>
	<b>bool</b> <b>operator</b>()(<b>const</b> _Ty&amp; _Left, <b>const</b> _Ty&amp; _Right) <b>const</b>
		{	<font color="#003399"><i>// apply operator&lt;= to operands</i></font>
		<b>return</b> (_Left &lt;= _Right);
		}
	};

		<font color="#003399"><i>// TEMPLATE STRUCT logical_and</i></font>
<b>template</b>&lt;<b>class</b> _Ty&gt;
	<b>struct</b> logical_and
		: <b>public</b> binary_function&lt;_Ty, _Ty, <b>bool</b>&gt;
	{	<font color="#003399"><i>// functor for operator&amp;&amp;</i></font>
	<b>bool</b> <b>operator</b>()(<b>const</b> _Ty&amp; _Left, <b>const</b> _Ty&amp; _Right) <b>const</b>
		{	<font color="#003399"><i>// apply operator&amp;&amp; to operands</i></font>
		<b>return</b> (_Left &amp;&amp; _Right);
		}
	};

		<font color="#003399"><i>// TEMPLATE STRUCT logical_or</i></font>
<b>template</b>&lt;<b>class</b> _Ty&gt;
	<b>struct</b> logical_or
		: <b>public</b> binary_function&lt;_Ty, _Ty, <b>bool</b>&gt;
	{	<font color="#003399"><i>// functor for operator||</i></font>
	<b>bool</b> <b>operator</b>()(<b>const</b> _Ty&amp; _Left, <b>const</b> _Ty&amp; _Right) <b>const</b>
		{	<font color="#003399"><i>// apply operator|| to operands</i></font>
		<b>return</b> (_Left || _Right);
		}
	};

		<font color="#003399"><i>// TEMPLATE STRUCT logical_not</i></font>
<b>template</b>&lt;<b>class</b> _Ty&gt;
	<b>struct</b> logical_not
		: <b>public</b> unary_function&lt;_Ty, <b>bool</b>&gt;
	{	<font color="#003399"><i>// functor for unary operator!</i></font>
	<b>bool</b> <b>operator</b>()(<b>const</b> _Ty&amp; _Left) <b>const</b>
		{	<font color="#003399"><i>// apply operator! to operand</i></font>
		<b>return</b> (!_Left);
		}
	};

		<font color="#003399"><i>// TEMPLATE CLASS unary_negate</i></font>
<b>template</b>&lt;<b>class</b> _Fn1&gt;
	<b>class</b> unary_negate
	: <b>public</b> unary_function&lt;<b>typename</b> _Fn1::argument_type, <b>bool</b>&gt;
	{	<font color="#003399"><i>// functor adapter !_Func(left)</i></font>
<b>public</b>:
	<b>explicit</b> unary_negate(<b>const</b> _Fn1&amp; _Func)
		: _Functor(_Func)
		{	<font color="#003399"><i>// construct from functor</i></font>
		}

	<b>bool</b> <b>operator</b>()(<b>const</b> <b>typename</b> _Fn1::argument_type&amp; _Left) <b>const</b>
		{	<font color="#003399"><i>// apply functor to operand</i></font>
		<b>return</b> (!_Functor(_Left));
		}

<b>protected</b>:
	_Fn1 _Functor;	<font color="#003399"><i>// the functor to apply</i></font>
	};

		<font color="#003399"><i>// TEMPLATE FUNCTION not1</i></font>
<b>template</b>&lt;<b>class</b> _Fn1&gt; <b>inline</b>
	unary_negate&lt;_Fn1&gt; not1(<b>const</b> _Fn1&amp; _Func)
	{	<font color="#003399"><i>// return a unary_negate functor adapter</i></font>
	<b>return</b> (std::unary_negate&lt;_Fn1&gt;(_Func));
	}

		<font color="#003399"><i>// TEMPLATE CLASS binary_negate</i></font>
<b>template</b>&lt;<b>class</b> _Fn2&gt;
	<b>class</b> binary_negate
		: <b>public</b> binary_function&lt;<b>typename</b> _Fn2::first_argument_type,
			<b>typename</b> _Fn2::second_argument_type, <b>bool</b>&gt;
	{	<font color="#003399"><i>// functor adapter !_Func(left, right)</i></font>
<b>public</b>:
	<b>explicit</b> binary_negate(<b>const</b> _Fn2&amp; _Func)
		: _Functor(_Func)
		{	<font color="#003399"><i>// construct from functor</i></font>
		}

	<b>bool</b> <b>operator</b>()(<b>const</b> <b>typename</b> _Fn2::first_argument_type&amp; _Left,
		<b>const</b> <b>typename</b> _Fn2::second_argument_type&amp; _Right) <b>const</b>
		{	<font color="#003399"><i>// apply functor to operands</i></font>
		<b>return</b> (!_Functor(_Left, _Right));
		}

<b>protected</b>:
	_Fn2 _Functor;	<font color="#003399"><i>// the functor to apply</i></font>
	};

		<font color="#003399"><i>// TEMPLATE FUNCTION not2</i></font>
<b>template</b>&lt;<b>class</b> _Fn2&gt; <b>inline</b>
	binary_negate&lt;_Fn2&gt; not2(<b>const</b> _Fn2&amp; _Func)
	{	<font color="#003399"><i>// return a binary_negate functor adapter</i></font>
	<b>return</b> (std::binary_negate&lt;_Fn2&gt;(_Func));
	}

		<font color="#003399"><i>// TEMPLATE CLASS binder1st</i></font>
<b>template</b>&lt;<b>class</b> _Fn2&gt;
	<b>class</b> binder1st
		: <b>public</b> unary_function&lt;<b>typename</b> _Fn2::second_argument_type,
			<b>typename</b> _Fn2::result_type&gt;
	{	<font color="#003399"><i>// functor adapter _Func(stored, right)</i></font>
<b>public</b>:
	<b>typedef</b> unary_function&lt;<b>typename</b> _Fn2::second_argument_type,
		<b>typename</b> _Fn2::result_type&gt; _Base;
	<b>typedef</b> <b>typename</b> _Base::argument_type argument_type;
	<b>typedef</b> <b>typename</b> _Base::result_type result_type;

	binder1st(<b>const</b> _Fn2&amp; _Func,
		<b>const</b> <b>typename</b> _Fn2::first_argument_type&amp; _Left)
		: op(_Func), value(_Left)
		{	<font color="#003399"><i>// construct from functor and left operand</i></font>
		}

	result_type <b>operator</b>()(<b>const</b> argument_type&amp; _Right) <b>const</b>
		{	<font color="#003399"><i>// apply functor to operands</i></font>
		<b>return</b> (op(value, _Right));
		}

	result_type <b>operator</b>()(argument_type&amp; _Right) <b>const</b>
		{	<font color="#003399"><i>// apply functor to operands</i></font>
		<b>return</b> (op(value, _Right));
		}

<b>protected</b>:
	_Fn2 op;	<font color="#003399"><i>// the functor to apply</i></font>
	<b>typename</b> _Fn2::first_argument_type value;	<font color="#003399"><i>// the left operand</i></font>
	};

		<font color="#003399"><i>// TEMPLATE FUNCTION bind1st</i></font>
<b>template</b>&lt;<b>class</b> _Fn2,
	<b>class</b> _Ty&gt; <b>inline</b>
	binder1st&lt;_Fn2&gt; bind1st(<b>const</b> _Fn2&amp; _Func, <b>const</b> _Ty&amp; _Left)
		{	<font color="#003399"><i>// return a binder1st functor adapter</i></font>
		<b>typename</b> _Fn2::first_argument_type _Val(_Left);
		<b>return</b> (std::binder1st&lt;_Fn2&gt;(_Func, _Val));
		}

		<font color="#003399"><i>// TEMPLATE CLASS binder2nd</i></font>
<b>template</b>&lt;<b>class</b> _Fn2&gt;
	<b>class</b> binder2nd
		: <b>public</b> unary_function&lt;<b>typename</b> _Fn2::first_argument_type,
			<b>typename</b> _Fn2::result_type&gt;
	{	<font color="#003399"><i>// functor adapter _Func(left, stored)</i></font>
<b>public</b>:
	<b>typedef</b> unary_function&lt;<b>typename</b> _Fn2::first_argument_type,
		<b>typename</b> _Fn2::result_type&gt; _Base;
	<b>typedef</b> <b>typename</b> _Base::argument_type argument_type;
	<b>typedef</b> <b>typename</b> _Base::result_type result_type;

	binder2nd(<b>const</b> _Fn2&amp; _Func,
		<b>const</b> <b>typename</b> _Fn2::second_argument_type&amp; _Right)
		: op(_Func), value(_Right)
		{	<font color="#003399"><i>// construct from functor and right operand</i></font>
		}

	result_type <b>operator</b>()(<b>const</b> argument_type&amp; _Left) <b>const</b>
		{	<font color="#003399"><i>// apply functor to operands</i></font>
		<b>return</b> (op(_Left, value));
		}

	result_type <b>operator</b>()(argument_type&amp; _Left) <b>const</b>
		{	<font color="#003399"><i>// apply functor to operands</i></font>
		<b>return</b> (op(_Left, value));
		}

<b>protected</b>:
	_Fn2 op;	<font color="#003399"><i>// the functor to apply</i></font>
	<b>typename</b> _Fn2::second_argument_type value;	<font color="#003399"><i>// the right operand</i></font>
	};

		<font color="#003399"><i>// TEMPLATE FUNCTION bind2nd</i></font>
<b>template</b>&lt;<b>class</b> _Fn2,
	<b>class</b> _Ty&gt; <b>inline</b>
	binder2nd&lt;_Fn2&gt; bind2nd(<b>const</b> _Fn2&amp; _Func, <b>const</b> _Ty&amp; _Right)
	{	<font color="#003399"><i>// return a binder2nd functor adapter</i></font>
	<b>typename</b> _Fn2::second_argument_type _Val(_Right);
	<b>return</b> (std::binder2nd&lt;_Fn2&gt;(_Func, _Val));
	}

		<font color="#003399"><i>// TEMPLATE CLASS pointer_to_unary_function</i></font>
<b>template</b>&lt;<b>class</b> _Arg,
	<b>class</b> _Result&gt;
	<b>class</b> pointer_to_unary_function
		: <b>public</b> unary_function&lt;_Arg, _Result&gt;
	{	<font color="#003399"><i>// functor adapter (*pfunc)(left)</i></font>
<b>public</b>:
	<b>explicit</b> pointer_to_unary_function(_Result (<b>__cdecl</b> *_Left)(_Arg))
		: _Pfun(_Left)
		{	<font color="#003399"><i>// construct from pointer</i></font>
		}

	_Result <b>operator</b>()(_Arg _Left) <b>const</b>
		{	<font color="#003399"><i>// call function with operand</i></font>
		<b>return</b> (_Pfun(_Left));
		}

<b>protected</b>:
	_Result (<b>__cdecl</b> *_Pfun)(_Arg);	<font color="#003399"><i>// the function pointer</i></font>
	};

		<font color="#003399"><i>// TEMPLATE CLASS pointer_to_binary_function</i></font>
<b>template</b>&lt;<b>class</b> _Arg1,
	<b>class</b> _Arg2,
	<b>class</b> _Result&gt;
	<b>class</b> pointer_to_binary_function
		: <b>public</b> binary_function&lt;_Arg1, _Arg2, _Result&gt;
	{	<font color="#003399"><i>// functor adapter (*pfunc)(left, right)</i></font>
<b>public</b>:
	<b>explicit</b> pointer_to_binary_function(
		_Result (<b>__cdecl</b> *_Left)(_Arg1, _Arg2))
		: _Pfun(_Left)
		{	<font color="#003399"><i>// construct from pointer</i></font>
		}

	_Result <b>operator</b>()(_Arg1 _Left, _Arg2 _Right) <b>const</b>
		{	<font color="#003399"><i>// call function with operands</i></font>
		<b>return</b> (_Pfun(_Left, _Right));
		}

<b>protected</b>:
	_Result (<b>__cdecl</b> *_Pfun)(_Arg1, _Arg2);	<font color="#003399"><i>// the function pointer</i></font>
	};

		<font color="#003399"><i>// TEMPLATE FUNCTION ptr_fun</i></font>
<b>template</b>&lt;<b>class</b> _Arg,
	<b>class</b> _Result&gt; <b>inline</b>
	pointer_to_unary_function&lt;_Arg, _Result&gt;
		ptr_fun(_Result (<b>__cdecl</b> *_Left)(_Arg))
	{	<font color="#003399"><i>// return pointer_to_unary_function functor adapter</i></font>
	<b>return</b> (std::pointer_to_unary_function&lt;_Arg, _Result&gt;(_Left));
	}

<b>template</b>&lt;<b>class</b> _Arg1,
	<b>class</b> _Arg2,
	<b>class</b> _Result&gt; <b>inline</b>
	pointer_to_binary_function&lt;_Arg1, _Arg2, _Result&gt;
		ptr_fun(_Result (<b>__cdecl</b> *_Left)(_Arg1, _Arg2))
	{	<font color="#003399"><i>// return pointer_to_binary_function functor adapter</i></font>
	<b>return</b> (std::pointer_to_binary_function&lt;_Arg1, _Arg2, _Result&gt;(_Left));
	}

		<font color="#003399"><i>// TEMPLATE CLASS mem_fun_t</i></font>
<b>template</b>&lt;<b>class</b> _Result,
	<b>class</b> _Ty&gt;
	<b>class</b> mem_fun_t
		: <b>public</b> unary_function&lt;_Ty *, _Result&gt;
	{	<font color="#003399"><i>// functor adapter (*p-&gt;*pfunc)(), non-const *pfunc</i></font>
<b>public</b>:
	<b>explicit</b> mem_fun_t(_Result (_Ty::*_Pm)())
		: _Pmemfun(_Pm)
		{	<font color="#003399"><i>// construct from pointer</i></font>
		}

	_Result <b>operator</b>()(_Ty *_Pleft) <b>const</b>
		{	<font color="#003399"><i>// call function</i></font>
		<b>return</b> ((_Pleft-&gt;*_Pmemfun)());
		}

<b>private</b>:
	_Result (_Ty::*_Pmemfun)();	<font color="#003399"><i>// the member function pointer</i></font>
	};

		<font color="#003399"><i>// TEMPLATE CLASS mem_fun1_t</i></font>
<b>template</b>&lt;<b>class</b> _Result,
	<b>class</b> _Ty,
	<b>class</b> _Arg&gt;
	<b>class</b> mem_fun1_t
		: <b>public</b> binary_function&lt;_Ty *, _Arg, _Result&gt;
	{	<font color="#003399"><i>// functor adapter (*p-&gt;*pfunc)(val), non-const *pfunc</i></font>
<b>public</b>:
	<b>explicit</b> mem_fun1_t(_Result (_Ty::*_Pm)(_Arg))
		: _Pmemfun(_Pm)
		{	<font color="#003399"><i>// construct from pointer</i></font>
		}

	_Result <b>operator</b>()(_Ty *_Pleft, _Arg _Right) <b>const</b>
		{	<font color="#003399"><i>// call function with operand</i></font>
		<b>return</b> ((_Pleft-&gt;*_Pmemfun)(_Right));
		}

<b>private</b>:
	_Result (_Ty::*_Pmemfun)(_Arg);	<font color="#003399"><i>// the member function pointer</i></font>
	};

		<font color="#003399"><i>// TEMPLATE CLASS const_mem_fun_t</i></font>
<b>template</b>&lt;<b>class</b> _Result,
	<b>class</b> _Ty&gt;
	<b>class</b> const_mem_fun_t
		: <b>public</b> unary_function&lt;<b>const</b> _Ty *, _Result&gt;
	{	<font color="#003399"><i>// functor adapter (*p-&gt;*pfunc)(), const *pfunc</i></font>
<b>public</b>:
	<b>explicit</b> const_mem_fun_t(_Result (_Ty::*_Pm)() <b>const</b>)
		: _Pmemfun(_Pm)
		{	<font color="#003399"><i>// construct from pointer</i></font>
		}

	_Result <b>operator</b>()(<b>const</b> _Ty *_Pleft) <b>const</b>
		{	<font color="#003399"><i>// call function</i></font>
		<b>return</b> ((_Pleft-&gt;*_Pmemfun)());
		}

<b>private</b>:
	_Result (_Ty::*_Pmemfun)() <b>const</b>;	<font color="#003399"><i>// the member function pointer</i></font>
	};

		<font color="#003399"><i>// TEMPLATE CLASS const_mem_fun1_t</i></font>
<b>template</b>&lt;<b>class</b> _Result,
	<b>class</b> _Ty,
	<b>class</b> _Arg&gt;
	<b>class</b> const_mem_fun1_t
		: <b>public</b> binary_function&lt;<b>const</b> _Ty *, _Arg, _Result&gt;
	{	<font color="#003399"><i>// functor adapter (*p-&gt;*pfunc)(val), const *pfunc</i></font>
<b>public</b>:
	<b>explicit</b> const_mem_fun1_t(_Result (_Ty::*_Pm)(_Arg) <b>const</b>)
		: _Pmemfun(_Pm)
		{	<font color="#003399"><i>// construct from pointer</i></font>
		}

	_Result <b>operator</b>()(<b>const</b> _Ty *_Pleft, _Arg _Right) <b>const</b>
		{	<font color="#003399"><i>// call function with operand</i></font>
		<b>return</b> ((_Pleft-&gt;*_Pmemfun)(_Right));
		}

<b>private</b>:
	_Result (_Ty::*_Pmemfun)(_Arg) <b>const</b>;	<font color="#003399"><i>// the member function pointer</i></font>
	};

		<font color="#003399"><i>// TEMPLATE FUNCTION mem_fun</i></font>
<b>template</b>&lt;<b>class</b> _Result,
	<b>class</b> _Ty&gt; <b>inline</b>
	mem_fun_t&lt;_Result, _Ty&gt; mem_fun(_Result (_Ty::*_Pm)())
	{	<font color="#003399"><i>// return a mem_fun_t functor adapter</i></font>
	<b>return</b> (std::mem_fun_t&lt;_Result, _Ty&gt;(_Pm));
	}

<b>template</b>&lt;<b>class</b> _Result,
	<b>class</b> _Ty,
	<b>class</b> _Arg&gt; <b>inline</b>
	mem_fun1_t&lt;_Result, _Ty, _Arg&gt; mem_fun(_Result (_Ty::*_Pm)(_Arg))
	{	<font color="#003399"><i>// return a mem_fun1_t functor adapter</i></font>
	<b>return</b> (std::mem_fun1_t&lt;_Result, _Ty, _Arg&gt;(_Pm));
	}

<b>template</b>&lt;<b>class</b> _Result,
	<b>class</b> _Ty&gt; <b>inline</b>
	const_mem_fun_t&lt;_Result, _Ty&gt;
		mem_fun(_Result (_Ty::*_Pm)() <b>const</b>)
	{	<font color="#003399"><i>// return a const_mem_fun_t functor adapter</i></font>
	<b>return</b> (std::const_mem_fun_t&lt;_Result, _Ty&gt;(_Pm));
	}

<b>template</b>&lt;<b>class</b> _Result,
	<b>class</b> _Ty,
	<b>class</b> _Arg&gt; <b>inline</b>
	const_mem_fun1_t&lt;_Result, _Ty, _Arg&gt;
		mem_fun(_Result (_Ty::*_Pm)(_Arg) <b>const</b>)
	{	<font color="#003399"><i>// return a const_mem_fun1_t functor adapter</i></font>
	<b>return</b> (std::const_mem_fun1_t&lt;_Result, _Ty, _Arg&gt;(_Pm));
	}

		<font color="#003399"><i>// TEMPLATE FUNCTION mem_fun1 (retained)</i></font>
<b>template</b>&lt;<b>class</b> _Result,
	<b>class</b> _Ty,
	<b>class</b> _Arg&gt; <b>inline</b>
	mem_fun1_t&lt;_Result, _Ty, _Arg&gt; mem_fun1(_Result (_Ty::*_Pm)(_Arg))
	{	<font color="#003399"><i>// return a mem_fun1_t functor adapter</i></font>
	<b>return</b> (std::mem_fun1_t&lt;_Result, _Ty, _Arg&gt;(_Pm));
	}

		<font color="#003399"><i>// TEMPLATE CLASS mem_fun_ref_t</i></font>
<b>template</b>&lt;<b>class</b> _Result,
	<b>class</b> _Ty&gt;
	<b>class</b> mem_fun_ref_t
		: <b>public</b> unary_function&lt;_Ty, _Result&gt;
	{	<font color="#003399"><i>// functor adapter (*left.*pfunc)(), non-const *pfunc</i></font>
<b>public</b>:
	<b>explicit</b> mem_fun_ref_t(_Result (_Ty::*_Pm)())
		: _Pmemfun(_Pm)
		{	<font color="#003399"><i>// construct from pointer</i></font>
		}

	_Result <b>operator</b>()(_Ty&amp; _Left) <b>const</b>
		{	<font color="#003399"><i>// call function</i></font>
		<b>return</b> ((_Left.*_Pmemfun)());
		}

<b>private</b>:
	_Result (_Ty::*_Pmemfun)();	<font color="#003399"><i>// the member function pointer</i></font>
	};

		<font color="#003399"><i>// TEMPLATE CLASS mem_fun1_ref_t</i></font>
<b>template</b>&lt;<b>class</b> _Result,
	<b>class</b> _Ty,
	<b>class</b> _Arg&gt;
	<b>class</b> mem_fun1_ref_t
		: <b>public</b> binary_function&lt;_Ty, _Arg, _Result&gt;
	{	<font color="#003399"><i>// functor adapter (*left.*pfunc)(val), non-const *pfunc</i></font>
<b>public</b>:
	<b>explicit</b> mem_fun1_ref_t(_Result (_Ty::*_Pm)(_Arg))
		: _Pmemfun(_Pm)
		{	<font color="#003399"><i>// construct from pointer</i></font>
		}

	_Result <b>operator</b>()(_Ty&amp; _Left, _Arg _Right) <b>const</b>
		{	<font color="#003399"><i>// call function with operand</i></font>
		<b>return</b> ((_Left.*_Pmemfun)(_Right));
		}

<b>private</b>:
	_Result (_Ty::*_Pmemfun)(_Arg);	<font color="#003399"><i>// the member function pointer</i></font>
	};

		<font color="#003399"><i>// TEMPLATE CLASS const_mem_fun_ref_t</i></font>
<b>template</b>&lt;<b>class</b> _Result,
	<b>class</b> _Ty&gt;
	<b>class</b> const_mem_fun_ref_t
		: <b>public</b> unary_function&lt;_Ty, _Result&gt;
	{	<font color="#003399"><i>// functor adapter (*left.*pfunc)(), const *pfunc</i></font>
<b>public</b>:
	<b>explicit</b> const_mem_fun_ref_t(_Result (_Ty::*_Pm)() <b>const</b>)
		: _Pmemfun(_Pm)
		{	<font color="#003399"><i>// construct from pointer</i></font>
		}

	_Result <b>operator</b>()(<b>const</b> _Ty&amp; _Left) <b>const</b>
		{	<font color="#003399"><i>// call function</i></font>
		<b>return</b> ((_Left.*_Pmemfun)());
		}

<b>private</b>:
	_Result (_Ty::*_Pmemfun)() <b>const</b>;	<font color="#003399"><i>// the member function pointer</i></font>
	};

		<font color="#003399"><i>// TEMPLATE CLASS const_mem_fun1_ref_t</i></font>
<b>template</b>&lt;<b>class</b> _Result,
	<b>class</b> _Ty,
	<b>class</b> _Arg&gt;
	<b>class</b> const_mem_fun1_ref_t
		: <b>public</b> binary_function&lt;_Ty, _Arg, _Result&gt;
	{	<font color="#003399"><i>// functor adapter (*left.*pfunc)(val), const *pfunc</i></font>
<b>public</b>:
	<b>explicit</b> const_mem_fun1_ref_t(_Result (_Ty::*_Pm)(_Arg) <b>const</b>)
		: _Pmemfun(_Pm)
		{	<font color="#003399"><i>// construct from pointer</i></font>
		}

	_Result <b>operator</b>()(<b>const</b> _Ty&amp; _Left, _Arg _Right) <b>const</b>
		{	<font color="#003399"><i>// call function with operand</i></font>
		<b>return</b> ((_Left.*_Pmemfun)(_Right));
		}

<b>private</b>:
	_Result (_Ty::*_Pmemfun)(_Arg) <b>const</b>;	<font color="#003399"><i>// the member function pointer</i></font>
	};

		<font color="#003399"><i>// TEMPLATE FUNCTION mem_fun_ref</i></font>
<b>template</b>&lt;<b>class</b> _Result,
	<b>class</b> _Ty&gt; <b>inline</b>
	mem_fun_ref_t&lt;_Result, _Ty&gt; mem_fun_ref(_Result (_Ty::*_Pm)())
	{	<font color="#003399"><i>// return a mem_fun_ref_t functor adapter</i></font>
	<b>return</b> (std::mem_fun_ref_t&lt;_Result, _Ty&gt;(_Pm));
	}

<b>template</b>&lt;<b>class</b> _Result,
	<b>class</b> _Ty,
	<b>class</b> _Arg&gt; <b>inline</b>
	mem_fun1_ref_t&lt;_Result, _Ty, _Arg&gt;
		mem_fun_ref(_Result (_Ty::*_Pm)(_Arg))
	{	<font color="#003399"><i>// return a mem_fun1_ref_t functor adapter</i></font>
	<b>return</b> (std::mem_fun1_ref_t&lt;_Result, _Ty, _Arg&gt;(_Pm));
	}

<b>template</b>&lt;<b>class</b> _Result,
	<b>class</b> _Ty&gt; <b>inline</b>
	const_mem_fun_ref_t&lt;_Result, _Ty&gt;
		mem_fun_ref(_Result (_Ty::*_Pm)() <b>const</b>)
	{	<font color="#003399"><i>// return a const_mem_fun_ref_t functor adapter</i></font>
	<b>return</b> (std::const_mem_fun_ref_t&lt;_Result, _Ty&gt;(_Pm));
	}

<b>template</b>&lt;<b>class</b> _Result,
	<b>class</b> _Ty,
	<b>class</b> _Arg&gt; <b>inline</b>
	const_mem_fun1_ref_t&lt;_Result, _Ty, _Arg&gt;
		mem_fun_ref(_Result (_Ty::*_Pm)(_Arg) <b>const</b>)
	{	<font color="#003399"><i>// return a const_mem_fun1_ref_t functor adapter</i></font>
	<b>return</b> (std::const_mem_fun1_ref_t&lt;_Result, _Ty, _Arg&gt;(_Pm));
	}

		<font color="#003399"><i>// TEMPLATE FUNCTION mem_fun1_ref (retained)</i></font>
<b>template</b>&lt;<b>class</b> _Result,
	<b>class</b> _Ty,
	<b>class</b> _Arg&gt; <b>inline</b>
	mem_fun1_ref_t&lt;_Result, _Ty, _Arg&gt; mem_fun1_ref(_Result (_Ty::*_Pm)(_Arg))
	{	<font color="#003399"><i>// return a mem_fun1_ref_t functor adapter</i></font>
	<b>return</b> (std::mem_fun1_ref_t&lt;_Result, _Ty, _Arg&gt;(_Pm));
	}
_STD_END

<b>#pragma</b> <b>warning</b>(<b>default</b>: 4244)

<b>#pragma</b> <b>warning</b>(pop)
<b>#pragma</b> pack(pop)

<b>#endif</b> <font color="#003399"><i>/* _FUNCTIONAL_ */</i></font>

<font color="#003399"><i>/*
 * Copyright (c) 1992-2002 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */</i></font>

<font color="#003399"><i>/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * &quot;as is&quot; without express or implied warranty.
 V3.13:0009 */</i></font>

</code></pre>

</body>
</html>

