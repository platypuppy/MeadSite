<html>
<head>
<link rel="stylesheet" type="text/css" href="new.css">
<title>STL-1</title>

<style>
.Trivia
{
  margin-left: 0;
  /*font-size : 12pt;*/
  /*font-weight : bold;*/
  background-color: #efefef; 
  border-style: solid;
  border-color: blue;
  border-width: thick;
  vertical-align: top;
  padding-top: 3px;
  padding-bottom : 3px;
  padding-left: 10px;
  padding-right: 10px;
}   
</style>


</head>

<body>  
<center><h1>STL Components</h1></center>

<!--
<a href="STL-Intro.html">Basic introduction to the Standard Template Library</a>
-->
<p>

This is from the introduction in Scott Meyer's book <i>Effective STL: 50 Specific Ways to Improve
Your Use of the Standard Template Library</i>:
<p>
<blockquote>
<b>Introduction</b>
<p>
You're already familiar with the STL. You know how to create containers, iterate over their contents, add and remove
elements, and apply common algorithms, such as find and sort. But you're not satisfied. You can't shake the sensation 
that the STL offers more than you're taking advantage of. Tasks that should be simple aren't. Operations that should be 
straightforward leak resources or behave erratically. Procedures that should be efficient demand more time or memory
than you're willing to give them. Yes, you know how to use the STL, but you're not sure you're using it <i>effectively</i>.
<p>
I wrote this book for you.
<p>
In <i>Effective STL</i>, I explain how to combine STL components to take full advantage of the library's design. Such information
allows you to develop simple, straightforward solutions to simple, straightforward problems, and it also helps you design
elegant approaches to more complicated problems. I describe common STL usage errors, and I show you how to avoid them.
That helps you dodge resource leaks, code that won't port, and behavior that is undefined. I discuss ways to optimize your
code, so you can make the STL perform like the fast, sleek machine it is intended to be.
<p class="Trivia">
The information in this book will make you a better STL programmer. It will make you a more productive programmer. 
And it will make you a happier programmer. Using the STL is fun, but using it effectively is outrageous fun, the kind
of fun where they have to drag you away from the keyboard, because you just can't believe the good time you're having.
Even a cursory glance at the STL reveals that it is a wondrously cool library, but the coolness runs broader and deeper
than you probably imagine. One of my primary goals in this book is to convey to you just how amazing the library is,
because in the nearly 30 years I've been programming, I've never seen anything like the STL. You probably haven't either.
</p>
</blockquote>


<!-- ************************************************************************************************ -->
<!-- ************************************************************************************************ -->
<p class="SectionHeader">
Components
</p>



Several components make up the Standard Template Library. Three of which are:

<ul>
<li><b>Containers</b>
<ul>
<li>Manage a collection (container) of objects of the same type.
<li>May be implemented as an array, linked-list, tree, or other type of structure. 
<li>The different kinds of containers reflect the different implementations and uses.
</ul>
<li><b>Iterators</b>
<ul>
<li>Iterators are used to traverse a container (or "walk a container") or subset of a container. 
<li>They provide a common interface for iterating over a collection of objects. (e.g. iterate over an array
vs. iterating over a linked-list.) 
<li>They are similar to pointers in that an iterator will "point" to the "next" object in the container.
<li>The concept of "next" varies among different containers. (e.g. the next element in an array vs. the
next element in a binary tree)
<li>Iterators are the "glue" between containers and algorithms.
</ul>
<li><b>Algorithms</b>
<ul>
<li>Algorithms are applied to containers (actually, ranges within containers) to process the elements.
<li>There are algorithms to <b>search</b>, <b>sort</b>, or otherwise access or modify the container 
and/or its elements.
<li>The algorithms work closely with iterators.
<li>These algorithms are often referred to as <i>generic algorithms</i> because they can be applied
to almost any type of container or element. 
<li>This allows an algorithm to be written once that can be used, for example, to search a list of
integers, or an array (vector) of strings, or a tree of Foo objects.
<li>In addition to the iterators, the generic algorithms can also be directed how to perform their
functions by supplying <i>function objects</i> or <i>functors</i> to the algorithm. (These are
similar in use to supplying function pointers (callbacks) to plain functions in C/C++.)
</ul>
</ul>

In one way, the STL separates the data from the algorithms, which is in stark contrast to how the 
object-oriented paradigm is supposed to work. 
<p>

<hr>
<h2>More #pragmas for Suppressing Warnings</h2>

(Some of these are now obsolete with Microsoft C++ 7.1)

<pre class="sourcecode"><code>
<b>#ifdef</b> _MSC_VER
<b>#pragma</b> <b>warning</b>(<b>disable</b>: 4290) <font color="#003399"><i>// Suppress 'C++ Exception Specification ignored'</i></font>
<b>#pragma</b> <b>warning</b>(<b>disable</b>: 4710) <font color="#003399"><i>// Suppress 'function ... not inlined' for Release builds</i></font>
<b>#pragma</b> <b>warning</b>(<b>disable</b>: 4514) <font color="#003399"><i>// Suppress '... unreferenced inline function has been removed'</i></font>
<b>#pragma</b> <b>warning</b>(<b>disable</b>: 4786) <font color="#003399"><i>// Suppress '... truncated to 255 chars in debug'</i></font>
<b>#pragma</b> <b>warning</b>(<b>push</b>, 3)       <font color="#003399"><i>// Set warning levels to a quieter level for the STL</i></font>
<b>#endif</b>

<b>#include</b> &lt;iostream&gt;
<b>#include</b> &lt;vector&gt;
<b>#include</b> &lt;deque&gt;
<b>#include</b> &lt;list&gt;
<b>#include</b> &lt;string&gt;
<b>#include</b> &lt;set&gt;
<b>#include</b> &lt;map&gt;
<b>#include</b> &lt;stack&gt;
<b>#include</b> &lt;queue&gt;
<b>#include</b> &lt;algorithm&gt;

<b>#ifdef</b> _MSC_VER
<b>#pragma</b> <b>warning</b>(<b>pop</b>)           <font color="#003399"><i>// Restore warning levels for our code</i></font>
<b>#endif</b>
</code></pre>

<!-- ************************************************************************************************ -->
<!-- ************************************************************************************************ -->
<hr>
<p class="SectionHeader">
Containers


<p class="technote">
Sure, the STL has iterators, algorithms, and function objects, but for most C++ programmers, it's the
containers that stand out. More powerful and flexible than arrays, they grow (and often shrink) 
dynamically, manage their own memory, keep track of how many objects they hold, bound the algorithmic
complexity of the operations they support, and much, much more. Their popularity is easy to understand.
They're simply better than their competition, regardless of whether that competition comes from
containers in other libraries or is a container type you'd write yourself. STL containers aren't just
good. They're <i>really</i> good. -- Scott Meyers in <i>Effective STL</i>
</p>

STL containers provide <i>value semantics</i>, meaning that they contain a copy of the object
you add. (As opposed to the original object.) There are requirements for elements added to
an STL container:
<ul>
<li>Elements must be copyable via a public copy constructor. 
<li>Elements must be assignable via a public assignment operator.
<li>Elements must be destroyable via a public destructor (which must not throw).
<li>All built-in types (like <b>int</b> and <b>double</b>) meet the above requirements.
</ul>

Implementation-wise, there are essentially two types of containers:
<ul>
<li><b>Array-based</b> - Stores elements in one or more (dynamically allocated) arrays of elements. 
Inserting into or removing from the middle (non-ends) of the structure is expensive. 
Standard containers <b>vector</b>, <b>deque</b>, and <b>string</b> are array-based.
<li><b>Node-based</b> - Stores elements in single (dynamically allocated) chunks of memory, much like
a linked list. Inserting into or removing from the middle is cheap (just update pointers.) Standard
containers such as <b>list</b>, <b>set</b>, and <b>map</b> are node-based.
</ul>

Sequence containers
<ul>
<li>Are <i>ordered collections</i> of objects, each object has a position.
<li>The position depends on the time the object arrived in the collection. (Temporal ordering)
<li>The position is independent of the value of the object.
<li>Some types of sequence containers:
<ul>
<li>Vector - A dynamic array, meant for adding to end. (<b>push_back</b>)
<li>Deque - (Note spelling, not Dequeue, pronounced <i>deck</i>) A double-ended queue, meant for adding at either end. (<b>push_front</b>/<b>push_back</b>) 
<li>List - A (doubly) linked list, typical usage and complexity.
</ul>
<li>Other, more specialized containers are <i>container adapters</i>: Stack, Queue, Priority Queue
<li>Each container implementation has its own complexities.
</ul>


Associative containers
<ul>
<li>Are <i>sorted collections</i> of objects, each object's position is determined
by its value.
<li>Associate containers always remain sorted because items are inserted into
the correct position.
<li>Some types of ordered containers:
<ul>
<li>Set - No duplicates, each value occurs only once.
<li>Multiset - Same as a set but it allows duplicates.
<li>Map - Elements are stored as key/value pairs. The key is used for the sort. Duplicate
keys are not allowed. (Used to implement <i>associative arrays</i>)
<li>Multimap - Same as map except that duplicate keys are allowed. This means that one
key may have multiple values associated with it. (Used to implement a <i>dictionary</i>).
</ul>
<li>You can specify the sort order when you create an associative container. (The default is to use
the less-than, <, operator).
<li>Associative containers are usually implemented as a binary tree. (Red-Black tree)
</ul>

Why the differences?

<ul>
<li>The different containers were created for different purposes. (efficiency)
<li>You want to choose the container that has the best performance: constant time</i>,
logarithmic time, or linear time).
<li>Usually, if a container is "missing" a method, it was not provided because it was
too inefficient. (e.g. there is no <b>push_front</b> method of a vector).
</ul>


<!-- ************************************************************************************************ -->
<!-- ************************************************************************************************ -->
<p class="SectionHeader">
Vectors
</p>

A dynamic array, meant for adding items to the end. Add this header file: 

<blockquote><pre>
<b>#include</b> &lt;vector&gt;
</pre></blockquote>

to the program.
<p>
Example:

<pre class="sourcecode"><code><b>int</b> main(<b>void</b>)
{
  <b>unsigned</b> i;

    <font color="#003399"><i>// Create empty vector of integers</i></font>
  std::vector&lt;<b>int</b>&gt; cont1;

    <font color="#003399"><i>// Add 7 random integers (each added at the end)</i></font>
  cont1.push_back(2);
  cont1.push_back(3);
  cont1.push_back(7);
  cont1.push_back(5);
  cont1.push_back(4);
  cont1.push_back(6);
  cont1.push_back(1);

    <font color="#003399"><i>// Print out the elements using subscripts</i></font>
  <b>for</b> (i = 0; i &lt; cont1.size(); ++i)
    std::cout &lt;&lt; cont1[i] &lt;&lt; <font color="#9933CC">&quot;  &quot;</font>;
  std::cout &lt;&lt; std::endl;

  cont1[2] = 8;    <font color="#003399"><i>// change the 3rd element to 8 (using subscript operator)</i></font>
  cont1.at(3) = 9; <font color="#003399"><i>// change the 4th element to 9 (using at method)</i></font>

  cont1[15] = 13;    <font color="#003399"><i>// attempt to change the 16th element (undefined behavior)</i></font>
  cont1.at(15) = 13; <font color="#003399"><i>// attempt to change the 16th element (throws std::out_of_range exception)</i></font>

    <font color="#003399"><i>// Print out the elements</i></font>
  <b>for</b> (i = 0; i &lt; cont1.size(); ++i)
    std::cout &lt;&lt; cont1[i] &lt;&lt; <font color="#9933CC">&quot;  &quot;</font>;

  std::cout &lt;&lt; std::endl;

    <font color="#003399"><i>// Display the number of elements in the container</i></font>
  std::cout &lt;&lt; <font color="#9933CC">&quot;size: &quot;</font> &lt;&lt; cont1.size() &lt;&lt; std::endl;

    <font color="#003399"><i>// Display the amount of elements that can be accommodated</i></font>
    <font color="#003399"><i>// without reallocating</i></font>
  std::cout &lt;&lt; <font color="#9933CC">&quot;capacity &quot;</font> &lt;&lt; cont1.capacity() &lt;&lt; std::endl &lt;&lt; std::endl;

  cont1.clear();  <font color="#003399"><i>// Remove all elements (calling destructors, if any)</i></font>

    <font color="#003399"><i>// Show size and capacity after clear</i></font>
  std::cout &lt;&lt; <font color="#9933CC">&quot;size: &quot;</font> &lt;&lt; cont1.size() &lt;&lt; std::endl;
  std::cout &lt;&lt; <font color="#9933CC">&quot;capacity &quot;</font> &lt;&lt; cont1.capacity() &lt;&lt; std::endl;
</code></pre>

Output:
<blockquote><pre>
2  3  7  5  4  6  1
2  3  8  9  4  6  1
size: 7
capacity 8

size: 0       
capacity 8
</pre></blockquote>

Adding code to above:

<pre class="sourcecode"><code>  
    <font color="#003399"><i>// Add some elements</i></font>
  <b>for</b> (i = 0; i &lt; 7; ++i)
    cont1.push_back(i);

    <font color="#003399"><i>// Show size and capacity</i></font>
  std::cout &lt;&lt; <font color="#9933CC">&quot;size: &quot;</font> &lt;&lt; cont1.size() &lt;&lt; std::endl;
  std::cout &lt;&lt; <font color="#9933CC">&quot;capacity &quot;</font> &lt;&lt; cont1.capacity() &lt;&lt; std::endl;

    <font color="#003399"><i>// Add two more</i></font>
  cont1.push_back(0);
  cont1.push_back(0);

    <font color="#003399"><i>// Show size and capacity</i></font>
  std::cout &lt;&lt; <font color="#9933CC">&quot;size: &quot;</font> &lt;&lt; cont1.size() &lt;&lt; std::endl;
  std::cout &lt;&lt; <font color="#9933CC">&quot;capacity &quot;</font> &lt;&lt; cont1.capacity() &lt;&lt; std::endl;

  <b>return</b> 0;
}</code></pre>

Output:
<blockquote><pre>
size: 7
capacity 8

size: 9
capacity 16
</pre></blockquote>

Oh, but if it were only true... From: <tt> comp.lang.c++ &gt; std::vector&lt;&gt;::clear semantics:</tt>
<p>
<a href="http://groups-beta.google.com/group/comp.lang.c++/msg/fc1d1e3a14b6e7c2?q=std::vector+clear+sets+capacity+to+0&hl=en&lr=&rnum=1">
message 1</a>
<br>
<a href="http://groups-beta.google.com/group/comp.lang.c++/msg/99146553bf9fdec?hl=en&lr=">message 2</a>
<p>

So, the original output above (from MSC++ 6.0, g++, Borland, and probably every other compiler) now looks like this in MSC++ 7.1

<blockquote><pre>
2  3  7  5  4  6  1
2  3  8  9  4  6  1
size: 7
capacity 9

size: 0       
capacity 0
</pre></blockquote>

<p>
Fortunately, Microsoft has now reverted back to the original way of preserving the capacity.
<p>



Another example:

<p>

<pre class="sourcecode"><code><font color="#003399"><i>// Create an empty vector of integers</i></font>
std::vector&lt;<b>int</b>&gt; cont1;

  <font color="#003399"><i>// Show size and capacity</i></font>
std::cout &lt;&lt; <font color="#9933CC">&quot;Empty:&quot;</font> &lt;&lt; std::endl;
std::cout &lt;&lt; <font color="#9933CC">&quot;size = &quot;</font> &lt;&lt; std::setw(2) &lt;&lt; cont1.size();
std::cout &lt;&lt; <font color="#9933CC">&quot;, capacity = &quot;</font> &lt;&lt; std::setw(2) &lt;&lt; cont1.capacity() &lt;&lt; std::endl;

std::cout &lt;&lt; <font color="#9933CC">&quot;Adding 18 integers:&quot;</font> &lt;&lt; std::endl;
<b>for</b> (<b>int</b> i = 0; i &lt; 18; i++)
{
  cont1.push_back(i);
  std::cout &lt;&lt; <font color="#9933CC">&quot;size = &quot;</font> &lt;&lt; std::setw(2) &lt;&lt; cont1.size();
  std::cout &lt;&lt; <font color="#9933CC">&quot;, capacity = &quot;</font> &lt;&lt; std::setw(2) &lt;&lt; cont1.capacity() &lt;&lt; std::endl;
}</code></pre>

<p>
<b>Output:</b>
<p>
<table>
<tr><th>MSC++ 6.0, g++, Borland, Clang, etc.</th><th>MSC++ 7.1 and later</th></tr> 
<tr><td>
<blockquote><pre>
Empty:
size =  0, capacity =  0
Adding 18 integers:
size =  1, capacity =  1
size =  2, capacity =  2
size =  3, capacity =  4
size =  4, capacity =  4
size =  5, capacity =  8
size =  6, capacity =  8
size =  7, capacity =  8
size =  8, capacity =  8
size =  9, capacity = 16
size = 10, capacity = 16
size = 11, capacity = 16
size = 12, capacity = 16
size = 13, capacity = 16
size = 14, capacity = 16
size = 15, capacity = 16
size = 16, capacity = 16
size = 17, capacity = 32
size = 18, capacity = 32
</pre></blockquote>
</td>

<td>
<blockquote><pre>
Empty:
size =  0, capacity =  0
Adding 18 integers:
size =  1, capacity =  1
size =  2, capacity =  2
size =  3, capacity =  3
size =  4, capacity =  4
size =  5, capacity =  6
size =  6, capacity =  6
size =  7, capacity =  9
size =  8, capacity =  9
size =  9, capacity =  9
size = 10, capacity = 13
size = 11, capacity = 13
size = 12, capacity = 13
size = 13, capacity = 13
size = 14, capacity = 19
size = 15, capacity = 19
size = 16, capacity = 19
size = 17, capacity = 19
size = 18, capacity = 19
</pre></blockquote>

</td></tr></table>
<p>


<blockquote><pre>
</pre></blockquote>

<p class="technote">
<b>Self-check</b> Compile the samples above and see how each compiler deals with the capacity. 
</p>

<p>
<hr width="90%">
<p>

<a name="VECTORMETHODS">
Other popular methods for vector:
</a>

<ul>
<li><b>push_back()</b> Add an element to the end (<i>without</i> growing the internal array). (Constant time)</i>
<li><b>insert()</b> Add at a particular position. (Linear time)</i>
<li><b>begin()</b> and <b>end()</b> Return iterators to the first element and (one past) the last element, respectively.
<li><b>erase()</b> Deletes an element or range of elements. Elements may need to be shifted (linear time); Capacity
is not reduced.
<li><b>clear()</b> Deletes all elements (linear time). Capacity is not reduced. (<i>caveat emptor</i>)
<li><b>empty()</b> Returns true if the vector is empty, otherwise false.
<li><b>operator[]</b> and <b>at()</b> Get/Set an element by index.
<ul>
<li>The overloaded subscript operator for reading/writing to the vector doesn't throw when 
subscript is out of range, but certainly will corrupt memory if the subscript is out of range.
<li>The <i>at(int index)</i> method for reading and writing elements does throw when subscript is out of range.
</ul>
<li><b>front()</b> and <b>back()</b> Return the first and last element, respectively.
<li><b>size()</b> Returns the number of elements in the vector.
<li><b>capacity()</b> Returns the number of elements that can be placed in the vector <i>without 
growing the vector</i>. 
<li><a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcstdlib/html/vclrfvectorswap.asp">
swap()</a> Exchanges the elements of two vectors. (Constant time)</i>
</ul>

Features
<ul>
<li>Use a vector when you need array semantics (random access for reading, writing to the end).
<li>Automatically resizes so that you don't have to worry about writing past the end.
<li>Use <b>reserve</b> to avoid unnecessary re-allocations.
<li>You can "preallocate" the amount of space you need to avoid the overhead of resizing.
<li>Inserting and deleting will invalidate pointers or iterators to elements that <i>follow</i> the
insertion or deletion.
<ul>
<li>If a reallocation occurs, all pointers and iterators are invalidated.
</ul>
</ul>

Constructors:
<p>
<!--
<ul>
<li><tt>vector&lt;<i>type</i>&gt; v</tt> - Defalut constructor creates an empty vector.
<li><tt>vector&lt;<i>type</i>&gt; v1(v2)</tt> - Copy constructor.
<li><tt>vector&lt;<i>type</i>&gt; v(n)</tt> - Creates a vector with <i>n</i> elements set to default value. (Default constructor)
<li><tt>vector&lt;<i>type</i>&gt; v(n, value)</tt> - Creates a vector with <i>n</i> elements set to <i>value</i>.
<li><tt>vector&lt;<i>type</i>&gt; v(beg, end)</tt> - Creates a vector from the specified range of elements.
</ul>
-->

<blockquote>
<table border=0>
<tr><td><tt>vector&lt;<i>type</i>&gt; v</tt></td><td width=20></td><td>Defalut constructor creates an empty vector.</td></tr>
<tr><td><tt>vector&lt;<i>type</i>&gt; v1(v2)</tt></td><td width=20></td><td>Copy constructor.</td></tr>
<tr><td><tt>vector&lt;<i>type</i>&gt; v(n)</tt></td><td width=20></td><td>Creates a vector with <i>n</i> elements set to default value. (Default constructor)</td></tr>
<tr><td><tt>vector&lt;<i>type</i>&gt; v(n, value)</tt></td><td width=20></td><td>Creates a vector with <i>n</i> elements set to <i>value</i>.</td></tr>
<tr><td><tt>vector&lt;<i>type</i>&gt; v(beg, end)</tt></td><td width=20></td><td>Creates a vector from the specified range of elements.</td></tr>
</table>
</blockquote>
<p>


We'll use this class <i>Foo</i> so we can see the constructions:

<pre class="sourcecode"><code><b>class</b> Foo
{
  <b>public</b>:
    Foo(<b>int</b> x = 2) {
      std::cout &lt;&lt; <font color="#9933CC">&quot;In Foo constructor: x = &quot;</font> &lt;&lt; x &lt;&lt; std::endl;
      x_ = x;
    };

    Foo (<b>const</b> Foo&amp; rhs) {
      std::cout &lt;&lt; <font color="#9933CC">&quot;In Foo copy constructor: x = &quot;</font> &lt;&lt; rhs.x_ &lt;&lt; std::endl;
      x_ = rhs.x_;
    }

    <b>int</b> GetX(<b>void</b>) <b>const</b> { 
      <b>return</b> x_; 
    }

  <b>private</b>:
    <b>int</b> x_;
};

std::ostream &amp; <b>operator</b>&lt;&lt;(std::ostream &amp;os, <b>const</b> Foo &amp;foo)
{
  <b>return</b> os &lt;&lt; foo.GetX();
}</code></pre>


This program shows how the <b>resize()</b> and <b>reserve()</b> methods work:

<pre class="sourcecode"><code><b>int</b> main(<b>void</b>)
{
    <font color="#003399"><i>// Create vector of 5 Foo objects (5 constructor calls)</i></font>
  std::vector&lt;Foo&gt; cont1(5);
  
    <font color="#003399"><i>// Show size and capacity</i></font>
  std::cout &lt;&lt; <font color="#9933CC">&quot;size: &quot;</font> &lt;&lt; cont1.size() &lt;&lt; std::endl;
  std::cout &lt;&lt; <font color="#9933CC">&quot;capacity &quot;</font> &lt;&lt; cont1.capacity() &lt;&lt; std::endl;

    <font color="#003399"><i>// Create new vector with 8 Foo objects (5 are old, 3 are new)</i></font>
  cont1.resize(8);

    <font color="#003399"><i>// Show size and capacity</i></font>
  std::cout &lt;&lt; <font color="#9933CC">&quot;size: &quot;</font> &lt;&lt; cont1.size() &lt;&lt; std::endl;
  std::cout &lt;&lt; <font color="#9933CC">&quot;capacity &quot;</font> &lt;&lt; cont1.capacity() &lt;&lt; std::endl;

    <font color="#003399"><i>// Create a vector with space for 300 Foo objects </i></font>
    <font color="#003399"><i>// (The previous 8 Foo objects are copied into new vector)</i></font>
  cont1.reserve(300);

    <font color="#003399"><i>// Show size and capacity</i></font>
  std::cout &lt;&lt; <font color="#9933CC">&quot;size: &quot;</font> &lt;&lt; cont1.size() &lt;&lt; std::endl;
  std::cout &lt;&lt; <font color="#9933CC">&quot;capacity &quot;</font> &lt;&lt; cont1.capacity() &lt;&lt; std::endl;

  <b>return</b> 0;
}</code></pre>


<b>Output:</b>

<!--
  compiler #1 - Old MS compiler (probably)
  compiler #2 - g++ 8 and clang 6
-->

<table border=1 cellspacing=0 cellpadding=0>
<tr><th>Compiler #1</th><th>Compiler #2<br>(with dtor calls)</th></tr>
<tr>

<td valign="top">
<blockquote><pre>
  <font color="#003399"><i>// std::vector&lt;Foo&gt; cont1(5);</i></font>
In Foo constructor: x = 2
In Foo copy constructor: x = 2
In Foo copy constructor: x = 2
In Foo copy constructor: x = 2
In Foo copy constructor: x = 2
In Foo copy constructor: x = 2
size: 5
capacity 5

  <font color="#003399"><i>// cont1.resize(8);</i></font>
In Foo constructor: x = 2
In Foo copy constructor: x = 2   <font color=blue>&lt;-- original object</font>
In Foo copy constructor: x = 2   <font color=blue>&lt;-- original object</font>
In Foo copy constructor: x = 2   <font color=blue>&lt;-- original object</font>
In Foo copy constructor: x = 2   <font color=blue>&lt;-- original object</font>
In Foo copy constructor: x = 2   <font color=blue>&lt;-- original object</font>
In Foo copy constructor: x = 2   <font color=blue>&lt;-- new (default) object</font>
In Foo copy constructor: x = 2   <font color=blue>&lt;-- new (default) object</font>
In Foo copy constructor: x = 2   <font color=blue>&lt;-- new (default) object</font>
size: 8
capacity 10





  <font color="#003399"><i>// cont1.reserve(300);</i></font>
In Foo copy constructor: x = 2
In Foo copy constructor: x = 2
In Foo copy constructor: x = 2
In Foo copy constructor: x = 2
In Foo copy constructor: x = 2
In Foo copy constructor: x = 2
In Foo copy constructor: x = 2
In Foo copy constructor: x = 2
size: 8
capacity 300
</pre></blockquote>

</td>
<td>

<blockquote><pre>
  <font color="#003399"><i>// std::vector&lt;Foo&gt; cont1(5);</i></font>
In Foo constructor: x = 2
In Foo constructor: x = 2
In Foo constructor: x = 2
In Foo constructor: x = 2
In Foo constructor: x = 2

size: 5
capacity 5

  <font color="#003399"><i>// cont1.resize(8);</i></font>
In Foo copy constructor: x = 2
In Foo copy constructor: x = 2
In Foo copy constructor: x = 2
In Foo copy constructor: x = 2
In Foo copy constructor: x = 2
In Foo constructor: x = 2
In Foo constructor: x = 2
In Foo constructor: x = 2
In Foo destructor: x = 2  <font color=blue>&lt;-- old vector deleted</font>
In Foo destructor: x = 2
In Foo destructor: x = 2
In Foo destructor: x = 2
In Foo destructor: x = 2
size: 8
capacity 10

  <font color="#003399"><i>// cont1.reserve(300);</i></font>
In Foo copy constructor: x = 2
In Foo copy constructor: x = 2
In Foo copy constructor: x = 2
In Foo copy constructor: x = 2
In Foo copy constructor: x = 2
In Foo copy constructor: x = 2
In Foo copy constructor: x = 2
In Foo copy constructor: x = 2
In Foo destructor: x = 2  <font color=blue>&lt;-- old vector deleted</font>
In Foo destructor: x = 2
In Foo destructor: x = 2
In Foo destructor: x = 2
In Foo destructor: x = 2
In Foo destructor: x = 2
In Foo destructor: x = 2
In Foo destructor: x = 2
size: 8
capacity 300
In Foo destructor: x = 2  <font color=blue>&lt;-- vector goes out of scope</font>
In Foo destructor: x = 2
In Foo destructor: x = 2
In Foo destructor: x = 2
In Foo destructor: x = 2
In Foo destructor: x = 2
In Foo destructor: x = 2
In Foo destructor: x = 2
</pre></blockquote>

</td>
</tr></table>
<p>

<p class="technote">
<b>Self-check</b> Try the example above with different compilers and observe the results. Can you explain the output?
<!--To <i>really</i> understand, you will need to step into the code with a debugger. Microsoft's 7.1 compiler will likely
give you different results from GNU or Borland.--> Is the output different?
</p>

Using the <b>reserve()</b> method <i>before</i> putting anything into the container:

<pre class="sourcecode"><code><b>int</b> main(<b>void</b>)
{
    <font color="#003399"><i>// Create an empty vector </i></font>
  std::vector&lt;Foo&gt; cont1;
  
    <font color="#003399"><i>// Show size and capacity</i></font>
  std::cout &lt;&lt; <font color="#9933CC">&quot;size: &quot;</font> &lt;&lt; cont1.size() &lt;&lt; std::endl;
  std::cout &lt;&lt; <font color="#9933CC">&quot;capacity &quot;</font> &lt;&lt; cont1.capacity() &lt;&lt; std::endl;

    <font color="#003399"><i>// Create new vector with space for 300 Foo objects </i></font>
  cont1.reserve(300);

    <font color="#003399"><i>// Show size and capacity</i></font>
  std::cout &lt;&lt; <font color="#9933CC">&quot;size: &quot;</font> &lt;&lt; cont1.size() &lt;&lt; std::endl;
  std::cout &lt;&lt; <font color="#9933CC">&quot;capacity &quot;</font> &lt;&lt; cont1.capacity() &lt;&lt; std::endl;

  <b>return</b> 0;
}</code></pre>


<b>Output:</b>
<blockquote><pre>
  <font color="#003399"><i>// std::vector&lt;Foo&gt; cont1; </i></font>
size: 0
capacity 0

  <font color="#003399"><i>// cont1.reserve(300);</i></font>
size: 0
capacity 300
</pre></blockquote>

Notes:
<ul>
<li>Resizing to a smaller size will remove items from the end (destructors will be called).
<li>Resizing to a larger size will cause items to be added to end (default constructor calls).
<li>Capacity may be larger than size.
<li>Capacity is usually not reduced when resizing to a smaller size. <i>vector.end()</i> 
returns a pointer (iterator) to the end of the elements, <i>not</i> the end of the
container. 
<li>To trim excess capacity, use the <i>swap trick</i> or <i>shrink-to-fit</i>:

<pre class="sourcecode"><code><b>int</b> main(<b>void</b>)
{
  <b>int</b> i;

    <font color="#003399"><i>// Create an empty vector </i></font>
  std::vector&lt;<b>int</b>&gt; cont1;

    <font color="#003399"><i>// Add 1000 elements</i></font>
  <b>for</b> (i = 0; i &lt; 1000; ++i)
    cont1.push_back(i);

    <font color="#003399"><i>// Show size and capacity</i></font>
  std::cout &lt;&lt; <font color="#9933CC">&quot;size: &quot;</font> &lt;&lt; cont1.size() &lt;&lt; std::endl;
  std::cout &lt;&lt; <font color="#9933CC">&quot;capacity &quot;</font> &lt;&lt; cont1.capacity() &lt;&lt; std::endl;

    <font color="#003399"><i>// Remove the last 950</i></font>
  <b>for</b> (i = 0; i &lt; 950; ++i)
    cont1.pop_back();

    <font color="#003399"><i>// Show size and capacity</i></font>
  std::cout &lt;&lt; <font color="#9933CC">&quot;size: &quot;</font> &lt;&lt; cont1.size() &lt;&lt; std::endl;
  std::cout &lt;&lt; <font color="#9933CC">&quot;capacity &quot;</font> &lt;&lt; cont1.capacity() &lt;&lt; std::endl;

    <font color="#003399"><i>// Swap &quot;trick&quot;</i></font>
  std::vector&lt;<b>int</b>&gt;(cont1).swap(cont1);

    <font color="#003399"><i>// Show size and capacity</i></font>
  std::cout &lt;&lt; <font color="#9933CC">&quot;size: &quot;</font> &lt;&lt; cont1.size() &lt;&lt; std::endl;
  std::cout &lt;&lt; <font color="#9933CC">&quot;capacity &quot;</font> &lt;&lt; cont1.capacity() &lt;&lt; std::endl;

  <b>return</b> 0;
}</code></pre>

<b>Output:</b>
<blockquote><pre>
size: 1000
capacity 1024
size: 50
capacity 1024
size: 50
capacity 50
</pre></blockquote>

</ul>

A closer look at the swap. This is how the swap works (long way):
<p>
<blockquote><pre>
std::vector&lt;<b>int</b>&gt; temp(cont1); <font color="#003399"><i>// Construct temp via copy constructor</i></font>
temp.swap(cont1);             <font color="#003399"><i>// Swap contents of cont1 with temp</i></font>
    <font color="#003399"><i>// temp eventually goes out of scope and is cleaned up</i></font>
</pre></blockquote>

This is the short way, using an unnamed temporary:
<p>

<blockquote><pre>
    <font color="#003399"><i>// Swap trick</i></font>
  std::vector&lt;<b>int</b>&gt;(cont1).swap(cont1);
</pre></blockquote>

<ol>
<li>An unnamed temporary <tt>std::vector&lt;<b>int</b>&gt;</tt> is constructed 
from <tt>cont1</tt>.
<blockquote><pre>
std::vector&lt;<b>int</b>&gt;(cont1)  <font color="#003399"><i>// unnamed_temp</i></font>
</pre></blockquote>
<li>The <tt>swap</tt> method of the unnamed temporary is called with <tt>cont1</tt> as
the parameter.
<blockquote><pre>
<i>unnamed_temp</i>.swap(cont1);
</pre></blockquote>
<li>The contents are swapped between the two containers.
<li>The destructor for the unnamed temporary is called immediately after the swap.
</ol>

Note that the <tt>swap</tt> method is very efficient. It is only swapping the pointers
to the internal arrays, not the elements themselves.

<p class="technote">
Newer C++ STL libraries have added a 
<a href="http://www.cplusplus.com/reference/vector/vector/shrink_to_fit/"><i>shrink_to_fit</i></a> method to the <b>std::vector</b>
class so the above is no longer necessary.

<blockquote><pre>
</pre></blockquote>


<!-- ************************************************************************************************ -->
<!-- ************************************************************************************************ -->
<p class="SectionHeader">
Using vectors with C API Functions
</p>

<pre class="sourcecode"><code><b>void</b> FillArray(<b>int</b> *array, <b>int</b> size)
{
  <b>for</b> (<b>int</b> i = 0; i &lt; size; i++)
    array[i] = i * i;
}

<b>int</b> main(<b>void</b>)
{
  <b>int</b> i, size = 10;

    <font color="#003399"><i>// Create a vector with size elements (initialized to 0) </i></font>
  std::vector&lt;<b>int</b>&gt; cont1(size);

    <font color="#003399"><i>// Print them</i></font>
  <b>for</b> (i = 0; i &lt; size; ++i)
    std::cout &lt;&lt; cont1[i] &lt;&lt; <font color="#9933CC">&quot;   &quot;</font>;
  std::cout &lt;&lt; std::endl;

    <font color="#003399"><i>// Update array contents</i></font>
  FillArray(&amp;cont1[0], cont1.size());

    <font color="#003399"><i>// Print them</i></font>
  <b>for</b> (i = 0; i &lt; size; ++i)
    std::cout &lt;&lt; cont1[i] &lt;&lt; <font color="#9933CC">&quot;   &quot;</font>;
  std::cout &lt;&lt; std::endl;

  <b>return</b> 0;
}</code></pre>

<b>Output:</b>
<blockquote><pre>
0   0   0   0   0   0   0   0   0   0
0   1   4   9   16   25   36   49   64   81
</pre></blockquote>

Notes:
<ul>
<li>The C++ Standard guarantees that vector elements are stored in contiguous memory (like C arrays).
<li>You can't write into empty positions (size < capacity) because the internal data members
won't get updated. (You can't use the subscript operator to add elements.)
<li>Just like ordinary array manipulation, modifying the underlying array can be dangerous (it's up to 
the programmer to protect the data/memory).
<li>Empty vectors may contain invalid pointers to data, so check the <b>empty()</b> method first.
</ul>
<p>
More information on the methods available for 
<a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcstdlib/html/vclrfvectormembers.asp">vector members</a>
on MSDN.

<p>
<!-- ************************************************************************************************ -->
<!-- ************************************************************************************************ -->
<p class="SectionHeader">
Deques
</p>

A dynamic array, meant for adding items to both ends. Add this header file: 

<blockquote><pre>
<b>#include</b> &lt;deque&gt;
</pre></blockquote>

to the program. Deques (pronounced "Decks") are double-ended queues. 

<ul>
<li>They are also <i>array-based</i> structures.
<li>The act much like vectors and share a lot of the interface. 
<li>The primary difference is that deques can grow in both directions (from the front and back).
<li>They provide additional methods <b>push_front()</b> and <b>pop_front()</b>.
<li>There is no <b>reserve()</b> or <b>capacity()</b> method, so no control over when reallocation occurs.
<li>Unused space may be freed, so the allocated space for a deque may shrink. (Implementation dependent)
<li>Inserting and deleting will invalidate pointers or iterators to the other elements. 
<ul>
<li>This is because you have no control over (or knowledge) of when a reallocation occurs. 
<li>You must assume the worst, which is that an allocation has occurred.
<li>The exception to this rule is when an element is added to the end or the front.
</ul>
</ul>

Example:

<pre class="sourcecode"><code><b>int</b> main(<b>void</b>)
{
    <font color="#003399"><i>// Create empty deque for integers</i></font>
  std::deque&lt;<b>int</b>&gt; cont1;

    <font color="#003399"><i>// Add 7 random integers</i></font>
  cont1.push_back(2);  <font color="#003399"><i>// add to end</i></font>
  cont1.push_back(3);  <font color="#003399"><i>// add to end</i></font>
  cont1.push_back(4);  <font color="#003399"><i>// add to end</i></font>
  cont1.push_back(5);  <font color="#003399"><i>// add to end</i></font>
  cont1.push_front(6); <font color="#003399"><i>// insert at front</i></font>
  cont1.push_front(7); <font color="#003399"><i>// insert at front</i></font>
  cont1.push_front(8); <font color="#003399"><i>// insert at front</i></font>

    <font color="#003399"><i>// Print out the elements using subscripts</i></font>
  <b>for</b> (<b>unsigned</b> <b>int</b> i = 0; i &lt; cont1.size(); ++i)
    std::cout &lt;&lt; cont1[i] &lt;&lt; <font color="#9933CC">&quot;  &quot;</font>;
  std::cout &lt;&lt; std::endl;

  <b>return</b> 0;
}</code></pre>

<b>Output:</b>
<blockquote><pre>
8  7  6  2  3  4  5
</pre></blockquote>

or, we can use a different loop to print out the values (destructive):

<blockquote><pre>
<b>while</b> (!cont1.empty())
{
  std::cout &lt;&lt; cont1.front() &lt;&lt; <font color="#9933CC">&quot;  &quot;</font>;
  cont1.pop_front();
}
std::cout &lt;&lt; std::endl;
</pre></blockquote>

<p>
More information on the methods available for 
<a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcstdlib/html/vclrfdeque_members.asp">deque members</a>
on MSDN.
<p>

<!-- ************************************************************************************************ -->
<!-- ************************************************************************************************ -->
<p class="SectionHeader">
Lists
</p>

A doubly linked-list. Add this header file: 

<blockquote><pre>
<b>#include</b> &lt;list&gt;
</pre></blockquote>

Lists are double linked-lists.  

<ul>
<li>Lists are <i>node-based</i> structures, which is very different from vectors and deques. 
<li>Since there is no random-access methods (indexing), accessing an arbitrary element is expensive. (Linear time)</i>
<li>However, removing from the middle or inserting into the middle is inexpensive because only pointers
need to be manipulated. (Constant time)</i>
<li>Inserting and deleting does not invalidate pointers or iterators to the other elements.
<li>List also provides <b>push_front()</b> and <b>pop_front()</b> methods.
<li>There is no <b>reserve()</b> or <b>capacity()</b> method, since they are not necessary.
<li>Additional methods are available such as <b>sort</b>, <b>merge</b>, <b>unique</b>, and <b>splice</b>
</ul>

Example:

We will need these headers:

<blockquote><pre>
<b>#include</b> &lt;iostream&gt;
<b>#include</b> &lt;list&gt;
<b>#include</b> &lt;string&gt;
</pre></blockquote>

First, create a list and add some strings:

<blockquote><pre>
<b>int</b> main(<b>void</b>)
{
    <font color="#003399"><i>// Create empty list of strings</i></font>
  std::list&lt;std::string&gt; cont1;

    <font color="#003399"><i>// Add 7 strings</i></font>
  cont1.push_back(<font color="#9933CC">&quot;one&quot;</font>);    <font color="#003399"><i>// add to end</i></font>
  cont1.push_back(<font color="#9933CC">&quot;two&quot;</font>);    <font color="#003399"><i>// add to end</i></font>
  cont1.push_back(<font color="#9933CC">&quot;three&quot;</font>);  <font color="#003399"><i>// add to end</i></font>
  cont1.push_back(<font color="#9933CC">&quot;four&quot;</font>);   <font color="#003399"><i>// add to end</i></font>
  cont1.push_front(<font color="#9933CC">&quot;five&quot;</font>);  <font color="#003399"><i>// insert at front</i></font>
  cont1.push_front(<font color="#9933CC">&quot;six&quot;</font>);   <font color="#003399"><i>// insert at front</i></font>
  cont1.push_front(<font color="#9933CC">&quot;seven&quot;</font>); <font color="#003399"><i>// insert at front</i></font>
</pre></blockquote>

To print out the items, we might try this:

<blockquote><pre>
  <font color="#003399"><i>// Print out the elements using subscripts</i></font>
<b>for</b> (<b>unsigned</b> <b>int</b> i = 0; i &lt; cont1.size(); ++i)
  std::cout &lt;&lt; cont1[i] &lt;&lt; std::endl;   
</pre></blockquote>

but we would quickly be met with this error message: (or something similar)

<blockquote><pre>
main.cpp(476) : error C2676: binary '[' : 'class std::list<class std::basic_string<char,struct std::char_traits<char>,
class std::allocator<char> >,class std::allocator<class std::basic_string<char,struct std::
char_traits<char>,class std::allocator<char> > > >' 
does not define this operator or a conversion to a type acceptable to the predefined operator
</pre></blockquote>

There is no random access (no <tt><b>operator[]</b></tt>) so we need another way to iterate
over the list. So, we use our while loop (not a good idea):

<blockquote><pre>
  <font color="#003399"><i>// Print the contents of the list</i></font>
<b>while</b> (!cont1.empty())
{
  std::cout &lt;&lt; cont1.front() &lt;&lt; <font color="#9933CC">&quot;  &quot;</font>;
  cont1.pop_front();
}
std::cout &lt;&lt; std::endl;
</pre></blockquote>

<b>Output:</b>
<blockquote><pre>
seven  six  five  one  two  three  four
</pre></blockquote>

What we really want to do is to use an <i>iterator</i>:

<blockquote><pre>
  <font color="#003399"><i>// Declare an iterator </i></font>
std::list&lt;std::string&gt;::iterator it;

  <font color="#003399"><i>// &quot;Walk&quot; (iterate) over the list until the end</i></font>
<b>for</b> (it = cont1.begin(); it != cont1.end(); ++it)
  std::cout &lt;&lt; *it &lt;&lt; <font color="#9933CC">&quot;  &quot;</font>;  <font color="#003399"><i>// dereference the iterator to get the value</i></font>

std::cout &lt;&lt; std::endl;
</pre></blockquote>


<b>Output:</b>
<blockquote><pre>
seven  six  five  one  two  three  four
</pre></blockquote>

Summary:
<ul>
<li>The list class is essentially an abstraction of a double linked-list.
<li>There is no random access, so you can't use the subscript operator.
<li>You must traverse the elements with iterators.
<li>Adding/removing elements (anywhere in the list) is always done in constant time</i>. 
However, <i>locating</i> the item/position requires linear time.
</ul>

<blockquote><pre>
</pre></blockquote>


<p>
More information on the methods available for 
<a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcstdlib/html/vclrflist_members.asp">list members</a>
on MSDN.


<!-- ************************************************************************************************ -->
<!-- ************************************************************************************************ -->
<p class="SectionHeader">
Iterators
</p>

Iterators provide a generic method for traversing the standard containers. 

<ul>
<li>Iterators are objects (instantiated from classes) so they have an interface that clients can use.
<li>All of the standard containers support iterators, so the code for accessing elements is similar
between containers. 
<li>In keeping with abstraction, this hides the implementation details of the container. (e.g. Code
for traversing an array is different than code for traversing a linked-list.)
<li>An example of using iterators on a vector:
</ul>

<pre class="sourcecode"><code>    <font color="#003399"><i>// Create vector, add 5 integers</i></font>
  std::vector&lt;<b>int</b>&gt; cont1;
  <b>for</b> (<b>int</b> i = 0; i &lt; 5; ++i)
    cont1.push_back(i);

    <font color="#003399"><i>// Create an iterator of the proper type</i></font>
  std::vector&lt;<b>int</b>&gt;::iterator iter;

    <font color="#003399"><i>// Iterate over the container, printing each element</i></font>
  <b>for</b> (iter = cont1.begin(); iter != cont1.end(); ++iter)
    std::cout &lt;&lt; *iter &lt;&lt; <font color="#9933CC">&quot;  &quot;</font>;
</code></pre>

<b>Output:</b>
<blockquote><pre>
0  1  2  3  4
</pre></blockquote>


A closer look at this syntax:

<blockquote><pre>
  <font color="#003399"><i>// Create an iterator of the proper type</i></font>
std::vector&lt;<b>int</b>&gt;::iterator iter;
</pre></blockquote>


<blockquote><pre>
</pre></blockquote>

<blockquote><pre>
</pre></blockquote>

Suppose we add a public <b>typedef</b> to a class:
<p>

<blockquote><pre>
<b>namespace</b> DigiPen
{
  <b>class</b> Foo
  {
    <b>public</b>:
      <b>typedef</b> <b>int</b> FooInt;   <font color="#003399"><i>// public typedef</i></font>
  };
}
</pre></blockquote>

<a name="ITERATOR_TYPEDEF">
Now we can use the <b>typedef</b>:
</a>
<p>

<blockquote><pre>
  <font color="#003399"><i>// Declare variable 'i' as type DigiPen::Foo::FooInt</i></font>
DigiPen::Foo::FooInt i;
</pre></blockquote>


All container classes provide an iterator <b>typedef</b>. The <i>vector</i> class looks 
something like this:
<p>

<blockquote><pre>
<b>namespace</b> std
{
  <b>template</b> &lt;<b>typename</b> T&gt;
  <b>class</b> vector
  {
    <b>public</b>:
        <font color="#003399"><i>// Nested templated class (uses same T as above)</i></font>
      <b>class</b> vector_iterator : <b>public</b> std::iterator&lt;std::random_access_iterator_tag, T&gt;
      {
        <font color="#003399"><i>// ...</i></font>
      };

      <b>typedef</b> vector_iterator iterator; <font color="#003399"><i>// public iterator</i></font>
  };
}
</pre></blockquote>

That allows us to use <i>iterator</i> as a type: 
<p>

<blockquote><pre>
  <font color="#003399"><i>// Create an iterator of the proper type</i></font>
std::vector&lt;<b>int</b>&gt;::iterator iter;
</pre></blockquote>



<blockquote><pre>
</pre></blockquote>


Common syntax of declaring the variable within the <b>for</b> loop:
(<a href="STL-1.html#VECTORMETHODS">vector methods</a>)

<blockquote><pre>
  <font color="#003399"><i>// Iterate over the container, printing each element</i></font>
<b>for</b> (std::vector&lt;<b>int</b>&gt;::iterator iter = cont1.begin(); iter != cont1.end(); ++iter)
  std::cout &lt;&lt; *iter &lt;&lt; <font color="#9933CC">&quot;  &quot;</font>;
</pre></blockquote>

Using a <b>typedef</b> in the client for convenience: (this example uses <tt>std::list</tt>)

<blockquote><pre>
  <font color="#003399"><i>// Create a typedef for an iterator that's used</i></font>
  <font color="#003399"><i>// with lists of integers</i></font>
<b>typedef</b> std::list&lt;<b>int</b>&gt;::iterator IntIter;

  <font color="#003399"><i>// Use the typedef to declare a loop variable</i></font>
<b>for</b> (IntIter iter = cont1.begin(); iter != cont1.end(); ++iter)
  std::cout &lt;&lt; *iter &lt;&lt; <font color="#9933CC">&quot;  &quot;</font>;
</pre></blockquote>


<hr width=90%>
<p>

Common usage:

<ul>
<li><b>begin()</b> Returns an iterator that references the first element in the container.
<li><b>end()</b> Returns an iterator that references <i>one past</i> the last element in the container.
<li><b>*iter</b> Returns the object referenced by <i>iter</i>.
</ul>

Since containers are instantiated from templates, their associated iterators are also instantiated
from templates. The type <i>iterator</i> is defined in the container as a <b>typedef</b>. So, our code
looks like this:

<blockquote><pre>
  <font color="#003399"><i>// Create an iterator for a <font color="blue"><b>vector</b></font> of <font color="blue"><b>ints</b></font></i></font>
std::vector&lt;<b>int</b>&gt;::iterator iter;
</pre></blockquote>

This creates an iterator that can be used to iterate over a vector of integers. If we wanted to
iterate over a vector of strings:

<blockquote><pre>
  <font color="#003399"><i>// Create an iterator for a <font color="blue"><b>vector</b></font> of <font color="blue"><b>strings</b></font></i></font>
std::vector&lt;std::string&gt;::iterator iter;
</pre></blockquote>

or for a <tt>std::list</tt> of doubles:

<blockquote><pre>
  <font color="#003399"><i>// Create an iterator for a <font color="blue"><b>list</b></font> of <font color="blue"><b>doubles</b></font></i></font>
std::list&lt;<b>double</b>&gt;::iterator iter;
</pre></blockquote>

So, if our code contained a <tt>std::list</tt> of integers (instead of a <tt>std::vector</tt>):

<pre class="sourcecode"><code>    <font color="#003399"><i>// Create list, add 5 integers</i></font>
  std::list&lt;<b>int</b>&gt; cont1;
  <b>for</b> (<b>int</b> i = 0; i &lt; 5; ++i)
    cont1.push_back(i);

    <font color="#003399"><i>// Create an iterator for a list of integers</i></font>
  std::list&lt;<b>int</b>&gt;::iterator iter;

    <font color="#003399"><i>// Iterate over the container, printing each element</i></font>
  <b>for</b> (iter = cont1.begin(); iter != cont1.end(); ++iter)
    std::cout &lt;&lt; *iter &lt;&lt; <font color="#9933CC">&quot;  &quot;</font>;
</code></pre>

Note that the loop doesn't change. This is why iterators are the backbone of the <i>generic algorithms</i>.
<p>
A final example showing the client creating a <b>typedef</b> for the container as well:
<p>

<pre class="sourcecode"><code>  <font color="#003399"><i>// Any of these typedefs will work</i></font>
<b>typedef</b> std::vector&lt;<b>int</b>&gt; Container;
<font color="#003399"><i>//typedef std::list&lt;int&gt; Container;</i></font>
<font color="#003399"><i>//typedef std::deque&lt;int&gt; Container;</i></font>

  <font color="#003399"><i>// Create container, add 5 integers</i></font>
Container cont1;
<b>for</b> (<b>int</b> i = 0; i &lt; 5; ++i)
  cont1.push_back(i);

  <font color="#003399"><i>// Use the typedef to declare a loop variable</i></font>
<b>for</b> (Container::iterator iter = cont1.begin(); iter != cont1.end(); ++iter)
  std::cout &lt;&lt; *iter &lt;&lt; <font color="#9933CC">&quot;  &quot;</font>;
std::cout &lt;&lt; std::endl;
</code></pre>

<p>
<hr>
<p>

<blockquote><pre>
</pre></blockquote>


<b>Iterator Categories</b>

<ul>
<li>There are several categories of iterators, each providing different capabilities:
<ul>
<li><b>Forward</b> - Read/Write; Can only move in one direction (forward) from one element to the next.
<li><b>Bidirectional</b> - Read/Write; Can move forward and backward from one element to the next.
<li><b>Random Access</b> - Read/Write; Can access any element at any time (from any other element).
<li><b>Input</b> - Read only; Forward only. (Used for input streams)
<li><b>Output</b> - Write only; Forward only. (Used for output streams)
</ul>
<li>Not all containers provide all types of iterators. (e.g. <tt>std::list</tt> doesn't provide random access)
</ul>

<b>Forward</b> iterators have these capabilities:

<blockquote>
<table border=1 cellspacing=0>
<tr><th>Expression</th><th>Result</th></tr>
<tr><td><pre>iter_type()</pre></td><td>Instantiates an iterator of type <i>iter_type</i> (Default constructor)</tr>
<tr><td><pre>iter_type(iter)</pre></td><td>Instantiates an iterator of type <i>iter_type</i> from iter. (Copy/conversion constructor)</tr>
<tr><td><pre>*iter</pre></td><td>Dereferences the iterator (returns the object referenced by the iterator)</td></tr>
<tr><td><pre>iter->member</pre></td><td>Returns a member of the object referenced by the iterator</td></tr>
<tr><td><pre><font color="blue">++iter</font></pre></td><td><font color="blue">Increments the iterator (move to the next element). Returns incremented iterator.</font></td></tr>
<tr><td><pre><font color="blue">iter++</font></pre></td><td><font color="blue">Increments the iterator (move to the next element). Returns previous non-incremented iterator.</font></td></tr>
<tr><td><pre>iter1 = iter2</pre></td><td>Assigns iter2 to iter1</td></tr>
<tr><td><pre>iter1 == iter2</pre></td><td>Checks for equality</td></tr>
<tr><td><pre>iter1 != iter2</pre></td><td>Checks for inequality</td></tr>
</table>
</blockquote>

<!--
For pointers (not iterators), the blue items are only valid if the pointer is pointing
into an array (or contiguous memory).
-->

<b>Bidirectional</b> iterators have all of the capabilities of forward iterators, and add the ability to 
move backward through the elements:

<blockquote>
<table border=1 cellspacing=0>
<tr><th>Expression</th><th>Result</th></tr>
<tr><td><pre><font color="blue">--iter</font></pre></td><td><font color="blue">Decrements the iterator (move back one). Returns decremented iterator.</font></td></tr>
<tr><td><pre><font color="blue">iter--</font></pre></td><td><font color="blue">Decrements the iterator (move back one). Returns previous non-decremented iterator.</font></td></tr>
</table>
</blockquote>

<b>Random access</b> iterators provide all of the capabilities of bidirectional iterators, but add some other
functionality:

<ol>
<li>Use of the subscript operator for accessing any element.
<li><i>iterator arithmetic</i> (much like pointer arithmetic) for moving to any element, e.g.
<blockquote><pre>
iter + i;
iter - i;
iter += i;
</pre></blockquote>
<li>Comparison operators for determining the relative positions of two iterators, e.g.
<blockquote><pre>
iter1 < iter2;
iter1 > iter2;
iter1 <= iter2;
iter1 >= iter2;
</pre></blockquote>
</ol>

Different containers provide different iterators:

<blockquote>
<table border=1 cellpadding=4>
<tr><th>Example Container</th><th>Iterator</th></tr>
<tr><td>vector, deque, string</td><td>random access</td></tr>
<tr><td>list, set, map, multiset, multimap</td><td>bidirectional</td></tr>
<tr><td>forward_list</td><td>forward</td></tr>
<tr><td>istream</td><td>input</td></tr>
<tr><td>ostream</td><td>output</td></tr>
</table>
</blockquote>

<hr width=90%>
<p>

<a name="ITERATOR_TYPES">
<b>Iterator Types</b>
</a>
<p>

The standard containers provide four types of iterators:

<ul>
<li><i>iterator</i> - General iterator for read/write of non-const containers.
<li><i>const_iterator</i> - Used to traverse <b>const</b> containers for <i>read-only</i> access.
<li><i>reverse_iterator</i> - For traversing containers in reverse order (read/write)
<li><i>const_reverse_iterator</i> - For traversing containers in reverse order (read only)
</ul>

Obviously, the reverse versions only work with bidirectional and random access iterators.

<p class="SectionHeader">
Example - Creating a generic <b>print</b> function
</p>


<p>

It gets tedious to have to write the code to print the contents of a container every time:
<blockquote><pre>
  <font color="#003399"><i>// Create vector, add 5 integers</i></font>
std::vector&lt;<b>int</b>&gt; cont1;

  <font color="#003399"><i>// do something ...</i></font>

  <font color="#003399"><i>// Print the contents of the container (vector)</i></font>
<b>for</b> (std::vector&lt;<b>int</b>&gt;::iterator iter = cont1.begin(); iter != cont1.end(); ++iter)
  std::cout &lt;&lt; *iter &lt;&lt; <font color="#9933CC">&quot;  &quot;</font>;
std::cout &lt;&lt; std::endl;
</pre></blockquote>

It would be nice if we could just do this:

<blockquote><pre>
std::cout &lt;&lt; cont1 &lt;&lt; std::endl;
</pre></blockquote>

but that won't work. So, we come up with <b>print1</b>, which works just fine:

<!--
// This conflicts with the normal operator<< for regular
// stuff. There is no guarantee that T is a container.
// It may be a Foo class, and then where would we be?
// The error is:
//  error C2593: '<<' : 'operator <<' is ambigous
// These lines in the print functions above are causing it:
//    std::cout << *iter << "  ";
//
// which operator<< is called? Conflicts with some
// overloads in ostream.h as well.

/*
template <typename T>
std::ostream &operator<<(std::ostream &os, const T& c)
{
  typename T::const_iterator iter;
  for (iter = c.begin(); iter != c.end(); ++iter)
  {
    os << *iter << "  ";  // recursive???
    //os.operator<<(*iter);
    //os.operator<<("  ");
  }
  os << std::endl;
  return os;
}
*/
-->

<!--************************************************************************-->
<!--************************************************************************-->
<blockquote>
<h2>Print1</h2>
</blockquote>

<pre class="sourcecode"><code><b>void</b> print1(std::vector&lt;<b>int</b>&gt;&amp; v)
{
  <b>for</b> (<b>unsigned</b> i = 0; i &lt; v.size(); i++)
    std::cout &lt;&lt; v[i] &lt;&lt; <font color="#9933CC">&quot;  &quot;</font>;
  std::cout &lt;&lt; std::endl;
}</code></pre>


This code:

<blockquote><pre>
  <font color="#003399"><i>// Create vector, add 5 integers</i></font>
std::vector&lt;<b>int</b>&gt; cont1;
<b>for</b> (<b>int</b> i = 0; i &lt; 5; ++i)
  cont1.push_back(i);

  <font color="#003399"><i>// Print the vector of ints</i></font>
print1(cont1);
</pre></blockquote>

now prints:

<blockquote><pre>
0  1  2  3  4
</pre></blockquote>

It's a nice start but:
<ul>
<li>Only handles integers, so we'd need one for every type we want to print:
<blockquote><pre>
<b>void</b> print1(std::vector&lt;<b>int</b>&gt;&amp; v);
<b>void</b> print1(std::vector&lt;<b>double</b>&gt;&amp; v);
<b>void</b> print1(std::vector&lt;std::string&gt;&amp; v);
<b>void</b> print1(std::vector&lt;Foo&gt;&amp; v);
...
</pre></blockquote>
</ul>

It should be pretty obvious what the solution is.
<p>
This leads us to our second version, called <b>Print2</b>:
<p>
<!--Making the type a <b>template</b> parameter, we can print any type of vector:-->

<!--************************************************************************-->
<!--************************************************************************-->
<blockquote>
<h2>Print2</h2>
</blockquote>

<pre class="sourcecode"><code><font color="blue"><b>template &lt;typename T&gt;</b></font>
<b>void</b> print2(std::vector&lt;<font color="blue"><b>T&gt;</b></font>&amp; v)
{
  <b>for</b> (<b>unsigned</b> i = 0; i &lt; v.size(); i++)
    std::cout &lt;&lt; v[i] &lt;&lt; <font color="#9933CC">&quot;  &quot;</font>;
  std::cout &lt;&lt; std::endl;
}</code></pre>

Now we can deal with all of this code:

<blockquote><pre>
  <font color="#003399"><i>// Create vector for integers, add 5 of them</i></font>
std::vector&lt;<b>int</b>&gt; cont1;
<b>for</b> (<b>int</b> i = 0; i &lt; 5; ++i)
  cont1.push_back(i);

  <font color="#003399"><i>// Create vector for strings, add 3 of them</i></font>
std::vector&lt;std::string&gt; cont2;
cont2.push_back(<font color="#9933CC">&quot;one&quot;</font>);
cont2.push_back(<font color="#9933CC">&quot;two&quot;</font>);
cont2.push_back(<font color="#9933CC">&quot;three&quot;</font>);

  <font color="#003399"><i>// Create vector of Foo objects, add 5 of them</i></font>
std::vector&lt;Foo&gt; cont3;
<b>for</b> (i = 0; i &lt; 5; ++i)
  cont3.push_back(i * i);

print2(cont1); <font color="#003399"><i>// Print the vector of integers </i></font>
print2(cont2); <font color="#003399"><i>// Print the vector of strings </i></font>
print2(cont3); <font color="#003399"><i>// Print the vector of Foo objects</i></font>
</pre></blockquote>


<b>Output:</b>
<blockquote><pre>
0  1  2  3  4
one  two  three
0  1  4  9  16
</pre></blockquote>

This code has a problem with the <i>print</i> function:

<blockquote><pre>
  <font color="#003399"><i>// Create deque for integers, add 5 of them</i></font>
std::deque&lt;<b>int</b>&gt; cont1;
<b>for</b> (<b>int</b> i = 0; i &lt; 5; ++i)
  cont1.push_back(i);

  <font color="#003399"><i>// Compiler error: print2 function can't handle a deque</i></font>
print2(cont1);
</pre></blockquote>

<ul>
<li>Only handles vectors, so we'd need one for each container:

<blockquote><pre>
<b>void</b> print1(std::vector&lt;<b>int</b>&gt;&amp; v);
<b>void</b> print1(std::list&lt;<b>int</b>&gt;&amp; v);
<b>void</b> print1(std::deque&lt;<b>int</b>&gt;&amp; v);
<b>void</b> print1(std::set&lt;<b>int</b>&gt;&amp; v);
...
<b>void</b> print1(std::vector&lt;<b>double</b>&gt;&amp; v);
<b>void</b> print1(std::list&lt;<b>double</b>&gt;&amp; v);
<b>void</b> print1(std::deque&lt;<b>double</b>&gt;&amp; v);
<b>void</b> print1(std::set&lt;<b>double</b>&gt;&amp; v);
...
</pre></blockquote>
</ul>

So we modify the template to include the container type as well:

<!--************************************************************************-->
<!--************************************************************************-->
<blockquote>
<h2>Print3</h2>
</blockquote>

<pre class="sourcecode"><code><b>template</b> &lt;<b>typename</b> T&gt;
<b>void</b> print3(<font color="blue"><b>T</b></font>&amp; v)
{
  <b>for</b> (<b>unsigned</b> i = 0; i &lt; v.size(); i++)
    std::cout &lt;&lt; v[i] &lt;&lt; <font color="#9933CC">&quot;  &quot;</font>;
  std::cout &lt;&lt; std::endl;
}</code></pre>

Now:
<ul>
<li>We can handle any type of vector (provided the elements have overloaded <b>operator&lt;&lt</b>).
<li>We can handle vectors and deques.
<li>But there is still a limitation. 
<li>Here's an example of that limitation:

<blockquote><pre>
  <font color="#003399"><i>// Create a list of strings with some values</i></font>
std::list&lt;std::string&gt; cont1;
cont1.push_back(<font color="#9933CC">&quot;one&quot;</font>);
cont1.push_back(<font color="#9933CC">&quot;two&quot;</font>);
cont1.push_back(<font color="#9933CC">&quot;three&quot;</font>);

  <font color="#003399"><i>// Compiler error </i></font>
print3(cont1);
</pre></blockquote>

And this is the error message:

<blockquote><pre>
main.cpp(584) : error C2676: binary '[' : 'class std::list&lt;class std::basic_string&lt;char,
struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt;,class std::allocator&lt;
class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;
char&gt; &gt; &gt; &gt;' does not define this operator or a conversion to a type acceptable to 
the predefined operator' 
main.cpp(614) : see reference to function template instantiation 'void __cdecl print3(class 
std::list&lt;class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class 
std::allocator&lt;char&gt; &gt;,class std::allocator&lt;class std::basic_string&lt;char,
struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; &gt; &gt; &)' being compiled
</pre></blockquote>

<p>
It's not immediately obvious what the problem is, but the error message has enough information to figure it out.
<p>
	
<li>We can only handle containers that overload <b>operator[]</b>. 
<li>It iterator terminology, we can only deal with containers that provide random access to the elements.
<li>To handle other iterators, we need to implement the function using iterators.
</ul>

Using iterators instead of subscripts:

<!--************************************************************************-->
<!--************************************************************************-->
<blockquote>
<h2>Print4</h2>
</blockquote>

<pre class="sourcecode"><code><b>template</b> &lt;<b>typename</b> T&gt;
<b>void</b> print4(T&amp; v)
{
  <font color="blue"><b>typename T::iterator iter;</b></font>
  for <font color="blue"><b>(iter = v.begin(); iter != v.end(); ++iter)</b></font>
    std::cout &lt;&lt; <font color="blue"><b>*iter</b></font> &lt;&lt; <font color="#9933CC">&quot;  &quot;</font>;
  std::cout &lt;&lt; std::endl;
}</code></pre>

allows us to handle a lot more structures. For example:

<blockquote><pre>
  <font color="#003399"><i>// Create a list of doubles</i></font>
std::list&lt;<b>double</b>&gt; cont1;
<b>for</b> (<b>int</b> i = 1; i &lt;= 5; ++i)
  cont1.push_back(1.0 / i);

  <font color="#003399"><i>// Create a set of strings</i></font>
std::set&lt;std::string&gt; cont2;
cont2.insert(<font color="#9933CC">&quot;one&quot;</font>);
cont2.insert(<font color="#9933CC">&quot;two&quot;</font>);
cont2.insert(<font color="#9933CC">&quot;three&quot;</font>);
cont2.insert(<font color="#9933CC">&quot;four&quot;</font>);

print4(cont1);  <font color="#003399"><i>// Print the list of doubles</i></font>
print4(cont2);  <font color="#003399"><i>// Print the set of strings</i></font>
</pre></blockquote>

<b>Output:</b>
<blockquote><pre>
1  0.5  0.333333  0.25  0.2
four  one  three  two
</pre></blockquote>

By the way, notice any thing about the order of the strings in the set?
<p>
	
There's still a slight problem that this code exposes:

<blockquote><pre>
  <font color="#003399"><i>// Create a list of strings</i></font>
std::list&lt;std::string&gt; cont1;
cont1.push_back(<font color="#9933CC">&quot;one&quot;</font>);
cont1.push_back(<font color="#9933CC">&quot;two&quot;</font>);
cont1.push_back(<font color="#9933CC">&quot;three&quot;</font>);
cont1.push_back(<font color="#9933CC">&quot;four&quot;</font>);

  <font color="#003399"><i>// Create a copy of the list of strings</i></font>
<b>const</b> std::list&lt;std::string&gt; cont2(cont1);

print4(cont1);  <font color="#003399"><i>// Print the first list of strings</i></font>
print4(cont2);  <font color="#003399"><i>// Print the second list of strings</i></font>
</pre></blockquote>

The compiler emits <a href="STL-Error-2.html">these errors</a>
<p>

<a href="STL-1.html#ITERATOR_TYPES">Iterator types</a>
<p>

We need to modify the function slightly to handle this case:

<!--************************************************************************-->
<!--************************************************************************-->
<blockquote>
<a name="PRINT5">
<h2>Print5</h2>
</a>
</blockquote>

<pre class="sourcecode"><code><b>template</b> &lt;<b>typename</b> T&gt;
<b>void</b> print5(<font color="blue"><b>const</b></font> T&amp; v)
{
  <b>typename</b> T::<font color="blue"><b>const_iterator</b></font> iter;
  <b>for</b> (iter = v.begin(); iter != v.end(); ++iter)
    std::cout &lt;&lt; *iter &lt;&lt; <font color="#9933CC">&quot;  &quot;</font>;
  std::cout &lt;&lt; std::endl;
}</code></pre>

Now we can print both lists:

<blockquote><pre>
print4(cont1);  <font color="#003399"><i>// Print the first list of strings</i></font>
print5(cont2);  <font color="#003399"><i>// Print the second list of strings</i></font>
</pre></blockquote>

Note that we can use <b>print5</b> to print the first list as well.
<p>
<a href="STL-1.html#ITERATOR_TYPEDEF">Iterator typedef</a>
<p>

<p>

<hr width=90%>
<p>

A note about the <b>typename</b> keyword:
<p>
<!--
The code for <b>print4</b> <b>print5</b> actually contains a compiler error (for compliant
compilers.) 
-->

<!--
Neither Microsoft's 6.0/7.1 nor Borland's compiler uncovers the problem below.
-->

The compiler shows a problem (undefined identifier):

<blockquote><pre>
<b>template</b> &lt;<b>typename</b> T&gt;
<b>void</b> f1(<b>const</b> T&amp; a)
{
  <b>int</b> b = 5;
  T::value * b;      <font color="#003399"><i>// What is the meaning of this?</i></font>
  T::newtype * ptr;  <font color="#003399"><i>// What is the meaning of this? (Compiler error)</i></font>
}
</pre></blockquote>

The error message:

<blockquote><pre>
main.cpp: In function `void f1(const T&) [with T = X]':
main.cpp:1054: error: `ptr' undeclared (first use this function)
</pre></blockquote>

The problem is more noticeable if we have this class and we instantiate it:

<blockquote><pre>
<b>class</b> X 
{
  <b>public</b>:
    <b>static</b> <b>const</b> <b>int</b> value = 10;
    <b>typedef</b> <b>int</b> newtype;
};

<b>int</b> main(<b>void</b>)
{
  X a;
  f1(a);

  <b>return</b> 0;
}
</pre></blockquote>

Corrected:
<p>

<blockquote><pre>
<b>template</b> &lt;<b>typename</b> T&gt;
<b>void</b> f1(<b>const</b> T&amp; a)
{
  <b>int</b> b = 5;
  T::value * b;               <font color="#003399"><i>// Implicit assumption: value is non-type</i></font>
                              <font color="#003399"><i>//   (multiplication expression)</i></font>  
  <b>typename</b> T::newtype * ptr;  <font color="#003399"><i>// Explicit: newtype is a type</i></font>
                              <font color="#003399"><i>//   (declaration)</i></font>  
}
</pre></blockquote>

Why do you think the compiler won't warn about the multiplication expression above?
In other words, the compiler would warn about this:

<blockquote><pre>
int a = 5;
int b = 6;
a * b;      // statement has no effect
</pre></blockquote>

What's the difference?

<hr width=90%>
<p>




<blockquote>
</blockquote>


<b>Continuing with the example:</b>
<p>

A quick look at the <tt>std::pair</tt> class (partial listing)
<p>

<blockquote><pre>
<b>template</b>&lt;<b>typename</b> T, <b>typename</b> U&gt; 
<b>struct</b> pair
{   
    <font color="#003399"><i>// General typedefs</i></font>
  <b>typedef</b> T first_type;
  <b>typedef</b> U second_type;

    <font color="#003399"><i>// Default constructor</i></font>
  pair() : first(T()), second(U()) 
  { 
  }

    <font color="#003399"><i>// Constructor</i></font>
  pair(<b>const</b> T&amp; v1, <b>const</b> U&amp; v2) : first(v1), second(v2)
  { 
  }

  T first;  <font color="#003399"><i>// the first value</i></font>
  U second; <font color="#003399"><i>// the second value</i></font>

    <font color="#003399"><i>// other code</i></font>
};
</pre></blockquote>

The function template <tt>std::make_pair</tt> is a convenience function that simply
constructs a pair out of its two inputs.
<p>



What about using our <tt>print5</tt> function with this code:

<blockquote><pre>
  <font color="#003399"><i>// Create a map to hold integer/string pairs</i></font>
std::map&lt;<b>int</b>, std::string&gt; cont1;

  <font color="#003399"><i>// Put 3 pairs into the map</i></font>
cont1.insert(std::make_pair&lt;<b>int</b>, std::string&gt;(1, <font color="#9933CC">&quot;one&quot;</font>));
cont1.insert(std::make_pair&lt;<b>int</b>, std::string&gt;(2, <font color="#9933CC">&quot;two&quot;</font>));
cont1.insert(std::make_pair&lt;<b>int</b>, std::string&gt;(3, <font color="#9933CC">&quot;three&quot;</font>));

  <font color="#003399"><i>// Print the map</i></font>
print5(cont1);
</pre></blockquote>

Why is this error generated? <a href="STL-1.html#PRINT5">Print5</a>

<blockquote><pre>
main.cpp(618) : error C2679: binary '<<' : no operator defined which takes a 
                right-hand operand of type 'const struct std::pair<int const ,
                class std::basic_string<char,struct std::char_traits<char>,
                class std::allocator<char> > >' (or there is no acceptable conversion)
main.cpp(696) : see reference to function template instantiation 
                'void __cdecl print5(class std::map<int,class std::basic_string<char,
                struct std::char_traits<char>,class std::allocator<char> >,
                struct std::less<int>,class std::allocator<class std::basic_string<char,
                struct std::char_traits<char>,class std::allocator<char> > > > &)' 
                being compiled
</pre></blockquote>

<p>
<br><br>

There is nothing wrong with the <b>print5</b> function. We need to add this to our code:

<pre class="sourcecode"><code>std::ostream &amp;<b>operator</b>&lt;&lt;(std::ostream &amp;os, <b>const</b> std::pair&lt;<b>int</b>, std::string&gt;&amp; pair)
{
  os &lt;&lt; <font color="#9933CC">&quot;(&quot;</font> &lt;&lt; pair.first &lt;&lt; <font color="#9933CC">&quot;, &quot;</font> &lt;&lt; pair.second &lt;&lt; <font color="#9933CC">&quot;)&quot;</font>;
  <b>return</b> os;
}</code></pre>


Of course, that's not going to help us here:

<blockquote><pre>
  <font color="#003399"><i>// Create an empty map of double/Foo</i></font>
std::map&lt;<b>double</b>, Foo&gt; cont2;

  <font color="#003399"><i>// Create 3 Foo objects</i></font>
Foo f1(100); Foo f2(200); Foo f3(300);

  <font color="#003399"><i>// Insert pairs of double/Foo into the map</i></font>
cont2.insert(std::make_pair&lt;<b>double</b>, Foo&gt;(1.0, f1));
cont2.insert(std::make_pair&lt;<b>double</b>, Foo&gt;(3.14, f2));
cont2.insert(std::make_pair&lt;<b>double</b>, Foo&gt;(6.8, f3));

  <font color="#003399"><i>// Print out the contents of the map</i></font>
print5(cont2);
</pre></blockquote>

<br>

We have the same problem we had above. We need more genericity:

<pre class="sourcecode"><code><b>template</b> &lt;<b>typename</b> T, <b>typename</b> U&gt;
std::ostream &amp;<b>operator</b>&lt;&lt;(std::ostream &amp;os, <b>const</b> std::pair&lt;T, U&gt;&amp; pair)
{
  os &lt;&lt; <font color="#9933CC">&quot;(&quot;</font> &lt;&lt; pair.first &lt;&lt; <font color="#9933CC">&quot;, &quot;</font> &lt;&lt; pair.second &lt;&lt; <font color="#9933CC">&quot;)&quot;</font>;
  <b>return</b> os;
}</code></pre>

This code works only if the elements of the pair have overloaded <b>operator&lt;&lt;</b> as well.
But, this is hardly a problem since printing to the screen requires <b>operator&lt;&lt;</b>.
<p>

	
By the way, each code snippet does the same thing:
<p>

<blockquote><pre>
  <font color="#003399"><i>// 1. Create unnamed pair and insert (template params explicit)</i></font>
cont1.insert(std::make_pair&lt;<b>int</b>, std::string&gt;(1, <font color="#9933CC">&quot;one&quot;</font>));

  <font color="#003399"><i>// 2. Create unnamed pair and insert (template params deduced)</i></font>
cont1.insert(std::make_pair(1, std::string(<font color="#9933CC">&quot;one&quot;</font>)));

  <font color="#003399"><i>// 3. Create pair by name and insert</i></font>
std::pair&lt;<b>int</b>, std::string&gt; pr(1, <font color="#9933CC">&quot;one&quot;</font>);
cont1.insert(pr);

  <font color="#003399"><i>// 4. Create default pair (0, &quot;&quot;), assign first/second, insert</i></font>
std::pair&lt;<b>int</b>, std::string&gt; pr2;
pr2.first = 1;
pr2.second = <font color="#9933CC">&quot;one&quot;</font>;
cont1.insert(pr2);
</pre></blockquote>

<blockquote><pre>
</pre></blockquote>


<blockquote><pre>
</pre></blockquote>

<p>
<a href="Maps-Example-1.html">Map example using pairs</a>


<!-- ************************************************************************************************ -->
<!-- ************************************************************************************************ -->
<p class="SectionHeader">
Functions for Iterators
</p>

There are 3 functions provided for iterators:

<ul>
<li><b>advance()</b> - increments an iterator's position by a certain value.
<li><b>distance()</b> - returns the distance (in elements) between to iterators.
<li><b>iter_swap()</b> - exchanges the values of two iterators.
</ul>

Declaration of <i>advance()</i>:

<blockquote><pre>
<b>template</b>&lt;<b>class</b> InIt, <b>class</b> Dist&gt; <b>void</b> advance(InIt&amp; it, Dist n); 
</pre></blockquote>

Notes:
<ul>
<li>Moves the iterator forward or backward.
<li>Random access and bidirectional iterators can move backward by specifying a negative distance value.
<li>No error checking is done, so advancing past the end is undefined.
<li>Efficiency for random-access iterators: constant time. </i>
<li>Efficiency for bidirectional iterators: linear time. </i>
<li>Efficiency for forward iterators: linear time. </i>
</ul>

Example:

<pre class="sourcecode"><code><b>int</b> main(<b>void</b>)
{
  std::vector&lt;<b>int</b>&gt; cont1;

    <font color="#003399"><i>// Put 5 integers in vector</i></font>
  <b>for</b> (<b>int</b> i = 0; i &lt; 5; ++i)
    cont1.push_back(i);

    <font color="#003399"><i>// Print out vector</i></font>
  std::vector&lt;<b>int</b>&gt;::iterator it;
  <b>for</b> (it = cont1.begin(); it != cont1.end(); ++it)
    std::cout &lt;&lt; *it &lt;&lt; <font color="#9933CC">&quot;  &quot;</font>;
  std::cout &lt;&lt; std::endl;

    <font color="#003399"><i>// Set iterator to beginning of container</i></font>
  it = cont1.begin();

    <font color="#003399"><i>// Print out first element</i></font>
  std::cout &lt;&lt; *it &lt;&lt; std::endl;

    <font color="#003399"><i>// Advance to 3rd element (2 elements further)</i></font>
  std::advance(it, 2);

    <font color="#003399"><i>// Print out 3rd element</i></font>
  std::cout &lt;&lt; *it &lt;&lt; std::endl;

    <font color="#003399"><i>// Backup one element</i></font>
  std::advance(it, -1);

    <font color="#003399"><i>// Print out 2nd element</i></font>
  std::cout &lt;&lt; *it &lt;&lt; std::endl;

  <b>return</b> 0;
}</code></pre>

<b>Output:</b>
<blockquote><pre>
0  1  2  3  4
0
2
1
</pre></blockquote>

<!-- ************************************************************************************************ -->
<!-- ************************************************************************************************ -->
<p class="SectionHeader">
More Examples Using Iterators
</p>



<pre class="sourcecode"><code><b>#include</b> &lt;iostream&gt;
<b>#include</b> &lt;vector&gt;
<b>#include</b> &lt;string&gt;

<b>int</b> main(<b>void</b>)
{
    <font color="#003399"><i>// Create a typedef for a vector of strings</i></font>
  <b>typedef</b> std::vector&lt;std::string&gt; StrCont;
    
    <font color="#003399"><i>// Create a vector of strings</i></font>
  StrCont cont1;

    <font color="#003399"><i>// Put 5 strings in the vector</i></font>
  cont1.push_back(<font color="#9933CC">&quot;one&quot;</font>);    
  cont1.push_back(<font color="#9933CC">&quot;two&quot;</font>);    
  cont1.push_back(<font color="#9933CC">&quot;three&quot;</font>);  
  cont1.push_back(<font color="#9933CC">&quot;four&quot;</font>);   
  cont1.push_back(<font color="#9933CC">&quot;five&quot;</font>);   

    <font color="#003399"><i>// Create a copy using all strings</i></font>
  StrCont cont2(cont1); 
  print5(cont2);  <font color="#003399"><i>// Output: one  two  three  four  five     </i></font>

    <font color="#003399"><i>// Create a copy using all strings</i></font>
  StrCont cont3(cont1.begin(), cont1.end());
  print5(cont3);  <font color="#003399"><i>// Output: one  two  three  four  five</i></font>

    <font color="#003399"><i>// Create a copy using first 2 strings only</i></font>
  StrCont cont4(cont1.begin(), cont1.begin() + 2);
  print5(cont4);  <font color="#003399"><i>// Output: one  two</i></font>

    <font color="#003399"><i>// Create a copy using last 3 strings</i></font>
  StrCont cont5(cont1.end() - 3, cont1.end());
  print5(cont5);  <font color="#003399"><i>// Output: three  four  five</i></font>

    <font color="#003399"><i>// Create a copy using all in reverse order</i></font>
  StrCont cont6(cont1.rbegin(), cont1.rend());
  print5(cont6);  <font color="#003399"><i>// Output: five  four  three  two  one</i></font>
  
  <b>return</b> 0;
}</code></pre>

<b>Output:</b>
<blockquote><pre>
one  two  three  four  five
one  two  three  four  five
one  two
three  four  five
five  four  three  two  one
</pre></blockquote>

Now, to use a <b>std::list</b> instead of a <b>std::vector</b>, we want to simply change
the <b>typedef</b>:


<blockquote><pre>
  <font color="#003399"><i>// Create a typedef for a list of strings</i></font>
<b>typedef</b> std::list&lt;std::string&gt; StrCont;
</pre></blockquote>

But this causes some problems with this code:

<blockquote><pre>
  <font color="#003399"><i>// Create a copy using first 2 strings only. Compiler error!</i></font>
StrCont cont4(cont1.begin(), cont1.begin() + 2);

  <font color="#003399"><i>// Create a copy using last 3 strings. : Compiler error!</i></font>
StrCont cont5(cont1.end() - 3, cont1.end());
</pre></blockquote>

Notes:
<ul>
<li>The problem is that we are adding to one iterator and subtracting from another. 
<li>These operations are only defined for random access iterators.
<li>The iterators for a <b>std::list</b> are bidirectional, so they don't support iterator arithmetic.
<li>We need to use a function like <b>advance</b> to perform the arithmetic:

<blockquote><pre>
  <font color="#003399"><i>// Create(bidirectional) iterators. Same as list&lt;string&gt;::iterator</i></font>
StrCont::iterator start = cont1.begin(); <font color="#003399"><i>// initialize to beginning</i></font>
StrCont::iterator end = cont1.begin();   <font color="#003399"><i>// initialize to beginning</i></font>

  <font color="#003399"><i>// Increment iterator by 2. (Complexity now is linear)</i></font>
std::advance(end, 2);

  <font color="#003399"><i>// Create a copy using first 2 strings only</i></font>
StrCont cont4(start, end);
print5(cont4);  <font color="#003399"><i>// Output: one  two</i></font>

start = cont1.end();  <font color="#003399"><i>// Set start to end</i></font>
end = cont1.end();    <font color="#003399"><i>// Set end to end</i></font>

  <font color="#003399"><i>// Decrement iterator by 3</i></font>
std::advance(start, -3);

  <font color="#003399"><i>// Create a copy using last 3 strings</i></font>
StrCont cont5(start, end);
print5(cont5);  <font color="#003399"><i>// Output: three  four  five</i></font>
</pre></blockquote>


<li>Notice that using the technique above, the code can handle <b>std::vector</b> without 
modification and that the <b>advance</b> function has constant complexity.
</ul>

<!--
On a final note, the reverse iterator code show above does not work with MS VC++ 6.0 (What's new?) The
solution is to use STLport instead of the RogueWave STL implementation that comes with MS. 
-->

<!--
<p class="technote">
You are <b><i>STRONGLY</i></b> encouraged to use/try STLport if you haven't already. I have offered to help
anyone that needs help installing and building the libraries. Please do not ignore this advice and think
that you don't need this knowledge because your current game project doesn't need it.
</p>
-->

</ul>


<!-- ************************************************************************************************ -->
<!-- ************************************************************************************************ -->
<p class="SectionHeader">
Iterator Adapters
</p>

There are 3 general types of iterator adapters: <!-- (found in the <tt><b>&lt;iterator&gt;</b></tt> header file)-->
<ul>
<li><b>Insert iterators</b> - Also called <i>inserters</i>, used to insert (rather than overwrite) elements
in a container. If there is not enough space, new space is allocated on-the-fly.
<li><b>Stream iterators</b> - Iterators to read from a stream or write to a stream. Generally used for I/O.
<li><b>Reverse iterators</b> - They switch the increment operator to a decrement operator internally. These
iterators require containers that have <i>rbegin()</i> and <i>rend()</i> methods.
</ul>

<p>
<b>Insert Iterators</b>
<p>

There are 3 predefined inserters:
<ul>
<li><b>Front inserters</b> - Prepend elements at the front of the container by calling <i>push_front()</i>.
<li><b>Back inserters</b> - Append elements at the end of the container by calling <i>push_back()</i>. 
<li><b>Inserters</b> - Insert elements at a specified position by calling <i>insert()</i>.
</ul>

Example:

<pre class="sourcecode"><code><b>int</b> Random1_30(<b>void</b>)
{
  <b>return</b> rand() % 30 + 1;
}

<b>#include</b> &lt;iterator&gt;<font color="#003399"><i>// May need this for the inserters</i></font>

<b>void</b> f26(<b>void</b>)
{
  <b>typedef</b> std::list&lt;<b>int</b>&gt; ContainerType;

    <font color="#003399"><i>// Create container all set to 0</i></font>
  ContainerType cont1(10), cont2(10);
  
    <font color="#003399"><i>// Create empty containers</i></font>
  std::list&lt;<b>int</b>&gt; cont3, cont4, cont5;

    <font color="#003399"><i>// Fill cont1 with random values</i></font>
    <font color="#003399"><i>// 12  18  5  11  30  5  19  19  23  15</i></font>
  std::generate(cont1.begin(), cont1.end(), Random1_30);

    <font color="#003399"><i>// Copy values from cont1 to cont2 (pre-allocated)</i></font>
    <font color="#003399"><i>// 12  18  5  11  30  5  19  19  23  15</i></font>
  std::copy(cont1.begin(), cont1.end(), cont2.begin());

    <font color="#003399"><i>// Insert values from cont1 at front of cont3 (allocate as needed)</i></font>
    <font color="#003399"><i>// 15  23  19  19  5  30  11  5  18  12</i></font>
  std::copy(cont1.begin(), cont1.end(), std::front_inserter(cont3));

    <font color="#003399"><i>// Insert values from cont1 at back of cont4 (allocate as needed)</i></font>
    <font color="#003399"><i>// 12  18  5  11  30  5  19  19  23  15</i></font>
  std::copy(cont1.begin(), cont1.end(), std::back_inserter(cont4));

    <font color="#003399"><i>// Insert values from cont1 into cont5 at element 3 (allocate as needed)</i></font>
    <font color="#003399"><i>// 99  99  99  12  18  5  11  30  5  19  19  23  15  99  99  99  99  99  99  99</i></font>
  cont5.resize(10, 99);
  ContainerType::iterator iter = cont5.begin();
  std::advance(iter, 3);
  std::copy(cont1.begin(), cont1.end(), std::inserter(cont5, iter));

    <font color="#003399"><i>// Print the containers</i></font>
  print5(cont1);
  print5(cont2);
  print5(cont3);
  print5(cont4);
  print5(cont5);
}</code></pre>

Notes:
<ul>
<li><i>front_inserter</i> can only be used with containers that support the <i>push_front()</i> method.
<li><i>back_inserter</i> can only be used with containers that support the <i>push_back()</i> method.
<li>You may need to include <tt><b>&lt;iterator&gt;</b></tt> to use the iterator adapters (older compilers).
</ul>

<b>The power of iterators:</b> (<tt>words_</tt> is an empty vector of strings)

<blockquote><pre>
<b>#include</b> &lt;iostream&gt;
<b>#include</b> &lt;algorithm&gt;
<b>#include</b> &lt;fstream&gt;
<b>#include</b> &lt;iterator&gt;

<b>#include</b> <font color="#9933CC">&quot;Tester.h&quot;</font>

<b>bool</b> Tester::Load(<b>const</b> std::string&amp; filename)
{
  std::ifstream infile(filename.c_str());
  <b>if</b> (!infile.is_open())
    <b>return</b> <b>false</b>;
  <b>else</b>
  {
    std::istream_iterator&lt;std::string&gt; it(infile);
    std::istream_iterator&lt;std::string&gt; eof;
    std::copy(it, eof, std::back_inserter(words_));
    <b>return</b> true;
  }
}

<b>void</b> Tester::Print(<b>bool</b> oneline) <b>const</b>
{
  <b>if</b> (oneline)
    std::copy(words_.begin(), words_.end(), std::ostream_iterator&lt;std::string&gt;(std::cout, <font color="#9933CC">&quot; &quot;</font>));
  <b>else</b>
    std::copy(words_.begin(), words_.end(), std::ostream_iterator&lt;std::string&gt;(std::cout, <font color="#9933CC">&quot;\n&quot;</font>));

  std::cout &lt;&lt; std::endl;
}
</pre></blockquote>

The code to read in the words could have been done on one line:
<blockquote><pre>
<b>using namespace</b> std;
copy(istream_iterator&lt;string&gt;(infile), istream_iterator&lt;string&gt(), back_inserter(words_));
</pre></blockquote>


<!--
<p>
More information on the methods available for 
<a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcstdlib/html/vclrfmap_members.asp">map members</a>
on MSDN.
<p>
More information on the methods available for 
<a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcstdlib/html/vclrfset_members.asp">set members</a>
on MSDN.
<p>


<blockquote><pre>
</pre></blockquote>

<blockquote><pre>
</pre></blockquote>
-->

<p>

<p>

<!--
Other handy reference material on MSDN:
<ul>
<li><a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcstdlib/html/vcoriStandardCLibraryReference.asp">Standard C++ Library Reference</a>
<li><a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcstdlib/html/vcoristandardtemplatelibrarysamples.asp">Standard Template Library Samples</a>
<li><a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclang/html/vcrefcpluspluslanguagereference.asp">C++ Language Reference</a>
</ul>

From GNU:
<ul>
<li><a href="http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt08ch19s02.html">Iterators</a> and
a good explanation of the whole "half-open" concept.
</ul>

-->

<p>
<hr>
<p>



<!--
Using the generic algorithms:

<p class="technote">
The second major efficiency argument is that all but the most trivial STL algorithms use computer
science algorithms that are more sophisticated -- sometimes <i>much</i> more sophisticated -- than
anything the average C++ programmer will be able to come up with. It's impossible to beat <b>sort</b>
or its kin; the search algorithms for sorted ranges are equally good; and even such mundane tasks
as eliminating some objects from contiguous memory containers are more efficiently accomplished using
the <b>erase-remove</b> idiom than the loops most programmers come up with. -- Scott Meyers in <i>Effective STL</i>
</p>

-->

<!--

Printing the list in reverse order:

<blockquote><pre>
  <font color="#003399"><i>// Declare a reverse iterator </i></font>
std::list&lt;std::string&gt;::reverse_iterator rit;

<font color="#003399"><i>// &quot;Walk&quot; (iterate) over the list in reverse order</i></font>
<b>for</b> (rit = cont1.rbegin(); rit != cont1.rend(); ++rit)
  std::cout &lt;&lt; *rit &lt;&lt; <font color="#9933CC">&quot;  &quot;</font>;  <font color="#003399"><i>// dereference the iterator to get the value</i></font>
std::cout &lt;&lt; std::endl;
</pre></blockquote>

<b>Output:</b>
<blockquote><pre>
four  three  two  one  five  six  seven
</pre></blockquote>

Sorting the list:

<blockquote><pre>
  <font color="#003399"><i>// Sort the list (uses <b>operator&lt;</b>)</i></font>
cont1.sort();
</pre></blockquote>

<b>Output:</b>

<blockquote><pre>
five  four  one  seven  six  three  two
</pre></blockquote>


Be very careful not to mix up forward iterators with reverse iterators:

<blockquote><pre>
  <font color="#003399"><i>// Declare a reverse iterator </i></font>
std::list&lt;std::string&gt;::reverse_iterator rit;

<font color="#003399"><i>// &quot;Walk&quot; (iterate) over the list in a &quot;forward&quot; order (Wrong!!!)</i></font>
<b>for</b> (rit = cont1.begin(); rit != cont1.end(); ++rit)
  std::cout &lt;&lt; *rit &lt;&lt; <font color="#9933CC">&quot;  &quot;</font>;  <font color="#003399"><i>// dereference the iterator to get the value</i></font>
std::cout &lt;&lt; std::endl;
</pre></blockquote>

This produces this terse <a href="STL-Error-1.html">error message</a>
<p>

-->


</body>
</html>


