<html>
<head>
<link rel="stylesheet" type="text/css" href="new.css">
<title>algorithm.h</title>
</head>

<body>  

<pre class="sourcecode"><code>
<font color="#003399"><i>// algorithm standard header</i></font>
<b>#pragma</b> once
<b>#ifndef</b> _ALGORITHM_
<b>#define</b> _ALGORITHM_
<b>#include</b> &lt;memory&gt;

<b>#pragma</b> pack(push,8)
<b>#pragma</b> <b>warning</b>(push,3)
<b>#pragma</b> <b>warning</b>(<b>disable</b>: 4244)
_STD_BEGIN

    <font color="#003399"><i>// COMMON SORT PARAMETERS</i></font>
<b>const</b> <b>int</b> _ISORT_MAX = 32;  <font color="#003399"><i>// maximum size for insertion sort</i></font>

    <font color="#003399"><i>// TEMPLATE FUNCTION for_each</i></font>
<b>template</b>&lt;<b>class</b> _InIt,
  <b>class</b> _Fn1&gt; <b>inline</b>
  _Fn1 for_each(_InIt _First, _InIt _Last, _Fn1 _Func)
  { <font color="#003399"><i>// perform function for each element</i></font>
  <b>for</b> (; _First != _Last; ++_First)
    _Func(*_First);
  <b>return</b> (_Func);
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION find</i></font>
<b>template</b>&lt;<b>class</b> _InIt,
  <b>class</b> _Ty&gt; <b>inline</b>
  _InIt find(_InIt _First, _InIt _Last, <b>const</b> _Ty&amp; _Val)
  { <font color="#003399"><i>// find first matching _Val</i></font>
  <b>for</b> (; _First != _Last; ++_First)
    <b>if</b> (*_First == _Val)
      <b>break</b>;
  <b>return</b> (_First);
  }

<b>inline</b> <b>const</b> <b>char</b> *find(<b>const</b> <b>char</b> *_First, <b>const</b> <b>char</b> *_Last, <b>int</b> _Val)
  { <font color="#003399"><i>// find first char that matches _Val</i></font>
  _First = (<b>const</b> <b>char</b> *)::memchr(_First, _Val, _Last - _First);
  <b>return</b> (_First == 0 ? _Last : _First);
  }

<b>inline</b> <b>const</b> <b>signed</b> <b>char</b> *find(<b>const</b> <b>signed</b> <b>char</b> *_First,
  <b>const</b> <b>signed</b> <b>char</b> *_Last, <b>int</b> _Val)
  { <font color="#003399"><i>// find first signed char that matches _Val</i></font>
  _First = (<b>const</b> <b>signed</b> <b>char</b> *)::memchr(_First, _Val,
    _Last - _First);
  <b>return</b> (_First == 0 ? _Last : _First);
  }

<b>inline</b> <b>const</b> <b>unsigned</b> <b>char</b> *find(<b>const</b> <b>unsigned</b> <b>char</b> *_First,
  <b>const</b> <b>unsigned</b> <b>char</b> *_Last, <b>int</b> _Val)
  { <font color="#003399"><i>// find first unsigned char that matches _Val</i></font>
  _First = (<b>const</b> <b>unsigned</b> <b>char</b> *)::memchr(_First, _Val,
    _Last - _First);
  <b>return</b> (_First == 0 ? _Last : _First);
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION find_if</i></font>
<b>template</b>&lt;<b>class</b> _InIt,
  <b>class</b> _Pr&gt; <b>inline</b>
  _InIt find_if(_InIt _First, _InIt _Last, _Pr _Pred)
  { <font color="#003399"><i>// find first satisfying _Pred</i></font>
  <b>for</b> (; _First != _Last; ++_First)
    <b>if</b> (_Pred(*_First))
      <b>break</b>;
  <b>return</b> (_First);
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION adjacent_find</i></font>
<b>template</b>&lt;<b>class</b> _FwdIt&gt; <b>inline</b>
  _FwdIt adjacent_find(_FwdIt _First, _FwdIt _Last)
  { <font color="#003399"><i>// find first matching successor</i></font>
  <b>for</b> (_FwdIt _Firstb; (_Firstb = _First) != _Last &amp;&amp; ++_First != _Last; )
    <b>if</b> (*_Firstb == *_First)
      <b>return</b> (_Firstb);
  <b>return</b> (_Last);
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION adjacent_find WITH PRED</i></font>
<b>template</b>&lt;<b>class</b> _FwdIt,
  <b>class</b> _Pr&gt; <b>inline</b>
  _FwdIt adjacent_find(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
  { <font color="#003399"><i>// find first satisfying _Pred with successor</i></font>
  <b>for</b> (_FwdIt _Firstb; (_Firstb = _First) != _Last &amp;&amp; ++_First != _Last; )
    <b>if</b> (_Pred(*_Firstb, *_First))
      <b>return</b> (_Firstb);
  <b>return</b> (_Last);
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION count</i></font>
<b>template</b>&lt;<b>class</b> _InIt,
  <b>class</b> _Ty&gt; <b>inline</b>
  <b>typename</b> iterator_traits&lt;_InIt&gt;::difference_type
    count(_InIt _First, _InIt _Last, <b>const</b> _Ty&amp; _Val)
  { <font color="#003399"><i>// count elements that match _Val</i></font>
  <b>typename</b> iterator_traits&lt;_InIt&gt;::difference_type _Count = 0;

  <b>for</b> (; _First != _Last; ++_First)
    <b>if</b> (*_First == _Val)
      ++_Count;
  <b>return</b> (_Count);
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION count_if</i></font>
<b>template</b>&lt;<b>class</b> _InIt,
  <b>class</b> _Pr&gt; <b>inline</b>
  <b>typename</b> iterator_traits&lt;_InIt&gt;::difference_type
    count_if(_InIt _First, _InIt _Last, _Pr _Pred)
  { <font color="#003399"><i>// count elements satisfying _Pred</i></font>
  <b>typename</b> iterator_traits&lt;_InIt&gt;::difference_type _Count = 0;

  <b>for</b> (; _First != _Last; ++_First)
    <b>if</b> (_Pred(*_First))
      ++_Count;
  <b>return</b> (_Count);
  }


    <font color="#003399"><i>// TEMPLATE FUNCTION search</i></font>
<b>template</b>&lt;<b>class</b> _FwdIt1,
  <b>class</b> _FwdIt2,
  <b>class</b> _Diff1,
  <b>class</b> _Diff2&gt; <b>inline</b>
  _FwdIt1 _Search(_FwdIt1 _First1, _FwdIt1 _Last1,
    _FwdIt2 _First2, _FwdIt2 _Last2, _Diff1 *, _Diff2 *)
  { <font color="#003399"><i>// find first [_First2, _Last2) match</i></font>
  _Diff1 _Count1 = 0;
  _Distance(_First1, _Last1, _Count1);
  _Diff2 _Count2 = 0;
  _Distance(_First2, _Last2, _Count2);

  <b>for</b> (; _Count2 &lt;= _Count1; ++_First1, --_Count1)
    { <font color="#003399"><i>// room for match, try it</i></font>
    _FwdIt1 _Mid1 = _First1;
    <b>for</b> (_FwdIt2 _Mid2 = _First2; ; ++_Mid1, ++_Mid2)
      <b>if</b> (_Mid2 == _Last2)
        <b>return</b> (_First1);
      <b>else</b> <b>if</b> (!(*_Mid1 == *_Mid2))
        <b>break</b>;
    }
  <b>return</b> (_Last1);
  }

<b>template</b>&lt;<b>class</b> _FwdIt1,
  <b>class</b> _FwdIt2&gt; <b>inline</b>
  _FwdIt1 search(_FwdIt1 _First1, _FwdIt1 _Last1,
    _FwdIt2 _First2, _FwdIt2 _Last2)
  { <font color="#003399"><i>// find first [_First2, _Last2) match</i></font>
  <b>return</b> (_Search(_First1, _Last1, _First2, _Last2,
    _Dist_type(_First1), _Dist_type(_First2)));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION search WITH PRED</i></font>
<b>template</b>&lt;<b>class</b> _FwdIt1,
  <b>class</b> _FwdIt2,
  <b>class</b> _Diff1,
  <b>class</b> _Diff2,
  <b>class</b> _Pr&gt; <b>inline</b>
  _FwdIt1 _Search(_FwdIt1 _First1, _FwdIt1 _Last1,
    _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred, _Diff1 *, _Diff2 *)
  { <font color="#003399"><i>// find first [_First2, _Last2) satisfying _Pred</i></font>
  _Diff1 _Count1 = 0;
  _Distance(_First1, _Last1, _Count1);
  _Diff2 _Count2 = 0;
  _Distance(_First2, _Last2, _Count2);

  <b>for</b> (; _Count2 &lt;= _Count1; ++_First1, --_Count1)
    { <font color="#003399"><i>// room for match, try it</i></font>
    _FwdIt1 _Mid1 = _First1;
    <b>for</b> (_FwdIt2 _Mid2 = _First2; ; ++_Mid1, ++_Mid2)
      <b>if</b> (_Mid2 == _Last2)
        <b>return</b> (_First1);
      <b>else</b> <b>if</b> (!_Pred(*_Mid1, *_Mid2))
        <b>break</b>;
    }
  <b>return</b> (_Last1);
  }

<b>template</b>&lt;<b>class</b> _FwdIt1,
  <b>class</b> _FwdIt2,
  <b>class</b> _Pr&gt; <b>inline</b>
  _FwdIt1 search(_FwdIt1 _First1, _FwdIt1 _Last1,
    _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
  { <font color="#003399"><i>// find first [_First2, _Last2) satisfying _Pred</i></font>
  <b>return</b> (_Search(_First1, _Last1, _First2, _Last2, _Pred,
    _Dist_type(_First1), _Dist_type(_First2)));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION search_n</i></font>
<b>template</b>&lt;<b>class</b> _FwdIt1,
  <b>class</b> _Diff2,
  <b>class</b> _Ty,
  <b>class</b> _Diff1&gt; <b>inline</b>
  _FwdIt1 _Search_n(_FwdIt1 _First1, _FwdIt1 _Last1,
    _Diff2 _Count, <b>const</b> _Ty&amp; _Val, _Diff1 *)
  { <font color="#003399"><i>// find first _Count * _Val match</i></font>
  _Diff1 _Count1 = 0;
  _Distance(_First1, _Last1, _Count1);

  <b>for</b> (; _Count &lt;= _Count1; ++_First1, --_Count1)
    { <font color="#003399"><i>// room for match, try it</i></font>
    _FwdIt1 _Mid1 = _First1;
    <b>for</b> (_Diff2 _Count2 = _Count; ; ++_Mid1, --_Count2)
      <b>if</b> (_Count2 == 0)
        <b>return</b> (_First1);
      <b>else</b> <b>if</b> (!(*_Mid1 == _Val))
        <b>break</b>;
    }
  <b>return</b> (_Last1);
  }

<b>template</b>&lt;<b>class</b> _FwdIt1,
  <b>class</b> _Diff2,
  <b>class</b> _Ty&gt; <b>inline</b>
  _FwdIt1 search_n(_FwdIt1 _First1, _FwdIt1 _Last1,
    _Diff2 _Count, <b>const</b> _Ty&amp; _Val)
  { <font color="#003399"><i>// find first _Count * _Val match</i></font>
  <b>return</b> (_Search_n(_First1, _Last1, _Count, _Val, _Dist_type(_First1)));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION search_n WITH PRED</i></font>
<b>template</b>&lt;<b>class</b> _FwdIt1,
  <b>class</b> _Diff2,
  <b>class</b> _Ty,
  <b>class</b> _Diff1,
  <b>class</b> _Pr&gt; <b>inline</b>
  _FwdIt1 _Search_n(_FwdIt1 _First1, _FwdIt1 _Last1,
    _Diff2 _Count, <b>const</b> _Ty&amp; _Val, _Pr _Pred, _Diff1 *)
  { <font color="#003399"><i>// find first _Count * _Val satisfying _Pred</i></font>
  _Diff1 _Count1 = 0;
  _Distance(_First1, _Last1, _Count1);

  <b>for</b> (; _Count &lt;= _Count1; ++_First1, --_Count1)
    { <font color="#003399"><i>// room for match, try it</i></font>
    _FwdIt1 _Mid1 = _First1;
    <b>for</b> (_Diff2 _Count2 = _Count; ; ++_Mid1, --_Count2)
      <b>if</b> (_Count2 == 0)
        <b>return</b> (_First1);
      <b>else</b> <b>if</b> (!_Pred(*_Mid1, _Val))
        <b>break</b>;
    }
  <b>return</b> (_Last1);
  }

<b>template</b>&lt;<b>class</b> _FwdIt1,
  <b>class</b> _Diff2,
  <b>class</b> _Ty,
  <b>class</b> _Pr&gt; <b>inline</b>
  _FwdIt1 search_n(_FwdIt1 _First1, _FwdIt1 _Last1,
    _Diff2 _Count, <b>const</b> _Ty&amp; _Val, _Pr _Pred)
  { <font color="#003399"><i>// find first _Count * _Val satisfying _Pred</i></font>
  <b>return</b> (_Search_n(_First1, _Last1,
    _Count, _Val, _Pred, _Dist_type(_First1)));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION find_end</i></font>
<b>template</b>&lt;<b>class</b> _FwdIt1,
  <b>class</b> _FwdIt2,
  <b>class</b> _Diff1,
  <b>class</b> _Diff2&gt; <b>inline</b>
  _FwdIt1 _Find_end(_FwdIt1 _First1, _FwdIt1 _Last1,
    _FwdIt2 _First2, _FwdIt2 _Last2, _Diff1 *, _Diff2 *)
  { <font color="#003399"><i>// find last [_First2, _Last2) match</i></font>
  _Diff1 _Count1 = 0;
  _Distance(_First1, _Last1, _Count1);
  _Diff2 _Count2 = 0;
  _Distance(_First2, _Last2, _Count2);
  _FwdIt1 _Ans = _Last1;

  <b>if</b> (0 &lt; _Count2)
    <b>for</b> (; _Count2 &lt;= _Count1; ++_First1, --_Count1)
      { <font color="#003399"><i>// room for match, try it</i></font>
      _FwdIt1 _Mid1 = _First1;
      <b>for</b> (_FwdIt2 _Mid2 = _First2; ; ++_Mid1)
        <b>if</b> (!(*_Mid1 == *_Mid2))
          <b>break</b>;
        <b>else</b> <b>if</b> (++_Mid2 == _Last2)
          { <font color="#003399"><i>// potential answer, save it</i></font>
          _Ans = _First1;
          <b>break</b>;
          }
      }
  <b>return</b> (_Ans);
  }

<b>template</b>&lt;<b>class</b> _FwdIt1,
  <b>class</b> _FwdIt2&gt; <b>inline</b>
  _FwdIt1 find_end(_FwdIt1 _First1, _FwdIt1 _Last1,
    _FwdIt2 _First2, _FwdIt2 _Last2)
  { <font color="#003399"><i>// find last [_First2, _Last2) match</i></font>
  <b>return</b> (_Find_end(_First1, _Last1, _First2, _Last2,
    _Dist_type(_First1), _Dist_type(_First2)));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION find_end WITH PRED</i></font>
<b>template</b>&lt;<b>class</b> _FwdIt1,
  <b>class</b> _FwdIt2,
  <b>class</b> _Diff1,
  <b>class</b> _Diff2,
  <b>class</b> _Pr&gt; <b>inline</b>
  _FwdIt1 _Find_end(_FwdIt1 _First1, _FwdIt1 _Last1,
    _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred, _Diff1 *, _Diff2 *)
  { <font color="#003399"><i>// find last [_First2, _Last2) satisfying _Pred</i></font>
  _Diff1 _Count1 = 0;
  _Distance(_First1, _Last1, _Count1);
  _Diff2 _Count2 = 0;
  _Distance(_First2, _Last2, _Count2);
  _FwdIt1 _Ans = _Last1;

  <b>if</b> (0 &lt; _Count2)
    <b>for</b> (; _Count2 &lt;= _Count1; ++_First1, --_Count1)
      { <font color="#003399"><i>// room for match, try it</i></font>
      _FwdIt1 _Mid1 = _First1;
      <b>for</b> (_FwdIt2 _Mid2 = _First2; ; ++_Mid1)
        <b>if</b> (!_Pred(*_Mid1, *_Mid2))
          <b>break</b>;
        <b>else</b> <b>if</b> (++_Mid2 == _Last2)
          { <font color="#003399"><i>// potential answer, save it</i></font>
          _Ans = _First1;
          <b>break</b>;
          }
      }
  <b>return</b> (_Ans);
  }

<b>template</b>&lt;<b>class</b> _FwdIt1,
  <b>class</b> _FwdIt2,
  <b>class</b> _Pr&gt; <b>inline</b>
  _FwdIt1 find_end(_FwdIt1 _First1, _FwdIt1 _Last1,
    _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
  { <font color="#003399"><i>// find last [_First2, _Last2) satisfying _Pred</i></font>
  <b>return</b> (_Find_end(_First1, _Last1, _First2, _Last2, _Pred,
    _Dist_type(_First1), _Dist_type(_First2)));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION find_first_of</i></font>
<b>template</b>&lt;<b>class</b> _FwdIt1,
  <b>class</b> _FwdIt2&gt; <b>inline</b>
  _FwdIt1 find_first_of(_FwdIt1 _First1, _FwdIt1 _Last1,
    _FwdIt2 _First2, _FwdIt2 _Last2)
  { <font color="#003399"><i>// look for one of [_First2, _Last2) that matches element</i></font>
  <b>for</b> (; _First1 != _Last1; ++_First1)
    <b>for</b> (_FwdIt2 _Mid2 = _First2; _Mid2 != _Last2; ++_Mid2)
      <b>if</b> (*_First1 == *_Mid2)
        <b>return</b> (_First1);
  <b>return</b> (_First1);
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION find_first_of WITH PRED</i></font>
<b>template</b>&lt;<b>class</b> _FwdIt1,
  <b>class</b> _FwdIt2,
  <b>class</b> _Pr&gt; <b>inline</b>
  _FwdIt1 find_first_of(_FwdIt1 _First1, _FwdIt1 _Last1,
    _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
  { <font color="#003399"><i>// look for one of [_First2, _Last2) satisfying _Pred with element</i></font>
  <b>for</b> (; _First1 != _Last1; ++_First1)
    <b>for</b> (_FwdIt2 _Mid2 = _First2; _Mid2 != _Last2; ++_Mid2)
      <b>if</b> (_Pred(*_First1, *_Mid2))
        <b>return</b> (_First1);
  <b>return</b> (_First1);
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION iter_swap</i></font>
<b>template</b>&lt;<b>class</b> _FwdIt1,
  <b>class</b> _FwdIt2&gt; <b>inline</b>
  <b>void</b> iter_swap(_FwdIt1 _Left, _FwdIt2 _Right)
  { <font color="#003399"><i>// swap *_Left and *_Right</i></font>
  std::swap(*_Left, *_Right);
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION swap_ranges</i></font>
<b>template</b>&lt;<b>class</b> _FwdIt1,
  <b>class</b> _FwdIt2&gt; <b>inline</b>
  _FwdIt2 swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2)
  { <font color="#003399"><i>// swap [_First1, _Last1) with [_First2, ...)</i></font>
  <b>for</b> (; _First1 != _Last1; ++_First1, ++_First2)
    std::iter_swap(_First1, _First2);
  <b>return</b> (_First2);
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION transform WITH UNARY OP</i></font>
<b>template</b>&lt;<b>class</b> _InIt,
  <b>class</b> _OutIt,
  <b>class</b> _Fn1&gt; <b>inline</b>
  _OutIt transform(_InIt _First, _InIt _Last, _OutIt _Dest, _Fn1 _Func)
  { <font color="#003399"><i>// transform [_First, _Last) with _Func</i></font>
  <b>for</b> (; _First != _Last; ++_First, ++_Dest)
    *_Dest = _Func(*_First);
  <b>return</b> (_Dest);
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION transform WITH BINARY OP</i></font>
<b>template</b>&lt;<b>class</b> _InIt1,
  <b>class</b> _InIt2,
  <b>class</b> _OutIt,
  <b>class</b> _Fn2&gt; <b>inline</b>
  _OutIt transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
    _OutIt _Dest, _Fn2 _Func)
  { <font color="#003399"><i>// transform [_First1, _Last1) and [_First2, _Last2) with _Func</i></font>
  <b>for</b> (; _First1 != _Last1; ++_First1, ++_First2, ++_Dest)
    *_Dest = _Func(*_First1, *_First2);
  <b>return</b> (_Dest);
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION replace</i></font>
<b>template</b>&lt;<b>class</b> _FwdIt,
  <b>class</b> _Ty&gt; <b>inline</b>
  <b>void</b> replace(_FwdIt _First, _FwdIt _Last,
    <b>const</b> _Ty&amp; _Oldval, <b>const</b> _Ty&amp; _Newval)
  { <font color="#003399"><i>// replace each matching _Oldval with _Newval</i></font>
  <b>for</b> (; _First != _Last; ++_First)
    <b>if</b> (*_First == _Oldval)
      *_First = _Newval;
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION replace_if</i></font>
<b>template</b>&lt;<b>class</b> _FwdIt,
  <b>class</b> _Pr,
  <b>class</b> _Ty&gt; <b>inline</b>
  <b>void</b> replace_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred, <b>const</b> _Ty&amp; _Val)
  { <font color="#003399"><i>// replace each satisfying _Pred with _Val</i></font>
  <b>for</b> (; _First != _Last; ++_First)
    <b>if</b> (_Pred(*_First))
      *_First = _Val;
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION replace_copy</i></font>
<b>template</b>&lt;<b>class</b> _InIt,
  <b>class</b> _OutIt,
  <b>class</b> _Ty&gt; <b>inline</b>
  _OutIt replace_copy(_InIt _First, _InIt _Last, _OutIt _Dest,
    <b>const</b> _Ty&amp; _Oldval, <b>const</b> _Ty&amp; _Newval)
  { <font color="#003399"><i>// copy replacing each matching _Oldval with _Newval</i></font>
  <b>for</b> (; _First != _Last; ++_First, ++_Dest)
    *_Dest = *_First == _Oldval ? _Newval : *_First;
  <b>return</b> (_Dest);
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION replace_copy_if</i></font>
<b>template</b>&lt;<b>class</b> _InIt,
  <b>class</b> _OutIt,
  <b>class</b> _Pr,
  <b>class</b> _Ty&gt; <b>inline</b>
  _OutIt replace_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest,
    _Pr _Pred, <b>const</b> _Ty&amp; _Val)
  { <font color="#003399"><i>// copy replacing each satisfying _Pred with _Val</i></font>
  <b>for</b> (; _First != _Last; ++_First, ++_Dest)
    *_Dest = _Pred(*_First) ? _Val : *_First;
  <b>return</b> (_Dest);
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION generate</i></font>
<b>template</b>&lt;<b>class</b> _FwdIt,
  <b>class</b> _Fn0&gt; <b>inline</b>
  <b>void</b> generate(_FwdIt _First, _FwdIt _Last, _Fn0 _Func)
  { <font color="#003399"><i>// replace [_First, _Last) with _Func()</i></font>
  <b>for</b> (; _First != _Last; ++_First)
    *_First = _Func();
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION generate_n</i></font>
<b>template</b>&lt;<b>class</b> _OutIt,
  <b>class</b> _Diff,
  <b>class</b> _Fn0&gt; <b>inline</b>
  <b>void</b> generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func)
  { <font color="#003399"><i>// replace [_Dest, _Dest + _Count) with _Func()</i></font>
  <b>for</b> (; 0 &lt; _Count; --_Count, ++_Dest)
    *_Dest = _Func();
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION remove_copy</i></font>
<b>template</b>&lt;<b>class</b> _InIt,
  <b>class</b> _OutIt,
  <b>class</b> _Ty&gt; <b>inline</b>
  _OutIt remove_copy(_InIt _First, _InIt _Last,
    _OutIt _Dest, <b>const</b> _Ty&amp; _Val)
  { <font color="#003399"><i>// copy omitting each matching _Val</i></font>
  <b>for</b> (; _First != _Last; ++_First)
    <b>if</b> (!(*_First == _Val))
      *_Dest++ = *_First;
  <b>return</b> (_Dest);
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION remove_copy_if</i></font>
<b>template</b>&lt;<b>class</b> _InIt,
  <b>class</b> _OutIt,
  <b>class</b> _Pr&gt; <b>inline</b>
  _OutIt remove_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)
  { <font color="#003399"><i>// copy omitting each element satisfying _Pred</i></font>
  <b>for</b> (; _First != _Last; ++_First)
    <b>if</b> (!_Pred(*_First))
      *_Dest++ = *_First;
  <b>return</b> (_Dest);
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION remove</i></font>
<b>template</b>&lt;<b>class</b> _FwdIt,
  <b>class</b> _Ty&gt; <b>inline</b>
  _FwdIt remove(_FwdIt _First, _FwdIt _Last, <b>const</b> _Ty&amp; _Val)
  { <font color="#003399"><i>// remove each matching _Val</i></font>
  _First = find(_First, _Last, _Val);
  <b>if</b> (_First == _Last)
    <b>return</b> (_First);  <font color="#003399"><i>// empty sequence, all done</i></font>
  <b>else</b>
    { <font color="#003399"><i>// nonempty sequence, worth doing</i></font>
    _FwdIt _First1 = _First;
    <b>return</b> (std::remove_copy(++_First1, _Last, _First, _Val));
    }
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION remove_if</i></font>
<b>template</b>&lt;<b>class</b> _FwdIt,
  <b>class</b> _Pr&gt; <b>inline</b>
  _FwdIt remove_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
  { <font color="#003399"><i>// remove each satisfying _Pred</i></font>
  _First = std::find_if(_First, _Last, _Pred);
  <b>if</b> (_First == _Last)
    <b>return</b> (_First);  <font color="#003399"><i>// empty sequence, all done</i></font>
  <b>else</b>
    { <font color="#003399"><i>// nonempty sequence, worth doing</i></font>
    _FwdIt _First1 = _First;
    <b>return</b> (std::remove_copy_if(++_First1, _Last, _First, _Pred));
    }
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION unique</i></font>
<b>template</b>&lt;<b>class</b> _FwdIt&gt; <b>inline</b>
  _FwdIt unique(_FwdIt _First, _FwdIt _Last)
  { <font color="#003399"><i>// remove each matching previous</i></font>
  <b>for</b> (_FwdIt _Firstb; (_Firstb = _First) != _Last &amp;&amp; ++_First != _Last; )
    <b>if</b> (*_Firstb == *_First)
      { <font color="#003399"><i>// copy down</i></font>
      <b>for</b> (; ++_First != _Last; )
        <b>if</b> (!(*_Firstb == *_First))
          *++_Firstb = *_First;
      <b>return</b> (++_Firstb);
      }
  <b>return</b> (_Last);
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION unique WITH PRED</i></font>
<b>template</b>&lt;<b>class</b> _FwdIt,
  <b>class</b> _Pr&gt; <b>inline</b>
  _FwdIt unique(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
  { <font color="#003399"><i>// remove each satisfying _Pred with previous</i></font>
  <b>for</b> (_FwdIt _Firstb; (_Firstb = _First) != _Last &amp;&amp; ++_First != _Last; )
    <b>if</b> (_Pred(*_Firstb, *_First))
      { <font color="#003399"><i>// copy down</i></font>
      <b>for</b> (; ++_First != _Last; )
        <b>if</b> (!_Pred(*_Firstb, *_First))
          *++_Firstb = *_First;
      <b>return</b> (++_Firstb);
      }
  <b>return</b> (_Last);
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION unique_copy</i></font>
<b>template</b>&lt;<b>class</b> _InIt,
  <b>class</b> _OutIt,
  <b>class</b> _Ty&gt; <b>inline</b>
  _OutIt _Unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Ty *)
  { <font color="#003399"><i>// copy compressing pairs that match, input iterators</i></font>
  _Ty _Val = *_First;

  <b>for</b> (*_Dest++ = _Val; ++_First != _Last; )
    <b>if</b> (!(_Val == *_First))
      _Val = *_First, *_Dest++ = _Val;
  <b>return</b> (_Dest);
  }

<b>template</b>&lt;<b>class</b> _InIt,
  <b>class</b> _OutIt&gt; <b>inline</b>
  _OutIt _Unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest,
    input_iterator_tag)
  { <font color="#003399"><i>// copy compressing pairs that match, input iterators</i></font>
  <b>return</b> (_Unique_copy(_First, _Last, _Dest, _Val_type(_First)));
  }

<b>template</b>&lt;<b>class</b> _FwdIt,
  <b>class</b> _OutIt&gt; <b>inline</b>
  _OutIt _Unique_copy(_FwdIt _First, _FwdIt _Last, _OutIt _Dest,
    forward_iterator_tag)
  { <font color="#003399"><i>// copy compressing pairs that match, forward iterators</i></font>
  _FwdIt _Firstb = _First;
  <b>for</b> (*_Dest++ = *_Firstb; ++_First != _Last; )
    <b>if</b> (!(*_Firstb == *_First))
      _Firstb = _First, *_Dest++ = *_Firstb;
  <b>return</b> (_Dest);
  }

<b>template</b>&lt;<b>class</b> _BidIt,
  <b>class</b> _OutIt&gt; <b>inline</b>
  _OutIt _Unique_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest,
    bidirectional_iterator_tag)
  { <font color="#003399"><i>// copy compressing pairs that match, bidirectional iterators</i></font>
  <b>return</b> (_Unique_copy(_First, _Last, _Dest, forward_iterator_tag()));
  }

<b>template</b>&lt;<b>class</b> _RanIt,
  <b>class</b> _OutIt&gt; <b>inline</b>
  _OutIt _Unique_copy(_RanIt _First, _RanIt _Last, _OutIt _Dest,
    random_access_iterator_tag)
  { <font color="#003399"><i>// copy compressing pairs that match, random-access iterators</i></font>
  <b>return</b> (_Unique_copy(_First, _Last, _Dest, forward_iterator_tag()));
  }

<b>template</b>&lt;<b>class</b> _InIt,
  <b>class</b> _OutIt&gt; <b>inline</b>
  _OutIt unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest)
  { <font color="#003399"><i>// copy compressing pairs that match</i></font>
  <b>return</b> (_First == _Last ? _Dest :
    _Unique_copy(_First, _Last, _Dest, _Iter_cat(_First)));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION unique_copy WITH PRED</i></font>
<b>template</b>&lt;<b>class</b> _InIt,
  <b>class</b> _OutIt,
  <b>class</b> _Ty,
  <b>class</b> _Pr&gt; <b>inline</b>
  _OutIt _Unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred,
    _Ty *)
  { <font color="#003399"><i>// copy compressing pairs satisfying _Pred, input iterators</i></font>
  _Ty _Val = *_First;

  <b>for</b> (*_Dest++ = _Val; ++_First != _Last; )
    <b>if</b> (!_Pred(_Val, *_First))
      _Val = *_First, *_Dest++ = _Val;
  <b>return</b> (_Dest);
  }

<b>template</b>&lt;<b>class</b> _InIt,
  <b>class</b> _OutIt,
  <b>class</b> _Pr&gt; <b>inline</b>
  _OutIt _Unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred,
    input_iterator_tag)
  { <font color="#003399"><i>// copy compressing pairs satisfying _Pred, input iterators</i></font>
  <b>return</b> (_Unique_copy(_First, _Last, _Dest, _Pred, _Val_type(_First)));
  }

<b>template</b>&lt;<b>class</b> _FwdIt,
  <b>class</b> _OutIt,
  <b>class</b> _Pr&gt; <b>inline</b>
  _OutIt _Unique_copy(_FwdIt _First, _FwdIt _Last, _OutIt _Dest, _Pr _Pred,
    forward_iterator_tag)
  { <font color="#003399"><i>// copy compressing pairs satisfying _Pred, forward iterators</i></font>
  _FwdIt _Firstb = _First;

  <b>for</b> (*_Dest++ = *_Firstb; ++_First != _Last; )
    <b>if</b> (!_Pred(*_Firstb, *_First))
      _Firstb = _First, *_Dest++ = *_Firstb;
  <b>return</b> (_Dest);
  }

<b>template</b>&lt;<b>class</b> _BidIt,
  <b>class</b> _OutIt,
  <b>class</b> _Pr&gt; <b>inline</b>
  _OutIt _Unique_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest, _Pr _Pred,
    bidirectional_iterator_tag)
  { <font color="#003399"><i>// copy compressing pairs satisfying _Pred, bidirectional iterators</i></font>
  <b>return</b> (_Unique_copy(_First, _Last, _Dest, _Pred,
    forward_iterator_tag()));
  }

<b>template</b>&lt;<b>class</b> _RanIt,
  <b>class</b> _OutIt,
  <b>class</b> _Pr&gt; <b>inline</b>
  _OutIt _Unique_copy(_RanIt _First, _RanIt _Last, _OutIt _Dest, _Pr _Pred,
    random_access_iterator_tag)
  { <font color="#003399"><i>// copy compressing pairs satisfying _Pred, random-access iterators</i></font>
  <b>return</b> (_Unique_copy(_First, _Last, _Dest, _Pred,
    forward_iterator_tag()));
  }

<b>template</b>&lt;<b>class</b> _InIt,
  <b>class</b> _OutIt,
  <b>class</b> _Pr&gt; <b>inline</b>
  _OutIt unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)
  { <font color="#003399"><i>// copy compressing pairs satisfying _Pred</i></font>
  <b>return</b> (_First == _Last ? _Dest
    : _Unique_copy(_First, _Last, _Dest, _Pred, _Iter_cat(_First)));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION reverse</i></font>
<b>template</b>&lt;<b>class</b> _BidIt&gt; <b>inline</b>
  <b>void</b> _Reverse(_BidIt _First, _BidIt _Last, bidirectional_iterator_tag)
  { <font color="#003399"><i>// reverse elements in [_First, _Last), bidirectional iterators</i></font>
  <b>for</b> (; _First != _Last &amp;&amp; _First != --_Last; ++_First)
    std::iter_swap(_First, _Last);
  }

<b>template</b>&lt;<b>class</b> _RanIt&gt; <b>inline</b>
  <b>void</b> _Reverse(_RanIt _First, _RanIt _Last, random_access_iterator_tag)
  { <font color="#003399"><i>// reverse elements in [_First, _Last), random-access iterators</i></font>
  <b>for</b> (; _First &lt; _Last; ++_First)
    std::iter_swap(_First, --_Last);
  }

<b>template</b>&lt;<b>class</b> _BidIt&gt; <b>inline</b>
  <b>void</b> reverse(_BidIt _First, _BidIt _Last)
  { <font color="#003399"><i>// reverse elements in [_First, _Last)</i></font>
  _Reverse(_First, _Last, _Iter_cat(_First));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION reverse_copy</i></font>
<b>template</b>&lt;<b>class</b> _BidIt,
  <b>class</b> _OutIt&gt; <b>inline</b>
  _OutIt reverse_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest)
  { <font color="#003399"><i>// copy reversing elements in [_First, _Last)</i></font>
  <b>for</b> (; _First != _Last; ++_Dest)
    *_Dest = *--_Last;
  <b>return</b> (_Dest);
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION rotate</i></font>
<b>template</b>&lt;<b>class</b> _FwdIt&gt; <b>inline</b>
  <b>void</b> _Rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
    forward_iterator_tag)
  { <font color="#003399"><i>// rotate [_First, _Last), forward iterators</i></font>
  <b>for</b> (_FwdIt _Next = _Mid; ; )
    { <font color="#003399"><i>// swap [_First, ...) into place</i></font>
    std::iter_swap(_First, _Next);
    <b>if</b> (++_First == _Mid)
      <b>if</b> (++_Next == _Last)
        <b>break</b>;  <font color="#003399"><i>// done, quit</i></font>
      <b>else</b>
        _Mid = _Next; <font color="#003399"><i>// mark end of next interval</i></font>
    <b>else</b> <b>if</b> (++_Next == _Last)
      _Next = _Mid; <font color="#003399"><i>// wrap to last end</i></font>
    }
  }

<b>template</b>&lt;<b>class</b> _BidIt&gt; <b>inline</b>
  <b>void</b> _Rotate(_BidIt _First, _BidIt _Mid, _BidIt _Last,
    bidirectional_iterator_tag)
  { <font color="#003399"><i>// rotate [_First, _Last), bidirectional iterators</i></font>
  std::reverse(_First, _Mid);
  std::reverse(_Mid, _Last);
  std::reverse(_First, _Last);
  }

<b>template</b>&lt;<b>class</b> _RanIt,
  <b>class</b> _Diff,
  <b>class</b> _Ty&gt; <b>inline</b>
  <b>void</b> _Rotate(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Diff *, _Ty *)
  { <font color="#003399"><i>// rotate [_First, _Last), random-access iterators</i></font>
  _Diff _Shift = _Mid - _First;
  _Diff _Count = _Last - _First;

  <b>for</b> (_Diff _Factor = _Shift; _Factor != 0; )
    { <font color="#003399"><i>// find subcycle count as GCD of shift count and length</i></font>
    _Diff _Tmp = _Count % _Factor;
    _Count = _Factor, _Factor = _Tmp;
    }

  <b>if</b> (_Count &lt; _Last - _First)
    <b>for</b> (; 0 &lt; _Count; --_Count)
      { <font color="#003399"><i>// rotate each subcycle</i></font>
      _RanIt _Hole = _First + _Count;
      _RanIt _Next = _Hole;
      _Ty _Holeval = *_Hole;
      _RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;
      <b>while</b> (_Next1 != _Hole)
        { <font color="#003399"><i>// percolate elements back around subcycle</i></font>
        *_Next = *_Next1;
        _Next = _Next1;
        _Next1 = _Shift &lt; _Last - _Next1 ? _Next1 + _Shift
          : _First + (_Shift - (_Last - _Next1));
        }
      *_Next = _Holeval;
      }
  }

<b>template</b>&lt;<b>class</b> _RanIt&gt; <b>inline</b>
  <b>void</b> _Rotate(_RanIt _First, _RanIt _Mid, _RanIt _Last,
      random_access_iterator_tag)
  { <font color="#003399"><i>// rotate [_First, _Last), random-access iterators</i></font>
  _Rotate(_First, _Mid, _Last, _Dist_type(_First), _Val_type(_First));
  }

<b>template</b>&lt;<b>class</b> _FwdIt&gt; <b>inline</b>
  <b>void</b> rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last)
  { <font color="#003399"><i>// rotate [_First, _Last)</i></font>
  <b>if</b> (_First != _Mid &amp;&amp; _Mid != _Last)
    _Rotate(_First, _Mid, _Last, _Iter_cat(_First));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION rotate_copy</i></font>
<b>template</b>&lt;<b>class</b> _FwdIt,
  <b>class</b> _OutIt&gt; <b>inline</b>
  _OutIt rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest)
  { <font color="#003399"><i>// copy rotating [_First, _Last)</i></font>
  _Dest = std::copy(_Mid, _Last, _Dest);
  <b>return</b> (std::copy(_First, _Mid, _Dest));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION random_shuffle</i></font>
<b>template</b>&lt;<b>class</b> _RanIt,
  <b>class</b> _Diff&gt; <b>inline</b>
  <b>void</b> _Random_shuffle(_RanIt _First, _RanIt _Last, _Diff *)
  { <font color="#003399"><i>// shuffle [_First, _Last)</i></font>
  <b>const</b> <b>int</b> _RANDOM_BITS = 15;  <font color="#003399"><i>// minimum random bits from rand()</i></font>
  <b>const</b> <b>int</b> _RANDOM_MAX = (1U &lt;&lt; _RANDOM_BITS) - 1;

  _RanIt _Next = _First;
  <b>for</b> (<b>unsigned</b> <b>long</b> _Index = 2; ++_Next != _Last; ++_Index)
    { <font color="#003399"><i>// assume unsigned long big enough for _Diff count</i></font>
    <b>unsigned</b> <b>long</b> _Rm = _RANDOM_MAX;
    <b>unsigned</b> <b>long</b> _Rn = ::rand() &amp; _RANDOM_MAX;
    <b>for</b> (; _Rm &lt; _Index &amp;&amp; _Rm != ~0UL;
      _Rm = _Rm &lt;&lt; _RANDOM_BITS | _RANDOM_MAX)
      _Rn = _Rn &lt;&lt; _RANDOM_BITS | _RANDOM_MAX;  <font color="#003399"><i>// build random value</i></font>

    std::iter_swap(_Next, _First + _Diff(_Rn % _Index));  <font color="#003399"><i>// swap a pair</i></font>
    }
  }

<b>template</b>&lt;<b>class</b> _RanIt&gt; <b>inline</b>
  <b>void</b> random_shuffle(_RanIt _First, _RanIt _Last)
  { <font color="#003399"><i>// shuffle [_First, _Last)</i></font>
  <b>if</b> (_First != _Last)
    _Random_shuffle(_First, _Last, _Dist_type(_First));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION random_shuffle WITH RANDOM FN</i></font>
<b>template</b>&lt;<b>class</b> _RanIt,
  <b>class</b> _Fn1,
  <b>class</b> _Diff&gt; <b>inline</b>
  <b>void</b> _Random_shuffle(_RanIt _First, _RanIt _Last, _Fn1&amp; _Func, _Diff *)
  { <font color="#003399"><i>// shuffle nonempty [_First, _Last) using random function _Func</i></font>
  _RanIt _Next = _First;

  <b>for</b> (_Diff _Index = 2; ++_Next != _Last; ++_Index)
    std::iter_swap(_Next, _First + _Diff(_Func(_Index)));
  }

<b>template</b>&lt;<b>class</b> _RanIt,
  <b>class</b> _Fn1&gt; <b>inline</b>
  <b>void</b> random_shuffle(_RanIt _First, _RanIt _Last, _Fn1&amp; _Func)
  { <font color="#003399"><i>// shuffle [_First, _Last) using random function _Func</i></font>
  <b>if</b> (_First != _Last)
    _Random_shuffle(_First, _Last, _Func, _Dist_type(_First));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION partition</i></font>
<b>template</b>&lt;<b>class</b> _BidIt,
  <b>class</b> _Pr&gt; <b>inline</b>
  _BidIt partition(_BidIt _First, _BidIt _Last, _Pr _Pred)
  { <font color="#003399"><i>// move elements satisfying _Pred to beginning of sequence</i></font>
  <b>for</b> (; ; ++_First)
    { <font color="#003399"><i>// find any out-of-order pair</i></font>
    <b>for</b> (; _First != _Last &amp;&amp; _Pred(*_First); ++_First)
      ; <font color="#003399"><i>// skip in-place elements at beginning</i></font>
    <b>if</b> (_First == _Last)
      <b>break</b>;  <font color="#003399"><i>// done</i></font>

    <b>for</b> (; _First != --_Last &amp;&amp; !_Pred(*_Last); )
      ; <font color="#003399"><i>// skip in-place elements at end</i></font>
    <b>if</b> (_First == _Last)
      <b>break</b>;  <font color="#003399"><i>// done</i></font>

    std::iter_swap(_First, _Last);  <font color="#003399"><i>// swap out-of-place pair and loop</i></font>
    }
  <b>return</b> (_First);
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION stable_partition</i></font>
<b>template</b>&lt;<b>class</b> _BidIt,
  <b>class</b> _Pr,
  <b>class</b> _Diff,
  <b>class</b> _Ty&gt; <b>inline</b>
  _BidIt _Stable_partition(_BidIt _First, _BidIt _Last, _Pr _Pred,
    _Diff _Count, _Temp_iterator&lt;_Ty&gt;&amp; _Tempbuf)
  { <font color="#003399"><i>// partition preserving order of equivalents, using _Pred</i></font>
  <b>if</b> (_Count == 1)
    <b>return</b> (_Pred(*_First) ? _Last : _First);
  <b>else</b> <b>if</b> (_Count &lt;= _Tempbuf._Maxlen())
    { <font color="#003399"><i>// temp buffer big enough, copy right partition out and back</i></font>
    _BidIt _Next = _First;
    <b>for</b> (_Tempbuf._Init(); _First != _Last; ++_First)
      <b>if</b> (_Pred(*_First))
        *_Next++ = *_First;
      <b>else</b>
        *_Tempbuf++ = *_First;

    std::copy(_Tempbuf._First(), _Tempbuf._Last(), _Next);  <font color="#003399"><i>// copy back</i></font>
    <b>return</b> (_Next);
    }
  <b>else</b>
    { <font color="#003399"><i>// temp buffer not big enough, divide and conquer</i></font>
    _BidIt _Mid = _First;
    std::advance(_Mid, _Count / 2);

    _BidIt _Left = _Stable_partition(_First, _Mid, _Pred,
      _Count / 2, _Tempbuf);  <font color="#003399"><i>// form L1R1 in left half</i></font>
    _BidIt _Right = _Stable_partition(_Mid, _Last, _Pred,
      _Count - _Count / 2, _Tempbuf); <font color="#003399"><i>// form L2R2 in right half</i></font>

    _Diff _Count1 = 0;
    _Distance(_Left, _Mid, _Count1);
    _Diff _Count2 = 0;
    _Distance(_Mid, _Right, _Count2);

    <b>return</b> (_Buffered_rotate(_Left, _Mid, _Right,
      _Count1, _Count2, _Tempbuf)); <font color="#003399"><i>// rotate L1R1L2R2 to L1L2R1R2</i></font>
    }
  }

<b>template</b>&lt;<b>class</b> _BidIt,
  <b>class</b> _Pr,
  <b>class</b> _Diff,
  <b>class</b> _Ty&gt; <b>inline</b>
  _BidIt _Stable_partition(_BidIt _First, _BidIt _Last, _Pr _Pred,
    _Diff *, _Ty *)
  { <font color="#003399"><i>// partition preserving order of equivalents, using _Pred</i></font>
  _Diff _Count = 0;
  _Distance(_First, _Last, _Count);
  _Temp_iterator&lt;_Ty&gt; _Tempbuf(_Count);
  <b>return</b> (_Stable_partition(_First, _Last, _Pred, _Count, _Tempbuf));
  }

<b>template</b>&lt;<b>class</b> _BidIt,
  <b>class</b> _Pr&gt; <b>inline</b>
  _BidIt stable_partition(_BidIt _First, _BidIt _Last, _Pr _Pred)
  { <font color="#003399"><i>// partition preserving order of equivalents, using _Pred</i></font>
  <b>return</b> (_First == _Last ? _First : _Stable_partition(_First, _Last, _Pred,
    _Dist_type(_First), _Val_type(_First)));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION push_heap</i></font>
<b>template</b>&lt;<b>class</b> _RanIt,
  <b>class</b> _Diff,
  <b>class</b> _Ty&gt; <b>inline</b>
  <b>void</b> _Push_heap(_RanIt _First, _Diff _Hole,
    _Diff _Top, _Ty _Val)
  { <font color="#003399"><i>// percolate _Hole to _Top or where _Val belongs, using operator&lt;</i></font>
  <b>for</b> (_Diff _Idx = (_Hole - 1) / 2;
    _Top &lt; _Hole &amp;&amp; *(_First + _Idx) &lt; _Val;
    _Idx = (_Hole - 1) / 2)
    { <font color="#003399"><i>// move _Hole up to parent</i></font>
    *(_First + _Hole) = *(_First + _Idx);
    _Hole = _Idx;
    }

  *(_First + _Hole) = _Val; <font color="#003399"><i>// drop _Val into final hole</i></font>
  }

<b>template</b>&lt;<b>class</b> _RanIt,
  <b>class</b> _Diff,
  <b>class</b> _Ty&gt; <b>inline</b>
  <b>void</b> _Push_heap_0(_RanIt _First, _RanIt _Last, _Diff *, _Ty *)
  { <font color="#003399"><i>// push *_Last onto heap at [_First, _Last), using operator&lt;</i></font>
  _Diff _Count = _Last - _First;
  <b>if</b> (0 &lt; _Count)
    _Push_heap(_First, _Count, _Diff(0), _Ty(*_Last));
  }

<b>template</b>&lt;<b>class</b> _RanIt&gt; <b>inline</b>
  <b>void</b> push_heap(_RanIt _First, _RanIt _Last)
  { <font color="#003399"><i>// push *(_Last - 1) onto heap at [_First, _Last - 1), using operator&lt;</i></font>
  <b>if</b> (_First != _Last)
    _Push_heap_0(_First, --_Last,
      _Dist_type(_First), _Val_type(_First));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION push_heap WITH PRED</i></font>
<b>template</b>&lt;<b>class</b> _RanIt,
  <b>class</b> _Diff,
  <b>class</b> _Ty,
  <b>class</b> _Pr&gt; <b>inline</b>
  <b>void</b> _Push_heap(_RanIt _First, _Diff _Hole,
    _Diff _Top, _Ty _Val, _Pr _Pred)
  { <font color="#003399"><i>// percolate _Hole to _Top or where _Val belongs, using operator&lt;</i></font>
  <b>for</b> (_Diff _Idx = (_Hole - 1) / 2;
    _Top &lt; _Hole &amp;&amp; _Pred(*(_First + _Idx), _Val);
    _Idx = (_Hole - 1) / 2)
    { <font color="#003399"><i>// move _Hole up to parent</i></font>
    *(_First + _Hole) = *(_First + _Idx);
    _Hole = _Idx;
    }

  *(_First + _Hole) = _Val; <font color="#003399"><i>// drop _Val into final hole</i></font>
  }

<b>template</b>&lt;<b>class</b> _RanIt,
  <b>class</b> _Diff,
  <b>class</b> _Ty,
  <b>class</b> _Pr&gt; <b>inline</b>
  <b>void</b> _Push_heap_0(_RanIt _First, _RanIt _Last, _Pr _Pred, _Diff *, _Ty *)
  { <font color="#003399"><i>// push *_Last onto heap at [_First, _Last), using _Pred</i></font>
  _Diff _Count = _Last - _First;
  <b>if</b> (0 &lt; _Count)
    _Push_heap(_First, _Count, _Diff(0), _Ty(*_Last), _Pred);
  }

<b>template</b>&lt;<b>class</b> _RanIt,
  <b>class</b> _Pr&gt; <b>inline</b>
  <b>void</b> push_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
  { <font color="#003399"><i>// push *(_Last - 1) onto heap at [_First, _Last - 1), using _Pred</i></font>
  <b>if</b> (_First != _Last)
    _Push_heap_0(_First, --_Last, _Pred,
      _Dist_type(_First), _Val_type(_First));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION pop_heap</i></font>
<b>template</b>&lt;<b>class</b> _RanIt,
  <b>class</b> _Diff,
  <b>class</b> _Ty&gt; <b>inline</b>
  <b>void</b> _Adjust_heap(_RanIt _First, _Diff _Hole, _Diff _Bottom, _Ty _Val)
  { <font color="#003399"><i>// percolate _Hole to _Bottom, then push _Val, using operator&lt;</i></font>
  _Diff _Top = _Hole;
  _Diff _Idx = 2 * _Hole + 2;

  <b>for</b> (; _Idx &lt; _Bottom; _Idx = 2 * _Idx + 2)
    { <font color="#003399"><i>// move _Hole down to larger child</i></font>
    <b>if</b> (*(_First + _Idx) &lt; *(_First + (_Idx - 1)))
      --_Idx;
    *(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;
    }

  <b>if</b> (_Idx == _Bottom)
    { <font color="#003399"><i>// only child at bottom, move _Hole down to it</i></font>
    *(_First + _Hole) = *(_First + (_Bottom - 1));
    _Hole = _Bottom - 1;
    }
  _Push_heap(_First, _Hole, _Top, _Val);
  }

<b>template</b>&lt;<b>class</b> _RanIt,
  <b>class</b> _Diff,
  <b>class</b> _Ty&gt; <b>inline</b>
  <b>void</b> _Pop_heap(_RanIt _First, _RanIt _Last, _RanIt _Dest,
    _Ty _Val, _Diff *)
  { <font color="#003399"><i>// pop *_First to *_Dest and reheap, using operator&lt;</i></font>
  *_Dest = *_First;
  _Adjust_heap(_First, _Diff(0), _Diff(_Last - _First), _Val);
  }

<b>template</b>&lt;<b>class</b> _RanIt,
  <b>class</b> _Ty&gt; <b>inline</b>
  <b>void</b> _Pop_heap_0(_RanIt _First, _RanIt _Last, _Ty *)
  { <font color="#003399"><i>// pop *_First to *(_Last - 1) and reheap, using operator&lt;</i></font>
  _Pop_heap(_First, _Last - 1, _Last - 1,
    _Ty(*(_Last - 1)), _Dist_type(_First));
  }

<b>template</b>&lt;<b>class</b> _RanIt&gt; <b>inline</b>
  <b>void</b> pop_heap(_RanIt _First, _RanIt _Last)
  { <font color="#003399"><i>// pop *_First to *(_Last - 1) and reheap, using operator&lt;</i></font>
  <b>if</b> (1 &lt; _Last - _First)
    _Pop_heap_0(_First, _Last, _Val_type(_First));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION pop_heap WITH PRED</i></font>
<b>template</b>&lt;<b>class</b> _RanIt,
  <b>class</b> _Diff,
  <b>class</b> _Ty,
  <b>class</b> _Pr&gt; <b>inline</b>
  <b>void</b> _Adjust_heap(_RanIt _First, _Diff _Hole, _Diff _Bottom,
    _Ty _Val, _Pr _Pred)
  { <font color="#003399"><i>// percolate _Hole to _Bottom, then push _Val, using _Pred</i></font>
  _Diff _Top = _Hole;
  _Diff _Idx = 2 * _Hole + 2;

  <b>for</b> (; _Idx &lt; _Bottom; _Idx = 2 * _Idx + 2)
    { <font color="#003399"><i>// move _Hole down to larger child</i></font>
    <b>if</b> (_Pred(*(_First + _Idx), *(_First + (_Idx - 1))))
      --_Idx;
    *(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;
    }

  <b>if</b> (_Idx == _Bottom)
    { <font color="#003399"><i>// only child at bottom, move _Hole down to it</i></font>
    *(_First + _Hole) = *(_First + (_Bottom - 1));
    _Hole = _Bottom - 1;
    }
  _Push_heap(_First, _Hole, _Top, _Val, _Pred);
  }

<b>template</b>&lt;<b>class</b> _RanIt,
  <b>class</b> _Diff,
  <b>class</b> _Ty,
  <b>class</b> _Pr&gt; <b>inline</b>
  <b>void</b> _Pop_heap(_RanIt _First, _RanIt _Last, _RanIt _Dest,
    _Ty _Val, _Pr _Pred, _Diff *)
  { <font color="#003399"><i>// pop *_First to *_Dest and reheap, using _Pred</i></font>
  *_Dest = *_First;
  _Adjust_heap(_First, _Diff(0), _Diff(_Last - _First), _Val, _Pred);
  }

<b>template</b>&lt;<b>class</b> _RanIt,
  <b>class</b> _Ty,
  <b>class</b> _Pr&gt; <b>inline</b>
  <b>void</b> _Pop_heap_0(_RanIt _First, _RanIt _Last, _Pr _Pred, _Ty *)
  { <font color="#003399"><i>// pop *_First to *(_Last - 1) and reheap, using _Pred</i></font>
  _Pop_heap(_First, _Last - 1, _Last - 1,
    _Ty(*(_Last - 1)), _Pred, _Dist_type(_First));
  }

<b>template</b>&lt;<b>class</b> _RanIt,
  <b>class</b> _Pr&gt; <b>inline</b>
  <b>void</b> pop_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
  { <font color="#003399"><i>// pop *_First to *(_Last - 1) and reheap, using _Pred</i></font>
  <b>if</b> (1 &lt; _Last - _First)
    _Pop_heap_0(_First, _Last, _Pred, _Val_type(_First));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION make_heap</i></font>
<b>template</b>&lt;<b>class</b> _RanIt,
  <b>class</b> _Diff,
  <b>class</b> _Ty&gt; <b>inline</b>
  <b>void</b> _Make_heap(_RanIt _First, _RanIt _Last, _Diff *, _Ty *)
  { <font color="#003399"><i>// make nontrivial [_First, _Last) into a heap, using operator&lt;</i></font>
  _Diff _Bottom = _Last - _First;

  <b>for</b> (_Diff _Hole = _Bottom / 2; 0 &lt; _Hole; )
    { <font color="#003399"><i>// reheap top half, bottom to top</i></font>
    --_Hole;
    _Adjust_heap(_First, _Hole, _Bottom, _Ty(*(_First + _Hole)));
    }
  }

<b>template</b>&lt;<b>class</b> _RanIt&gt; <b>inline</b>
  <b>void</b> make_heap(_RanIt _First, _RanIt _Last)
  { <font color="#003399"><i>// make [_First, _Last) into a heap, using operator&lt;</i></font>
  <b>if</b> (1 &lt; _Last - _First)
    _Make_heap(_First, _Last,
      _Dist_type(_First), _Val_type(_First));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION make_heap WITH PRED</i></font>
<b>template</b>&lt;<b>class</b> _RanIt,
  <b>class</b> _Diff,
  <b>class</b> _Ty,
  <b>class</b> _Pr&gt; <b>inline</b>
  <b>void</b> _Make_heap(_RanIt _First, _RanIt _Last, _Pr _Pred, _Diff *, _Ty *)
  { <font color="#003399"><i>// make nontrivial [_First, _Last) into a heap, using _Pred</i></font>
  _Diff _Bottom = _Last - _First;
  <b>for</b> (_Diff _Hole = _Bottom / 2; 0 &lt; _Hole; )
    { <font color="#003399"><i>// reheap top half, bottom to top</i></font>
    --_Hole;
    _Adjust_heap(_First, _Hole, _Bottom,
      _Ty(*(_First + _Hole)), _Pred);
    }
  }

<b>template</b>&lt;<b>class</b> _RanIt,
  <b>class</b> _Pr&gt; <b>inline</b>
  <b>void</b> make_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
  { <font color="#003399"><i>// make [_First, _Last) into a heap, using _Pred</i></font>
  <b>if</b> (1 &lt; _Last - _First)
    _Make_heap(_First, _Last, _Pred,
      _Dist_type(_First), _Val_type(_First));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION sort_heap</i></font>
<b>template</b>&lt;<b>class</b> _RanIt&gt; <b>inline</b>
  <b>void</b> sort_heap(_RanIt _First, _RanIt _Last)
  { <font color="#003399"><i>// order heap by repeatedly popping, using operator&lt;</i></font>
  <b>for</b> (; 1 &lt; _Last - _First; --_Last)
    std::pop_heap(_First, _Last);
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION sort_heap WITH PRED</i></font>
<b>template</b>&lt;<b>class</b> _RanIt,
  <b>class</b> _Pr&gt; <b>inline</b>
  <b>void</b> sort_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
  { <font color="#003399"><i>// order heap by repeatedly popping, using _Pred</i></font>
  <b>for</b> (; 1 &lt; _Last - _First; --_Last)
    std::pop_heap(_First, _Last, _Pred);
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION lower_bound</i></font>
<b>template</b>&lt;<b>class</b> _FwdIt,
  <b>class</b> _Ty,
  <b>class</b> _Diff&gt; <b>inline</b>
  _FwdIt _Lower_bound(_FwdIt _First, _FwdIt _Last, <b>const</b> _Ty&amp; _Val, _Diff *)
  { <font color="#003399"><i>// find first element not before _Val, using operator&lt;</i></font>
  _Diff _Count = 0;
  _Distance(_First, _Last, _Count);

  <b>for</b> (; 0 &lt; _Count; )
    { <font color="#003399"><i>// divide and conquer, find half that contains answer</i></font>
    _Diff _Count2 = _Count / 2;
    _FwdIt _Mid = _First;
    std::advance(_Mid, _Count2);

    <b>if</b> (*_Mid &lt; _Val)
      _First = ++_Mid, _Count -= _Count2 + 1;
    <b>else</b>
      _Count = _Count2;
    }
  <b>return</b> (_First);
  }

<b>template</b>&lt;<b>class</b> _FwdIt,
  <b>class</b> _Ty&gt; <b>inline</b>
  _FwdIt lower_bound(_FwdIt _First, _FwdIt _Last, <b>const</b> _Ty&amp; _Val)
  { <font color="#003399"><i>// find first element not before _Val, using operator&lt;</i></font>
  <b>return</b> (_Lower_bound(_First, _Last, _Val, _Dist_type(_First)));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION lower_bound WITH PRED</i></font>
<b>template</b>&lt;<b>class</b> _FwdIt,
  <b>class</b> _Ty,
  <b>class</b> _Diff,
  <b>class</b> _Pr&gt; <b>inline</b>
  _FwdIt _Lower_bound(_FwdIt _First, _FwdIt _Last,
    <b>const</b> _Ty&amp; _Val, _Pr _Pred, _Diff *)
  { <font color="#003399"><i>// find first element not before _Val, using _Pred</i></font>
  _Diff _Count = 0;
  _Distance(_First, _Last, _Count);
  <b>for</b> (; 0 &lt; _Count; )
    { <font color="#003399"><i>// divide and conquer, find half that contains answer</i></font>
    _Diff _Count2 = _Count / 2;
    _FwdIt _Mid = _First;
    std::advance(_Mid, _Count2);

    <b>if</b> (_Pred(*_Mid, _Val))
      _First = ++_Mid, _Count -= _Count2 + 1;
    <b>else</b>
      _Count = _Count2;
    }
  <b>return</b> (_First);
  }

<b>template</b>&lt;<b>class</b> _FwdIt,
  <b>class</b> _Ty,
  <b>class</b> _Pr&gt; <b>inline</b>
  _FwdIt lower_bound(_FwdIt _First, _FwdIt _Last,
    <b>const</b> _Ty&amp; _Val, _Pr _Pred)
  { <font color="#003399"><i>// find first element not before _Val, using _Pred</i></font>
  <b>return</b> (_Lower_bound(_First, _Last, _Val, _Pred, _Dist_type(_First)));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION upper_bound</i></font>
<b>template</b>&lt;<b>class</b> _FwdIt,
  <b>class</b> _Ty,
  <b>class</b> _Diff&gt; <b>inline</b>
  _FwdIt _Upper_bound(_FwdIt _First, _FwdIt _Last, <b>const</b> _Ty&amp; _Val, _Diff *)
  { <font color="#003399"><i>// find first element that _Val is before, using operator&lt;</i></font>
  _Diff _Count = 0;
  _Distance(_First, _Last, _Count);
  <b>for</b> (; 0 &lt; _Count; )
    { <font color="#003399"><i>// divide and conquer, find half that contains answer</i></font>
    _Diff _Count2 = _Count / 2;
    _FwdIt _Mid = _First;
    std::advance(_Mid, _Count2);

    <b>if</b> (!(_Val &lt; *_Mid))
      _First = ++_Mid, _Count -= _Count2 + 1;
    <b>else</b>
      _Count = _Count2;
    }
  <b>return</b> (_First);
  }

<b>template</b>&lt;<b>class</b> _FwdIt,
  <b>class</b> _Ty&gt; <b>inline</b>
  _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, <b>const</b> _Ty&amp; _Val)
  { <font color="#003399"><i>// find first element that _Val is before, using operator&lt;</i></font>
  <b>return</b> (_Upper_bound(_First, _Last, _Val, _Dist_type(_First)));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION upper_bound WITH PRED</i></font>
<b>template</b>&lt;<b>class</b> _FwdIt,
  <b>class</b> _Ty,
  <b>class</b> _Diff,
  <b>class</b> _Pr&gt; <b>inline</b>
  _FwdIt _Upper_bound(_FwdIt _First, _FwdIt _Last,
    <b>const</b> _Ty&amp; _Val, _Pr _Pred, _Diff *)
  { <font color="#003399"><i>// find first element that _Val is before, using _Pred</i></font>
  _Diff _Count = 0;
  _Distance(_First, _Last, _Count);
  <b>for</b> (; 0 &lt; _Count; )
    { <font color="#003399"><i>// divide and conquer, find half that contains answer</i></font>
    _Diff _Count2 = _Count / 2;
    _FwdIt _Mid = _First;
    std::advance(_Mid, _Count2);

    <b>if</b> (!_Pred(_Val, *_Mid))
      _First = ++_Mid, _Count -= _Count2 + 1;
    <b>else</b>
      _Count = _Count2;
    }
  <b>return</b> (_First);
  }

<b>template</b>&lt;<b>class</b> _FwdIt,
  <b>class</b> _Ty,
  <b>class</b> _Pr&gt; <b>inline</b>
  _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last,
    <b>const</b> _Ty&amp; _Val, _Pr _Pred)
  { <font color="#003399"><i>// find first element that _Val is before, using _Pred</i></font>
  <b>return</b> (_Upper_bound(_First, _Last, _Val, _Pred, _Dist_type(_First)));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION equal_range</i></font>
<b>template</b>&lt;<b>class</b> _FwdIt,
  <b>class</b> _Ty,
  <b>class</b> _Diff&gt; <b>inline</b>
  pair&lt;_FwdIt, _FwdIt&gt; _Equal_range(_FwdIt _First, _FwdIt _Last,
    <b>const</b> _Ty&amp; _Val, _Diff *)
  { <font color="#003399"><i>// find range equivalent to _Val, using operator&lt;</i></font>
  _Diff _Count = 0;
  _Distance(_First, _Last, _Count);

  <b>for</b> (; 0 &lt; _Count; )
    { <font color="#003399"><i>// divide and conquer, check midpoint</i></font>
    _Diff _Count2 = _Count / 2;
    _FwdIt _Mid = _First;
    std::advance(_Mid, _Count2);

    <b>if</b> (*_Mid &lt; _Val)
      { <font color="#003399"><i>// range begins above _Mid, loop</i></font>
      _First = ++_Mid;
      _Count -= _Count2 + 1;
      }
    <b>else</b> <b>if</b> (_Val &lt; *_Mid)
      _Count = _Count2; <font color="#003399"><i>// range in first half, loop</i></font>
    <b>else</b>
      { <font color="#003399"><i>// range straddles mid, find each end and return</i></font>
      _FwdIt _First2 = lower_bound(_First, _Mid, _Val);
      std::advance(_First, _Count);
      _FwdIt _Last2 = upper_bound(++_Mid, _First, _Val);
      <b>return</b> (pair&lt;_FwdIt, _FwdIt&gt;(_First2, _Last2));
      }
    }

  <b>return</b> (pair&lt;_FwdIt, _FwdIt&gt;(_First, _First));  <font color="#003399"><i>// empty range</i></font>
  }

<b>template</b>&lt;<b>class</b> _FwdIt,
  <b>class</b> _Ty&gt; <b>inline</b>
  pair&lt;_FwdIt, _FwdIt&gt; equal_range(_FwdIt _First, _FwdIt _Last,
    <b>const</b> _Ty&amp; _Val)
  { <font color="#003399"><i>// find range equivalent to _Val, using operator&lt;</i></font>
  <b>return</b> (_Equal_range(_First, _Last, _Val, _Dist_type(_First)));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION equal_range WITH PRED</i></font>
<b>template</b>&lt;<b>class</b> _FwdIt,
  <b>class</b> _Ty,
  <b>class</b> _Diff,
  <b>class</b> _Pr&gt; <b>inline</b>
  pair&lt;_FwdIt, _FwdIt&gt; _Equal_range(_FwdIt _First, _FwdIt _Last,
    <b>const</b> _Ty&amp; _Val, _Pr _Pred, _Diff *)
  { <font color="#003399"><i>// find range equivalent to _Val, using _Pred</i></font>
  _Diff _Count = 0;
  _Distance(_First, _Last, _Count);

  <b>for</b> (; 0 &lt; _Count; )
    { <font color="#003399"><i>// divide and conquer, check midpoint</i></font>
    _Diff _Count2 = _Count / 2;
    _FwdIt _Mid = _First;
    std::advance(_Mid, _Count2);

    <b>if</b> (_Pred(*_Mid, _Val))
      { <font color="#003399"><i>// range begins above _Mid, loop</i></font>
      _First = ++_Mid;
      _Count -= _Count2 + 1;
      }
    <b>else</b> <b>if</b> (_Pred(_Val, *_Mid))
      _Count = _Count2; <font color="#003399"><i>// range in first half, loop</i></font>
    <b>else</b>
      { <font color="#003399"><i>// range straddles _Mid, find each end and return</i></font>
      _FwdIt _First2 = lower_bound(_First, _Mid, _Val, _Pred);
      std::advance(_First, _Count);
      _FwdIt _Last2 = upper_bound(++_Mid, _First, _Val, _Pred);
      <b>return</b> (pair&lt;_FwdIt, _FwdIt&gt;(_First2, _Last2));
      }
    }

  <b>return</b> (pair&lt;_FwdIt, _FwdIt&gt;(_First, _First));  <font color="#003399"><i>// empty range</i></font>
  }

<b>template</b>&lt;<b>class</b> _FwdIt,
  <b>class</b> _Ty,
  <b>class</b> _Pr&gt; <b>inline</b>
  pair&lt;_FwdIt, _FwdIt&gt; equal_range(_FwdIt _First, _FwdIt _Last,
    <b>const</b> _Ty&amp; _Val, _Pr _Pred)
  { <font color="#003399"><i>// find range equivalent to _Val, using _Pred</i></font>
  <b>return</b> (_Equal_range(_First, _Last, _Val, _Pred, _Dist_type(_First)));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION binary_search</i></font>
<b>template</b>&lt;<b>class</b> _FwdIt,
  <b>class</b> _Ty&gt; <b>inline</b>
  <b>bool</b> binary_search(_FwdIt _First, _FwdIt _Last, <b>const</b> _Ty&amp; _Val)
  { <font color="#003399"><i>// test if _Val equivalent to some element, using operator&lt;</i></font>
  _First = std::lower_bound(_First, _Last, _Val);
  <b>return</b> (_First != _Last &amp;&amp; !(_Val &lt; *_First));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION binary_search WITH PRED</i></font>
<b>template</b>&lt;<b>class</b> _FwdIt,
  <b>class</b> _Ty,
  <b>class</b> _Pr&gt; <b>inline</b>
  <b>bool</b> binary_search(_FwdIt _First, _FwdIt _Last,
    <b>const</b> _Ty&amp; _Val, _Pr _Pred)
  { <font color="#003399"><i>// test if _Val equivalent to some element, using _Pred</i></font>
  _First = std::lower_bound(_First, _Last, _Val, _Pred);
  <b>return</b> (_First != _Last &amp;&amp; !_Pred(_Val, *_First));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION merge</i></font>
<b>template</b>&lt;<b>class</b> _InIt1,
  <b>class</b> _InIt2,
  <b>class</b> _OutIt&gt; <b>inline</b>
  _OutIt merge(_InIt1 _First1, _InIt1 _Last1,
    _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
  { <font color="#003399"><i>// copy merging ranges, both using operator&lt;</i></font>
  <b>for</b> (; _First1 != _Last1 &amp;&amp; _First2 != _Last2; ++_Dest)
    <b>if</b> (*_First2 &lt; *_First1)
      *_Dest = *_First2, ++_First2;
    <b>else</b>
      *_Dest = *_First1, ++_First1;

  _Dest = std::copy(_First1, _Last1, _Dest);  <font color="#003399"><i>// copy any tail</i></font>
  <b>return</b> (std::copy(_First2, _Last2, _Dest));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION merge WITH PRED</i></font>
<b>template</b>&lt;<b>class</b> _InIt1,
  <b>class</b> _InIt2,
  <b>class</b> _OutIt,
  <b>class</b> _Pr&gt; <b>inline</b>
  _OutIt merge(_InIt1 _First1, _InIt1 _Last1,
    _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
  { <font color="#003399"><i>//  copy merging ranges, both using _Pred</i></font>
  <b>for</b> (; _First1 != _Last1 &amp;&amp; _First2 != _Last2; ++_Dest)
    <b>if</b> (_Pred(*_First2, *_First1))
      *_Dest = *_First2, ++_First2;
    <b>else</b>
      *_Dest = *_First1, ++_First1;

  _Dest = std::copy(_First1, _Last1, _Dest);  <font color="#003399"><i>// copy any tail</i></font>
  <b>return</b> (std::copy(_First2, _Last2, _Dest));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION inplace_merge</i></font>
<b>template</b>&lt;<b>class</b> _BidIt,
  <b>class</b> _Diff,
  <b>class</b> _Ty&gt; <b>inline</b>
  _BidIt _Buffered_rotate(_BidIt _First, _BidIt _Mid, _BidIt _Last,
    _Diff _Count1, _Diff _Count2, _Temp_iterator&lt;_Ty&gt;&amp; _Tempbuf)
  { <font color="#003399"><i>// rotate [_First, _Last) using temp buffer</i></font>
  <b>if</b> (_Count1 &lt;= _Count2 &amp;&amp; _Count1 &lt;= _Tempbuf._Maxlen())
    { <font color="#003399"><i>// buffer left partition, then copy parts</i></font>
    std::copy(_First, _Mid, _Tempbuf._Init());
    std::copy(_Mid, _Last, _First);
    <b>return</b> (std::copy_backward(_Tempbuf._First(), _Tempbuf._Last(),
      _Last));
    }
  <b>else</b> <b>if</b> (_Count2 &lt;= _Tempbuf._Maxlen())
    { <font color="#003399"><i>// buffer right partition, then copy parts</i></font>
    std::copy(_Mid, _Last, _Tempbuf._Init());
    std::copy_backward(_First, _Mid, _Last);
    <b>return</b> (std::copy(_Tempbuf._First(), _Tempbuf._Last(), _First));
    }
  <b>else</b>
    { <font color="#003399"><i>// buffer too small, rotate in place</i></font>
    std::rotate(_First, _Mid, _Last);
    std::advance(_First, _Count2);
    <b>return</b> (_First);
    }
  }

<b>template</b>&lt;<b>class</b> _BidIt1,
  <b>class</b> _BidIt2,
  <b>class</b> _BidIt3&gt; <b>inline</b>
  _BidIt3 _Merge_backward(_BidIt1 _First1, _BidIt1 _Last1,
    _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest)
  { <font color="#003399"><i>// merge backwards to _Dest, using operator&lt;</i></font>
  <b>for</b> (; ; )
    <b>if</b> (_First1 == _Last1)
      <b>return</b> (std::copy_backward(_First2, _Last2, _Dest));
    <b>else</b> <b>if</b> (_First2 == _Last2)
      <b>return</b> (std::copy_backward(_First1, _Last1, _Dest));
    <b>else</b> <b>if</b> (*--_Last2 &lt; *--_Last1)
      *--_Dest = *_Last1, ++_Last2;
    <b>else</b>
      *--_Dest = *_Last2, ++_Last1;
  }

<b>template</b>&lt;<b>class</b> _BidIt,
  <b>class</b> _Diff,
  <b>class</b> _Ty&gt; <b>inline</b>
  <b>void</b> _Buffered_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last,
    _Diff _Count1, _Diff _Count2,
      _Temp_iterator&lt;_Ty&gt;&amp; _Tempbuf)
  { <font color="#003399"><i>// merge [_First, _Mid) with [_Mid, _Last), using operator&lt;</i></font>
  <b>if</b> (_Count1 + _Count2 == 2)
    { <font color="#003399"><i>// order two one-element partitions</i></font>
    <b>if</b> (*_Mid &lt; *_First)
      std::iter_swap(_First, _Mid);
    }
  <b>else</b> <b>if</b> (_Count1 &lt;= _Count2 &amp;&amp; _Count1 &lt;= _Tempbuf._Maxlen())
    { <font color="#003399"><i>// buffer left partition, then merge</i></font>
    std::copy(_First, _Mid, _Tempbuf._Init());
    std::merge(_Tempbuf._First(), _Tempbuf._Last(), _Mid, _Last, _First);
    }
  <b>else</b> <b>if</b> (_Count2 &lt;= _Tempbuf._Maxlen())
    { <font color="#003399"><i>// buffer right partition, then merge</i></font>
    std::copy(_Mid, _Last, _Tempbuf._Init());
    _Merge_backward(_First, _Mid,
      _Tempbuf._First(), _Tempbuf._Last(), _Last);
    }
  <b>else</b>
    { <font color="#003399"><i>// buffer too small, divide and conquer</i></font>
    _BidIt _Firstn, _Lastn;
    _Diff _Count1n, _Count2n;

    <b>if</b> (_Count2 &lt; _Count1)
      { <font color="#003399"><i>// left larger, cut it in half and partition right to match</i></font>
      _Count1n = _Count1 / 2, _Count2n = 0;
      _Firstn = _First;
      std::advance(_Firstn, _Count1n);
      _Lastn = std::lower_bound(_Mid, _Last, *_Firstn);
      _Distance(_Mid, _Lastn, _Count2n);
      }
    <b>else</b>
      { <font color="#003399"><i>// right larger, cut it in half and partition left to match</i></font>
      _Count1n = 0, _Count2n = _Count2 / 2;
      _Lastn = _Mid;
      std::advance(_Lastn, _Count2n);
      _Firstn = std::upper_bound(_First, _Mid, *_Lastn);
      _Distance(_First, _Firstn, _Count1n);
      }

    _BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
      _Count1 - _Count1n, _Count2n, _Tempbuf);  <font color="#003399"><i>// rearrange middle</i></font>
    _Buffered_merge(_First, _Firstn, _Midn,
      _Count1n, _Count2n, _Tempbuf);  <font color="#003399"><i>// merge each new part</i></font>
    _Buffered_merge(_Midn, _Lastn, _Last,
      _Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf);
    }
  }

<b>template</b>&lt;<b>class</b> _BidIt,
  <b>class</b> _Diff,
  <b>class</b> _Ty&gt; <b>inline</b>
  <b>void</b> _Inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last,
    _Diff *, _Ty *)
  { <font color="#003399"><i>// merge [_First, _Mid) with [_Mid, _Last), using operator&lt;</i></font>
  _Diff _Count1 = 0;
  _Distance(_First, _Mid, _Count1);
  _Diff _Count2 = 0;
  _Distance(_Mid, _Last, _Count2);
  _Temp_iterator&lt;_Ty&gt; _Tempbuf(_Count1 &lt; _Count2 ? _Count1 : _Count2);
  _Buffered_merge(_First, _Mid, _Last,
    _Count1, _Count2, _Tempbuf);
  }

<b>template</b>&lt;<b>class</b> _BidIt&gt; <b>inline</b>
  <b>void</b> inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last)
  { <font color="#003399"><i>// merge [_First, _Mid) with [_Mid, _Last), using operator&lt;</i></font>
  <b>if</b> (_First != _Mid &amp;&amp; _Mid != _Last)
    _Inplace_merge(_First, _Mid, _Last,
      _Dist_type(_First), _Val_type(_First));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION inplace_merge WITH PRED</i></font>
<b>template</b>&lt;<b>class</b> _BidIt1,
  <b>class</b> _BidIt2,
  <b>class</b> _BidIt3,
  <b>class</b> _Pr&gt; <b>inline</b>
  _BidIt3 _Merge_backward(_BidIt1 _First1, _BidIt1 _Last1,
    _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred)
  { <font color="#003399"><i>// merge backwards to _Dest, using _Pred</i></font>
  <b>for</b> (; ; )
    <b>if</b> (_First1 == _Last1)
      <b>return</b> (std::copy_backward(_First2, _Last2, _Dest));
    <b>else</b> <b>if</b> (_First2 == _Last2)
      <b>return</b> (std::copy_backward(_First1, _Last1, _Dest));
    <b>else</b> <b>if</b> (_Pred(*--_Last2, *--_Last1))
      *--_Dest = *_Last1, ++_Last2;
    <b>else</b>
      *--_Dest = *_Last2, ++_Last1;
  }

<b>template</b>&lt;<b>class</b> _BidIt,
  <b>class</b> _Diff,
  <b>class</b> _Ty,
  <b>class</b> _Pr&gt; <b>inline</b>
  <b>void</b> _Buffered_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last,
    _Diff _Count1, _Diff _Count2,
      _Temp_iterator&lt;_Ty&gt;&amp; _Tempbuf, _Pr _Pred)
  { <font color="#003399"><i>// merge [_First, _Mid) with [_Mid, _Last), using _Pred</i></font>
  <b>if</b> (_Count1 + _Count2 == 2)
    { <font color="#003399"><i>// order two one-element partitions</i></font>
    <b>if</b> (_Pred(*_Mid, *_First))
      std::iter_swap(_First, _Mid);
    }
  <b>else</b> <b>if</b> (_Count1 &lt;= _Count2 &amp;&amp; _Count1 &lt;= _Tempbuf._Maxlen())
    { <font color="#003399"><i>// buffer left partition, then merge</i></font>
    std::copy(_First, _Mid, _Tempbuf._Init());
    std::merge(_Tempbuf._First(), _Tempbuf._Last(),
      _Mid, _Last, _First, _Pred);
    }
  <b>else</b> <b>if</b> (_Count2 &lt;= _Tempbuf._Maxlen())
    { <font color="#003399"><i>// buffer right partition, then merge</i></font>
    std::copy(_Mid, _Last, _Tempbuf._Init());
    _Merge_backward(_First, _Mid, _Tempbuf._First(), _Tempbuf._Last(),
      _Last, _Pred);
    }
  <b>else</b>
    { <font color="#003399"><i>// buffer too small, divide and conquer</i></font>
    _BidIt _Firstn, _Lastn;
    _Diff _Count1n, _Count2n;
    <b>if</b> (_Count2 &lt; _Count1)
      { <font color="#003399"><i>// left larger, cut it in half and partition right to match</i></font>
      _Count1n = _Count1 / 2, _Count2n = 0;
      _Firstn = _First;
      std::advance(_Firstn, _Count1n);
      _Lastn = lower_bound(_Mid, _Last, *_Firstn, _Pred);
      _Distance(_Mid, _Lastn, _Count2n);
      }
    <b>else</b>
      { <font color="#003399"><i>// right larger, cut it in half and partition left to match</i></font>
      _Count1n = 0, _Count2n = _Count2 / 2;
      _Lastn = _Mid;
      std::advance(_Lastn, _Count2n);
      _Firstn = upper_bound(_First, _Mid, *_Lastn, _Pred);
      _Distance(_First, _Firstn, _Count1n);
      }
    _BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
      _Count1 - _Count1n, _Count2n, _Tempbuf);  <font color="#003399"><i>// rearrange middle</i></font>
    _Buffered_merge(_First, _Firstn, _Midn,
      _Count1n, _Count2n, _Tempbuf, _Pred); <font color="#003399"><i>// merge each new part</i></font>
    _Buffered_merge(_Midn, _Lastn, _Last,
      _Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf, _Pred);
    }
  }

<b>template</b>&lt;<b>class</b> _BidIt,
  <b>class</b> _Diff,
  <b>class</b> _Ty,
  <b>class</b> _Pr&gt; <b>inline</b>
  <b>void</b> _Inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred,
    _Diff *, _Ty *)
  { <font color="#003399"><i>// merge [_First, _Mid) with [_Mid, _Last), using _Pred</i></font>
  _Diff _Count1 = 0;
  _Distance(_First, _Mid, _Count1);
  _Diff _Count2 = 0;
  _Distance(_Mid, _Last, _Count2);
  _Temp_iterator&lt;_Ty&gt; _Tempbuf(_Count1 &lt; _Count2 ? _Count1 : _Count2);
  _Buffered_merge(_First, _Mid, _Last,
    _Count1, _Count2, _Tempbuf, _Pred);
  }

<b>template</b>&lt;<b>class</b> _BidIt,
  <b>class</b> _Pr&gt; <b>inline</b>
  <b>void</b> inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred)
  { <font color="#003399"><i>// merge [_First, _Mid) with [_Mid, _Last), using _Pred</i></font>
  <b>if</b> (_First != _Mid &amp;&amp; _Mid != _Last)
    _Inplace_merge(_First, _Mid, _Last, _Pred,
      _Dist_type(_First), _Val_type(_First));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION sort</i></font>
<b>template</b>&lt;<b>class</b> _BidIt&gt; <b>inline</b>
  <b>void</b> _Insertion_sort(_BidIt _First, _BidIt _Last)
  { <font color="#003399"><i>// insertion sort [_First, _Last), using operator&lt;</i></font>
  <b>if</b> (_First != _Last)
    <b>for</b> (_BidIt _Next = _First; ++_Next != _Last; )
      <b>if</b> (*_Next &lt; *_First)
        { <font color="#003399"><i>// found new earliest element, rotate to front</i></font>
        _BidIt _Next1 = _Next;
        std::rotate(_First, _Next, ++_Next1);
        }
      <b>else</b>
        { <font color="#003399"><i>// look for insertion point after first</i></font>
        _BidIt _Dest = _Next;
        <b>for</b> (_BidIt _Dest0 = _Dest; *_Next &lt; *--_Dest0; )
          _Dest = _Dest0;
        <b>if</b> (_Dest != _Next)
          { <font color="#003399"><i>// rotate into place</i></font>
          _BidIt _Next1 = _Next;
          std::rotate(_Dest, _Next, ++_Next1);
          }
        }
  }

<b>template</b>&lt;<b>class</b> _RanIt&gt; <b>inline</b>
  <b>void</b> _Med3(_RanIt _First, _RanIt _Mid, _RanIt _Last)
  { <font color="#003399"><i>// sort median of three elements to middle</i></font>
  <b>if</b> (*_Mid &lt; *_First)
    std::iter_swap(_Mid, _First);
  <b>if</b> (*_Last &lt; *_Mid)
    std::iter_swap(_Last, _Mid);
  <b>if</b> (*_Mid &lt; *_First)
    std::iter_swap(_Mid, _First);
  }

<b>template</b>&lt;<b>class</b> _RanIt&gt; <b>inline</b>
  <b>void</b> _Median(_RanIt _First, _RanIt _Mid, _RanIt _Last)
  { <font color="#003399"><i>// sort median element to middle</i></font>
  <b>if</b> (40 &lt; _Last - _First)
    { <font color="#003399"><i>// median of nine</i></font>
    <b>int</b> _Step = (_Last - _First + 1) / 8;
    _Med3(_First, _First + _Step, _First + 2 * _Step);
    _Med3(_Mid - _Step, _Mid, _Mid + _Step);
    _Med3(_Last - 2 * _Step, _Last - _Step, _Last);
    _Med3(_First + _Step, _Mid, _Last - _Step);
    }
  <b>else</b>
    _Med3(_First, _Mid, _Last);
  }

<b>template</b>&lt;<b>class</b> _RanIt&gt; <b>inline</b>
  pair&lt;_RanIt, _RanIt&gt; _Unguarded_partition(_RanIt _First, _RanIt _Last)
  { <font color="#003399"><i>// partition [_First, _Last), using operator&lt;</i></font>
  _RanIt _Mid = _First + (_Last - _First) / 2;  <font color="#003399"><i>// sort median to _Mid</i></font>
  _Median(_First, _Mid, _Last - 1);
  _RanIt _Pfirst = _Mid;
  _RanIt _Plast = _Pfirst + 1;

  <b>while</b> (_First &lt; _Pfirst
    &amp;&amp; !(*(_Pfirst - 1) &lt; *_Pfirst)
    &amp;&amp; !(*_Pfirst &lt; *(_Pfirst - 1)))
    --_Pfirst;
  <b>while</b> (_Plast &lt; _Last
    &amp;&amp; !(*_Plast &lt; *_Pfirst)
    &amp;&amp; !(*_Pfirst &lt; *_Plast))
    ++_Plast;

  _RanIt _Gfirst = _Plast;
  _RanIt _Glast = _Pfirst;

  <b>for</b> (; ; )
    { <font color="#003399"><i>// partition</i></font>
    <b>for</b> (; _Gfirst &lt; _Last; ++_Gfirst)
      <b>if</b> (*_Pfirst &lt; *_Gfirst)
        ;
      <b>else</b> <b>if</b> (*_Gfirst &lt; *_Pfirst)
        <b>break</b>;
      <b>else</b>
        std::iter_swap(_Plast++, _Gfirst);
    <b>for</b> (; _First &lt; _Glast; --_Glast)
      <b>if</b> (*(_Glast - 1) &lt; *_Pfirst)
        ;
      <b>else</b> <b>if</b> (*_Pfirst &lt; *(_Glast - 1))
        <b>break</b>;
      <b>else</b>
        std::iter_swap(--_Pfirst, _Glast - 1);
    <b>if</b> (_Glast == _First &amp;&amp; _Gfirst == _Last)
      <b>return</b> (pair&lt;_RanIt, _RanIt&gt;(_Pfirst, _Plast));

    <b>if</b> (_Glast == _First)
      { <font color="#003399"><i>// no room at bottom, rotate pivot upward</i></font>
      <b>if</b> (_Plast != _Gfirst)
        std::iter_swap(_Pfirst, _Plast);
      ++_Plast;
      std::iter_swap(_Pfirst++, _Gfirst++);
      }
    <b>else</b> <b>if</b> (_Gfirst == _Last)
      { <font color="#003399"><i>// no room at top, rotate pivot downward</i></font>
      <b>if</b> (--_Glast != --_Pfirst)
        std::iter_swap(_Glast, _Pfirst);
      std::iter_swap(_Pfirst, --_Plast);
      }
    <b>else</b>
      std::iter_swap(_Gfirst++, --_Glast);
    }
  }

<b>template</b>&lt;<b>class</b> _RanIt,
  <b>class</b> _Diff&gt; <b>inline</b>
  <b>void</b> _Sort(_RanIt _First, _RanIt _Last, _Diff _Ideal)
  { <font color="#003399"><i>// order [_First, _Last), using operator&lt;</i></font>
  _Diff _Count;
  <b>for</b> (; _ISORT_MAX &lt; (_Count = _Last - _First) &amp;&amp; 0 &lt; _Ideal; )
    { <font color="#003399"><i>// divide and conquer by quicksort</i></font>
    pair&lt;_RanIt, _RanIt&gt; _Mid = _Unguarded_partition(_First, _Last);
    _Ideal /= 2, _Ideal += _Ideal / 2;  <font color="#003399"><i>// allow 1.5 log2(N) divisions</i></font>

    <b>if</b> (_Mid.first - _First &lt; _Last - _Mid.second)  <font color="#003399"><i>// loop on larger half</i></font>
      _Sort(_First, _Mid.first, _Ideal), _First = _Mid.second;
    <b>else</b>
      _Sort(_Mid.second, _Last, _Ideal), _Last = _Mid.first;
    }

  <b>if</b> (_ISORT_MAX &lt; _Count)
    { <font color="#003399"><i>// heap sort if too many divisions</i></font>
    std::make_heap(_First, _Last);
    std::sort_heap(_First, _Last);
    }
  <b>else</b> <b>if</b> (1 &lt; _Count)
    _Insertion_sort(_First, _Last); <font color="#003399"><i>// small, insertion sort</i></font>
  }

<b>template</b>&lt;<b>class</b> _RanIt&gt; <b>inline</b>
  <b>void</b> sort(_RanIt _First, _RanIt _Last)
  { <font color="#003399"><i>// order [_First, _Last), using operator&lt;</i></font>
  _Sort(_First, _Last, _Last - _First);
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION sort WITH PRED</i></font>
<b>template</b>&lt;<b>class</b> _BidIt,
  <b>class</b> _Pr&gt; <b>inline</b>
  <b>void</b> _Insertion_sort(_BidIt _First, _BidIt _Last, _Pr _Pred)
  { <font color="#003399"><i>// insertion sort [_First, _Last), using _Pred</i></font>
  <b>if</b> (_First != _Last)
    <b>for</b> (_BidIt _Next = _First; ++_Next != _Last; )
      <b>if</b> (_Pred(*_Next, *_First))
        { <font color="#003399"><i>// found new earliest element, rotate to front</i></font>
        _BidIt _Next1 = _Next;
        std::rotate(_First, _Next, ++_Next1);
        }
      <b>else</b>
        { <font color="#003399"><i>// look for insertion point after first</i></font>
        _BidIt _Dest = _Next;
        <b>for</b> (_BidIt _Dest0 = _Dest; _Pred(*_Next, *--_Dest0); )
          _Dest = _Dest0;
        <b>if</b> (_Dest != _Next)
          { <font color="#003399"><i>// rotate into place</i></font>
          _BidIt _Next1 = _Next;
          std::rotate(_Dest, _Next, ++_Next1);
          }
        }
  }

<b>template</b>&lt;<b>class</b> _RanIt,
  <b>class</b> _Pr&gt; <b>inline</b>
  <b>void</b> _Med3(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred)
  { <font color="#003399"><i>// sort median of three elements to middle</i></font>
  <b>if</b> (_Pred(*_Mid, *_First))
    std::iter_swap(_Mid, _First);
  <b>if</b> (_Pred(*_Last, *_Mid))
    std::iter_swap(_Last, _Mid);
  <b>if</b> (_Pred(*_Mid, *_First))
    std::iter_swap(_Mid, _First);
  }

<b>template</b>&lt;<b>class</b> _RanIt,
  <b>class</b> _Pr&gt; <b>inline</b>
  <b>void</b> _Median(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred)
  { <font color="#003399"><i>// sort median element to middle</i></font>
  <b>if</b> (40 &lt; _Last - _First)
    { <font color="#003399"><i>// median of nine</i></font>
    <b>int</b> _Step = (_Last - _First + 1) / 8;
    _Med3(_First, _First + _Step, _First + 2 * _Step, _Pred);
    _Med3(_Mid - _Step, _Mid, _Mid + _Step, _Pred);
    _Med3(_Last - 2 * _Step, _Last - _Step, _Last, _Pred);
    _Med3(_First + _Step, _Mid, _Last - _Step, _Pred);
    }
  <b>else</b>
    _Med3(_First, _Mid, _Last, _Pred);
  }

<b>template</b>&lt;<b>class</b> _RanIt,
  <b>class</b> _Pr&gt; <b>inline</b>
  pair&lt;_RanIt, _RanIt&gt; _Unguarded_partition(_RanIt _First, _RanIt _Last,
    _Pr _Pred)
  { <font color="#003399"><i>// partition [_First, _Last), using _Pred</i></font>
  _RanIt _Mid = _First + (_Last - _First) / 2;
  _Median(_First, _Mid, _Last - 1, _Pred);
  _RanIt _Pfirst = _Mid;
  _RanIt _Plast = _Pfirst + 1;

  <b>while</b> (_First &lt; _Pfirst
    &amp;&amp; !_Pred(*(_Pfirst - 1), *_Pfirst)
    &amp;&amp; !_Pred(*_Pfirst, *(_Pfirst - 1)))
    --_Pfirst;
  <b>while</b> (_Plast &lt; _Last
    &amp;&amp; !_Pred(*_Plast, *_Pfirst)
    &amp;&amp; !_Pred(*_Pfirst, *_Plast))
    ++_Plast;

  _RanIt _Gfirst = _Plast;
  _RanIt _Glast = _Pfirst;

  <b>for</b> (; ; )
    { <font color="#003399"><i>// partition</i></font>
    <b>for</b> (; _Gfirst &lt; _Last; ++_Gfirst)
      <b>if</b> (_Pred(*_Pfirst, *_Gfirst))
        ;
      <b>else</b> <b>if</b> (_Pred(*_Gfirst, *_Pfirst))
        <b>break</b>;
      <b>else</b>
        std::iter_swap(_Plast++, _Gfirst);
    <b>for</b> (; _First &lt; _Glast; --_Glast)
      <b>if</b> (_Pred(*(_Glast - 1), *_Pfirst))
        ;
      <b>else</b> <b>if</b> (_Pred(*_Pfirst, *(_Glast - 1)))
        <b>break</b>;
      <b>else</b>
        std::iter_swap(--_Pfirst, _Glast - 1);
    <b>if</b> (_Glast == _First &amp;&amp; _Gfirst == _Last)
      <b>return</b> (pair&lt;_RanIt, _RanIt&gt;(_Pfirst, _Plast));

    <b>if</b> (_Glast == _First)
      { <font color="#003399"><i>// no room at bottom, rotate pivot upward</i></font>
      <b>if</b> (_Plast != _Gfirst)
        std::iter_swap(_Pfirst, _Plast);
      ++_Plast;
      std::iter_swap(_Pfirst++, _Gfirst++);
      }
    <b>else</b> <b>if</b> (_Gfirst == _Last)
      { <font color="#003399"><i>// no room at top, rotate pivot downward</i></font>
      <b>if</b> (--_Glast != --_Pfirst)
        std::iter_swap(_Glast, _Pfirst);
      std::iter_swap(_Pfirst, --_Plast);
      }
    <b>else</b>
      std::iter_swap(_Gfirst++, --_Glast);
    }
  }

<b>template</b>&lt;<b>class</b> _RanIt,
  <b>class</b> _Diff,
  <b>class</b> _Pr&gt; <b>inline</b>
  <b>void</b> _Sort(_RanIt _First, _RanIt _Last, _Diff _Ideal, _Pr _Pred)
  { <font color="#003399"><i>// order [_First, _Last), using _Pred</i></font>
  _Diff _Count;
  <b>for</b> (; _ISORT_MAX &lt; (_Count = _Last - _First) &amp;&amp; 0 &lt; _Ideal; )
    { <font color="#003399"><i>// divide and conquer by quicksort</i></font>
    pair&lt;_RanIt, _RanIt&gt; _Mid =
      _Unguarded_partition(_First, _Last, _Pred);
    _Ideal /= 2, _Ideal += _Ideal / 2;  <font color="#003399"><i>// allow 1.5 log2(N) divisions</i></font>

    <b>if</b> (_Mid.first - _First &lt; _Last - _Mid.second)  <font color="#003399"><i>// loop on larger half</i></font>
      _Sort(_First, _Mid.first, _Ideal, _Pred), _First = _Mid.second;
    <b>else</b>
      _Sort(_Mid.second, _Last, _Ideal, _Pred), _Last = _Mid.first;
    }

  <b>if</b> (_ISORT_MAX &lt; _Count)
    { <font color="#003399"><i>// heap sort if too many divisions</i></font>
    std::make_heap(_First, _Last, _Pred);
    std::sort_heap(_First, _Last, _Pred);
    }
  <b>else</b> <b>if</b> (1 &lt; _Count)
    _Insertion_sort(_First, _Last, _Pred);  <font color="#003399"><i>// small, insertion sort</i></font>
  }

<b>template</b>&lt;<b>class</b> _RanIt,
  <b>class</b> _Pr&gt; <b>inline</b>
  <b>void</b> sort(_RanIt _First, _RanIt _Last, _Pr _Pred)
  { <font color="#003399"><i>// order [_First, _Last), using _Pred</i></font>
  _Sort(_First, _Last, _Last - _First, _Pred);
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION stable_sort</i></font>
<b>template</b>&lt;<b>class</b> _BidIt,
  <b>class</b> _OutIt,
  <b>class</b> _Diff&gt; <b>inline</b>
  <b>void</b> _Chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest,
    _Diff _Chunk, _Diff _Count)
  { <font color="#003399"><i>// copy merging chunks, using operator&lt;</i></font>
  <b>for</b> (_Diff _Chunk2 = _Chunk * 2; _Chunk2 &lt;= _Count; _Count -= _Chunk2)
    { <font color="#003399"><i>// copy merging pairs of adjacent chunks</i></font>
    _BidIt _Mid1 = _First;
    std::advance(_Mid1, _Chunk);
    _BidIt _Mid2 = _Mid1;
    std::advance(_Mid2, _Chunk);

    _Dest = std::merge(_First, _Mid1, _Mid1, _Mid2, _Dest);
    _First = _Mid2;
    }

  <b>if</b> (_Count &lt;= _Chunk)
    std::copy(_First, _Last, _Dest);  <font color="#003399"><i>// copy partial last chunk</i></font>
  <b>else</b>
    { <font color="#003399"><i>// copy merging whole and partial last chunk</i></font>
    _BidIt _Mid = _First;
    std::advance(_Mid, _Chunk);

    std::merge(_First, _Mid, _Mid, _Last, _Dest);
    }
  }

<b>template</b>&lt;<b>class</b> _BidIt,
  <b>class</b> _Diff,
  <b>class</b> _Ty&gt; <b>inline</b>
  <b>void</b> _Buffered_merge_sort(_BidIt _First, _BidIt _Last, _Diff _Count,
    _Temp_iterator&lt;_Ty&gt;&amp; _Tempbuf)
  { <font color="#003399"><i>// sort using temp buffer for merges, using operator&lt;</i></font>
  _BidIt _Mid = _First;
  <b>for</b> (_Diff _Nleft = _Count; _ISORT_MAX &lt;= _Nleft; _Nleft -= _ISORT_MAX)
    { <font color="#003399"><i>// sort chunks</i></font>
    _BidIt _Midend = _Mid;
    std::advance(_Midend, (<b>int</b>)_ISORT_MAX);

    _Insertion_sort(_Mid, _Midend);
    _Mid = _Midend;
    }
  _Insertion_sort(_Mid, _Last); <font color="#003399"><i>// sort partial last chunk</i></font>

  <b>for</b> (_Diff _Chunk = _ISORT_MAX; _Chunk &lt; _Count; _Chunk *= 2)
    { <font color="#003399"><i>// merge adjacent pairs of chunks to and from temp buffer</i></font>
    _Chunked_merge(_First, _Last, _Tempbuf._Init(),
      _Chunk, _Count);
    _Chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
      _Chunk *= 2, _Count);
    }
  }

<b>template</b>&lt;<b>class</b> _BidIt,
  <b>class</b> _Diff,
  <b>class</b> _Ty&gt; <b>inline</b>
  <b>void</b> _Stable_sort(_BidIt _First, _BidIt _Last, _Diff _Count,
    _Temp_iterator&lt;_Ty&gt;&amp; _Tempbuf)
  { <font color="#003399"><i>//  sort preserving order of equivalents, using operator&lt;</i></font>
  <b>if</b> (_Count &lt;= _ISORT_MAX)
    _Insertion_sort(_First, _Last); <font color="#003399"><i>// small, insertion sort</i></font>
  <b>else</b>
    { <font color="#003399"><i>// sort halves and merge</i></font>
    _Diff _Count2 = (_Count + 1) / 2;
    _BidIt _Mid = _First;
    std::advance(_Mid, _Count2);

    <b>if</b> (_Count2 &lt;= _Tempbuf._Maxlen())
      { <font color="#003399"><i>// temp buffer big enough, sort each half using buffer</i></font>
      _Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf);
      _Buffered_merge_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);
      }
    <b>else</b>
      { <font color="#003399"><i>// temp buffer not big enough, divide and conquer</i></font>
      _Stable_sort(_First, _Mid, _Count2, _Tempbuf);
      _Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);
      }

    _Buffered_merge(_First, _Mid, _Last,
      _Count2, _Count - _Count2, _Tempbuf); <font color="#003399"><i>// merge sorted halves</i></font>
    }
  }

<b>template</b>&lt;<b>class</b> _BidIt,
  <b>class</b> _Diff,
  <b>class</b> _Ty&gt; <b>inline</b>
  <b>void</b> _Stable_sort(_BidIt _First, _BidIt _Last, _Diff *, _Ty *)
  { <font color="#003399"><i>// sort preserving order of equivalents, using operator&lt;</i></font>
  _Diff _Count = 0;
  _Distance(_First, _Last, _Count);
  _Temp_iterator&lt;_Ty&gt; _Tempbuf(_Count);
  _Stable_sort(_First, _Last, _Count, _Tempbuf);
  }

<b>template</b>&lt;<b>class</b> _BidIt&gt; <b>inline</b>
  <b>void</b> stable_sort(_BidIt _First, _BidIt _Last)
  { <font color="#003399"><i>// sort preserving order of equivalents, using operator&lt;</i></font>
  <b>if</b> (_First != _Last)
    _Stable_sort(_First, _Last, _Dist_type(_First), _Val_type(_First));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION stable_sort WITH PRED</i></font>
<b>template</b>&lt;<b>class</b> _BidIt,
  <b>class</b> _OutIt,
  <b>class</b> _Diff,
  <b>class</b> _Pr&gt; <b>inline</b>
  <b>void</b> _Chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest,
    _Diff _Chunk, _Diff _Count, _Pr _Pred)
  { <font color="#003399"><i>// copy merging chunks, using _Pred</i></font>
  <b>for</b> (_Diff _Chunk2 = _Chunk * 2; _Chunk2 &lt;= _Count; _Count -= _Chunk2)
    { <font color="#003399"><i>// copy merging pairs of adjacent chunks</i></font>
    _BidIt _Mid1 = _First;
    std::advance(_Mid1, _Chunk);
    _BidIt _Mid2 = _Mid1;
    std::advance(_Mid2, _Chunk);

    _Dest = std::merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);
    _First = _Mid2;
    }

  <b>if</b> (_Count &lt;= _Chunk)
    std::copy(_First, _Last, _Dest);  <font color="#003399"><i>// copy partial last chunk</i></font>
  <b>else</b>
    { <font color="#003399"><i>// copy merging whole and partial last chunk</i></font>
    _BidIt _Mid1 = _First;
    std::advance(_Mid1, _Chunk);

    std::merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);
    }
  }

<b>template</b>&lt;<b>class</b> _BidIt,
  <b>class</b> _Diff,
  <b>class</b> _Ty,
  <b>class</b> _Pr&gt; <b>inline</b>
  <b>void</b> _Buffered_merge_sort(_BidIt _First, _BidIt _Last, _Diff _Count,
    _Temp_iterator&lt;_Ty&gt;&amp; _Tempbuf, _Pr _Pred)
  { <font color="#003399"><i>// sort using temp buffer for merges, using _Pred</i></font>
  _BidIt _Mid = _First;
  <b>for</b> (_Diff _Nleft = _Count; _ISORT_MAX &lt;= _Nleft; _Nleft -= _ISORT_MAX)
    { <font color="#003399"><i>// sort chunks</i></font>
    _BidIt _Midn = _Mid;
    std::advance(_Midn, (<b>int</b>)_ISORT_MAX);

    _Insertion_sort(_Mid, _Midn, _Pred);
    _Mid = _Midn;
    }
  _Insertion_sort(_Mid, _Last, _Pred);  <font color="#003399"><i>// sort partial last chunk</i></font>

  <b>for</b> (_Diff _Chunk = _ISORT_MAX; _Chunk &lt; _Count; _Chunk *= 2)
    { <font color="#003399"><i>// merge adjacent pairs of chunks to and from temp buffer</i></font>
    _Chunked_merge(_First, _Last, _Tempbuf._Init(),
      _Chunk, _Count, _Pred);
    _Chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
      _Chunk *= 2, _Count, _Pred);
    }
  }

<b>template</b>&lt;<b>class</b> _BidIt,
  <b>class</b> _Diff,
  <b>class</b> _Ty,
  <b>class</b> _Pr&gt; <b>inline</b>
  <b>void</b> _Stable_sort(_BidIt _First, _BidIt _Last, _Diff _Count,
    _Temp_iterator&lt;_Ty&gt;&amp; _Tempbuf, _Pr _Pred)
  { <font color="#003399"><i>// sort preserving order of equivalents, using _Pred</i></font>
  <b>if</b> (_Count &lt;= _ISORT_MAX)
    _Insertion_sort(_First, _Last, _Pred);  <font color="#003399"><i>// small, insertion sort</i></font>
  <b>else</b>
    { <font color="#003399"><i>// sort halves and merge</i></font>
    _Diff _Count2 = (_Count + 1) / 2;
    _BidIt _Mid = _First;
    std::advance(_Mid, _Count2);

    <b>if</b> (_Count2 &lt;= _Tempbuf._Maxlen())
      { <font color="#003399"><i>// temp buffer big enough, sort each half using buffer</i></font>
      _Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);
      _Buffered_merge_sort(_Mid, _Last, _Count - _Count2,
        _Tempbuf, _Pred);
      }
    <b>else</b>
      { <font color="#003399"><i>// temp buffer not big enough, divide and conquer</i></font>
      _Stable_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);
      _Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf, _Pred);
      }

    _Buffered_merge(_First, _Mid, _Last,
      _Count2, _Count - _Count2, _Tempbuf, _Pred);  <font color="#003399"><i>// merge halves</i></font>
    }
  }

<b>template</b>&lt;<b>class</b> _BidIt,
  <b>class</b> _Diff,
  <b>class</b> _Ty,
  <b>class</b> _Pr&gt; <b>inline</b>
  <b>void</b> _Stable_sort(_BidIt _First, _BidIt _Last, _Diff *, _Ty *, _Pr _Pred)
  { <font color="#003399"><i>// sort preserving order of equivalents, using _Pred</i></font>
  _Diff _Count = 0;
  _Distance(_First, _Last, _Count);
  _Temp_iterator&lt;_Ty&gt; _Tempbuf(_Count);
  _Stable_sort(_First, _Last, _Count, _Tempbuf, _Pred);
  }

<b>template</b>&lt;<b>class</b> _BidIt,
  <b>class</b> _Pr&gt; <b>inline</b>
  <b>void</b> stable_sort(_BidIt _First, _BidIt _Last, _Pr _Pred)
  { <font color="#003399"><i>// sort preserving order of equivalents, using _Pred</i></font>
  <b>if</b> (_First != _Last)
    _Stable_sort(_First, _Last,
      _Dist_type(_First), _Val_type(_First), _Pred);
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION partial_sort</i></font>
<b>template</b>&lt;<b>class</b> _RanIt,
  <b>class</b> _Ty&gt; <b>inline</b>
  <b>void</b> _Partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Ty *)
  { <font color="#003399"><i>// order [First, _Last) up to _Mid, using operator&lt;</i></font>
  std::make_heap(_First, _Mid);

  <b>for</b> (_RanIt _Next = _Mid; _Next &lt; _Last; ++_Next)
    <b>if</b> (*_Next &lt; *_First)
      _Pop_heap(_First, _Mid, _Next, _Ty(*_Next),
        _Dist_type(_First));  <font color="#003399"><i>// replace top with new largest</i></font>
  std::sort_heap(_First, _Mid);
  }

<b>template</b>&lt;<b>class</b> _RanIt&gt; <b>inline</b>
  <b>void</b> partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last)
  { <font color="#003399"><i>// order [First, _Last) up to _Mid, using operator&lt;</i></font>
  _Partial_sort(_First, _Mid, _Last, _Val_type(_First));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION partial_sort WITH PRED</i></font>
<b>template</b>&lt;<b>class</b> _RanIt,
  <b>class</b> _Ty,
  <b>class</b> _Pr&gt; <b>inline</b>
  <b>void</b> _Partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last,
    _Pr _Pred, _Ty *)
  { <font color="#003399"><i>// order [First, _Last) up to _Mid, using _Pred</i></font>
  std::make_heap(_First, _Mid, _Pred);

  <b>for</b> (_RanIt _Next = _Mid; _Next &lt; _Last; ++_Next)
    <b>if</b> (_Pred(*_Next, *_First))
      _Pop_heap(_First, _Mid, _Next, _Ty(*_Next), _Pred,
        _Dist_type(_First));  <font color="#003399"><i>// replace top with new largest</i></font>
  std::sort_heap(_First, _Mid, _Pred);
  }

<b>template</b>&lt;<b>class</b> _RanIt,
  <b>class</b> _Pr&gt; <b>inline</b>
  <b>void</b> partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred)
  { <font color="#003399"><i>// order [First, _Last) up to _Mid, using _Pred</i></font>
  _Partial_sort(_First, _Mid, _Last, _Pred, _Val_type(_First));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION partial_sort_copy</i></font>
<b>template</b>&lt;<b>class</b> _InIt,
  <b>class</b> _RanIt,
  <b>class</b> _Diff,
  <b>class</b> _Ty&gt; <b>inline</b>
  _RanIt _Partial_sort_copy(_InIt _First1, _InIt _Last1,
    _RanIt _First2, _RanIt _Last2, _Diff *, _Ty *)
  { <font color="#003399"><i>// copy [First1, _Last1) into [_First2, _Last2), using operator&lt;</i></font>
  _RanIt _Mid2 = _First2;
  <b>for</b> (; _First1 != _Last1 &amp;&amp; _Mid2 != _Last2; ++_First1, ++_Mid2)
    *_Mid2 = *_First1;  <font color="#003399"><i>// copy min(_Last1 - _First1, _Last2 - _First2)</i></font>
  std::make_heap(_First2, _Mid2);

  <b>for</b> (; _First1 != _Last1; ++_First1)
    <b>if</b> (*_First1 &lt; *_First2)
      _Adjust_heap(_First2, _Diff(0), _Diff(_Mid2 - _First2),
        _Ty(*_First1)); <font color="#003399"><i>// replace top with new largest</i></font>

  std::sort_heap(_First2, _Mid2);
  <b>return</b> (_Mid2);
  }

<b>template</b>&lt;<b>class</b> _InIt,
  <b>class</b> _RanIt&gt; <b>inline</b>
  _RanIt partial_sort_copy(_InIt _First1, _InIt _Last1,
    _RanIt _First2, _RanIt _Last2)
  { <font color="#003399"><i>// copy [First1, _Last1) into [_First2, _Last2), using operator&lt;</i></font>
  <b>return</b> (_First1 == _Last1 || _First2 == _Last2 ? _First2
    : _Partial_sort_copy(_First1, _Last1, _First2, _Last2,
      _Dist_type(_First2), _Val_type(_First1)));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION partial_sort_copy WITH PRED</i></font>
<b>template</b>&lt;<b>class</b> _InIt,
  <b>class</b> _RanIt,
  <b>class</b> _Diff,
  <b>class</b> _Ty, <b>class</b> _Pr&gt; <b>inline</b>
  _RanIt _Partial_sort_copy(_InIt _First1, _InIt _Last1,
    _RanIt _First2, _RanIt _Last2, _Pr _Pred, _Diff *, _Ty *)
  { <font color="#003399"><i>// copy [First1, _Last1) into [_First2, _Last2) using _Pred</i></font>
  _RanIt _Mid2 = _First2;
  <b>for</b> (; _First1 != _Last1 &amp;&amp; _Mid2 != _Last2; ++_First1, ++_Mid2)
    *_Mid2 = *_First1;  <font color="#003399"><i>// copy min(_Last1 - _First1, _Last2 - _First2)</i></font>
  std::make_heap(_First2, _Mid2, _Pred);

  <b>for</b> (; _First1 != _Last1; ++_First1)
    <b>if</b> (_Pred(*_First1, *_First2))
      _Adjust_heap(_First2, _Diff(0), _Diff(_Mid2 - _First2),
        _Ty(*_First1), _Pred);  <font color="#003399"><i>// replace top with new largest</i></font>

  std::sort_heap(_First2, _Mid2, _Pred);
  <b>return</b> (_Mid2);
  }

<b>template</b>&lt;<b>class</b> _InIt,
  <b>class</b> _RanIt,
  <b>class</b> _Pr&gt; <b>inline</b>
  _RanIt partial_sort_copy(_InIt _First1, _InIt _Last1,
    _RanIt _First2, _RanIt _Last2, _Pr _Pred)
  { <font color="#003399"><i>// copy [First1, _Last1) into [_First2, _Last2) using _Pred</i></font>
  <b>return</b> (_First1 == _Last1 || _First2 == _Last2 ? _First2
    : _Partial_sort_copy(_First1, _Last1, _First2, _Last2, _Pred,
      _Dist_type(_First2), _Val_type(_First1)));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION nth_element</i></font>
<b>template</b>&lt;<b>class</b> _RanIt&gt; <b>inline</b>
  <b>void</b> nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last)
  { <font color="#003399"><i>// order Nth element, using operator&lt;</i></font>
  <b>for</b> (; _ISORT_MAX &lt; _Last - _First; )
    { <font color="#003399"><i>// divide and conquer, ordering partition containing Nth</i></font>
    pair&lt;_RanIt, _RanIt&gt; _Mid =
      _Unguarded_partition(_First, _Last);

    <b>if</b> (_Mid.second &lt;= _Nth)
      _First = _Mid.second;
    <b>else</b> <b>if</b> (_Mid.first &lt;= _Nth)
      <b>return</b>; <font color="#003399"><i>// Nth inside fat pivot, done</i></font>
    <b>else</b>
      _Last = _Mid.first;
    }

  _Insertion_sort(_First, _Last); <font color="#003399"><i>// sort any remainder</i></font>
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION nth_element WITH PRED</i></font>
<b>template</b>&lt;<b>class</b> _RanIt,
  <b>class</b> _Pr&gt; <b>inline</b>
  <b>void</b> nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last, _Pr _Pred)
  { <font color="#003399"><i>// order Nth element, using _Pred</i></font>
  <b>for</b> (; _ISORT_MAX &lt; _Last - _First; )
    { <font color="#003399"><i>// divide and conquer, ordering partition containing Nth</i></font>
    pair&lt;_RanIt, _RanIt&gt; _Mid =
      _Unguarded_partition(_First, _Last, _Pred);

    <b>if</b> (_Mid.second &lt;= _Nth)
      _First = _Mid.second;
    <b>else</b> <b>if</b> (_Mid.first &lt;= _Nth)
      <b>return</b>; <font color="#003399"><i>// Nth inside fat pivot, done</i></font>
    <b>else</b>
      _Last = _Mid.first;
    }

  _Insertion_sort(_First, _Last, _Pred);  <font color="#003399"><i>// sort any remainder</i></font>
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION includes</i></font>
<b>template</b>&lt;<b>class</b> _InIt1,
  <b>class</b> _InIt2&gt; <b>inline</b>
  <b>bool</b> includes(_InIt1 _First1, _InIt1 _Last1,
    _InIt2 _First2, _InIt2 _Last2)
  { <font color="#003399"><i>// test if all [_First1, _Last1) in [_First2, _Last2), using operator&lt;</i></font>
  <b>for</b> (; _First1 != _Last1 &amp;&amp; _First2 != _Last2; )
    <b>if</b> (*_First2 &lt; *_First1)
      <b>return</b> (<b>false</b>);
    <b>else</b> <b>if</b> (*_First1 &lt; *_First2)
      ++_First1;
    <b>else</b>
      ++_First1, ++_First2;
  <b>return</b> (_First2 == _Last2);
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION includes WITH PRED</i></font>
<b>template</b>&lt;<b>class</b> _InIt1,
  <b>class</b> _InIt2,
  <b>class</b> _Pr&gt; <b>inline</b>
  <b>bool</b> includes(_InIt1 _First1, _InIt1 _Last1,
    _InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
  { <font color="#003399"><i>// test if set [_First1, _Last1) in [_First2, _Last2), using _Pred</i></font>
  <b>for</b> (; _First1 != _Last1 &amp;&amp; _First2 != _Last2; )
    <b>if</b> (_Pred(*_First2, *_First1))
      <b>return</b> (<b>false</b>);
    <b>else</b> <b>if</b> (_Pred(*_First1, *_First2))
      ++_First1;
    <b>else</b>
      ++_First1, ++_First2;
  <b>return</b> (_First2 == _Last2);
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION set_union</i></font>
<b>template</b>&lt;<b>class</b> _InIt1,
  <b>class</b> _InIt2,
  <b>class</b> _OutIt&gt; <b>inline</b>
  _OutIt set_union(_InIt1 _First1, _InIt1 _Last1,
    _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
  { <font color="#003399"><i>// OR sets [_First1, _Last1) and [_First2, _Last2), using operator&lt;</i></font>
  <b>for</b> (; _First1 != _Last1 &amp;&amp; _First2 != _Last2; )
    <b>if</b> (*_First1 &lt; *_First2)
      *_Dest++ = *_First1, ++_First1;
    <b>else</b> <b>if</b> (*_First2 &lt; *_First1)
      *_Dest++ = *_First2, ++_First2;
    <b>else</b>
      *_Dest++ = *_First1, ++_First1, ++_First2;
  _Dest = std::copy(_First1, _Last1, _Dest);
  <b>return</b> (std::copy(_First2, _Last2, _Dest));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION set_union WITH PRED</i></font>
<b>template</b>&lt;<b>class</b> _InIt1,
  <b>class</b> _InIt2,
  <b>class</b> _OutIt,
  <b>class</b> _Pr&gt; <b>inline</b>
  _OutIt set_union(_InIt1 _First1, _InIt1 _Last1,
    _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
  { <font color="#003399"><i>// OR sets [_First1, _Last1) and [_First2, _Last2), using _Pred</i></font>
  <b>for</b> (; _First1 != _Last1 &amp;&amp; _First2 != _Last2; )
    <b>if</b> (_Pred(*_First1, *_First2))
      *_Dest++ = *_First1, ++_First1;
    <b>else</b> <b>if</b> (_Pred(*_First2, *_First1))
      *_Dest++ = *_First2, ++_First2;
    <b>else</b>
      *_Dest++ = *_First1, ++_First1, ++_First2;
  _Dest = std::copy(_First1, _Last1, _Dest);
  <b>return</b> (std::copy(_First2, _Last2, _Dest));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION set_intersection</i></font>
<b>template</b>&lt;<b>class</b> _InIt1,
  <b>class</b> _InIt2,
  <b>class</b> _OutIt&gt; <b>inline</b>
  _OutIt set_intersection(_InIt1 _First1, _InIt1 _Last1,
    _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
  { <font color="#003399"><i>// AND sets [_First1, _Last1) and [_First2, _Last2), using operator&lt;</i></font>
  <b>for</b> (; _First1 != _Last1 &amp;&amp; _First2 != _Last2; )
    <b>if</b> (*_First1 &lt; *_First2)
      ++_First1;
    <b>else</b> <b>if</b> (*_First2 &lt; *_First1)
      ++_First2;
    <b>else</b>
      *_Dest++ = *_First1++, ++_First2;
  <b>return</b> (_Dest);
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION set_intersection WITH PRED</i></font>
<b>template</b>&lt;<b>class</b> _InIt1,
  <b>class</b> _InIt2,
  <b>class</b> _OutIt,
  <b>class</b> _Pr&gt; <b>inline</b>
  _OutIt set_intersection(_InIt1 _First1, _InIt1 _Last1,
    _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
  { <font color="#003399"><i>// AND sets [_First1, _Last1) and [_First2, _Last2), using _Pred</i></font>
  <b>for</b> (; _First1 != _Last1 &amp;&amp; _First2 != _Last2; )
    <b>if</b> (_Pred(*_First1, *_First2))
      ++_First1;
    <b>else</b> <b>if</b> (_Pred(*_First2, *_First1))
      ++_First2;
    <b>else</b>
      *_Dest++ = *_First1++, ++_First2;
  <b>return</b> (_Dest);
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION set_difference</i></font>
<b>template</b>&lt;<b>class</b> _InIt1,
  <b>class</b> _InIt2,
  <b>class</b> _OutIt&gt; <b>inline</b>
  _OutIt set_difference(_InIt1 _First1, _InIt1 _Last1,
    _InIt2 _First2, _InIt2 _Last2,  _OutIt _Dest)
  { <font color="#003399"><i>// take set [_First2, _Last2) from [_First1, _Last1), using operator&lt;</i></font>
  <b>for</b> (; _First1 != _Last1 &amp;&amp; _First2 != _Last2; )
    <b>if</b> (*_First1 &lt; *_First2)
      *_Dest++ = *_First1, ++_First1;
    <b>else</b> <b>if</b> (*_First2 &lt; *_First1)
      ++_First2;
    <b>else</b>
      ++_First1, ++_First2;
  <b>return</b> (std::copy(_First1, _Last1, _Dest));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION set_difference WITH PRED</i></font>
<b>template</b>&lt;<b>class</b> _InIt1,
  <b>class</b> _InIt2,
  <b>class</b> _OutIt,
  <b>class</b> _Pr&gt; <b>inline</b>
  _OutIt set_difference(_InIt1 _First1, _InIt1 _Last1,
    _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
  { <font color="#003399"><i>//  take set [_First2, _Last2) from [_First1, _Last1), using _Pred</i></font>
  <b>for</b> (; _First1 != _Last1 &amp;&amp; _First2 != _Last2; )
    <b>if</b> (_Pred(*_First1, *_First2))
      *_Dest++ = *_First1, ++_First1;
    <b>else</b> <b>if</b> (_Pred(*_First2, *_First1))
      ++_First2;
    <b>else</b>
      ++_First1, ++_First2;
  <b>return</b> (std::copy(_First1, _Last1, _Dest));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION set_symmetric_difference</i></font>
<b>template</b>&lt;<b>class</b> _InIt1,
  <b>class</b> _InIt2,
  <b>class</b> _OutIt&gt; <b>inline</b>
  _OutIt set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
    _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
  { <font color="#003399"><i>// XOR sets [_First1, _Last1) and [_First2, _Last2), using operator&lt;</i></font>
  <b>for</b> (; _First1 != _Last1 &amp;&amp; _First2 != _Last2; )
    <b>if</b> (*_First1 &lt; *_First2)
      *_Dest++ = *_First1, ++_First1;
    <b>else</b> <b>if</b> (*_First2 &lt; *_First1)
      *_Dest++ = *_First2, ++_First2;
    <b>else</b>
      ++_First1, ++_First2;
  _Dest = std::copy(_First1, _Last1, _Dest);
  <b>return</b> (std::copy(_First2, _Last2, _Dest));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION set_symmetric_difference WITH PRED</i></font>
<b>template</b>&lt;<b>class</b> _InIt1,
  <b>class</b> _InIt2,
  <b>class</b> _OutIt,
  <b>class</b> _Pr&gt; <b>inline</b>
  _OutIt set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
    _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
  { <font color="#003399"><i>// XOR sets [_First1, _Last1) and [_First2, _Last2), using _Pred</i></font>
  <b>for</b> (; _First1 != _Last1 &amp;&amp; _First2 != _Last2; )
    <b>if</b> (_Pred(*_First1, *_First2))
      *_Dest++ = *_First1, ++_First1;
    <b>else</b> <b>if</b> (_Pred(*_First2, *_First1))
      *_Dest++ = *_First2, ++_First2;
    <b>else</b>
      ++_First1, ++_First2;
  _Dest = std::copy(_First1, _Last1, _Dest);
  <b>return</b> (std::copy(_First2, _Last2, _Dest));
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION max_element</i></font>
<b>template</b>&lt;<b>class</b> _FwdIt&gt; <b>inline</b>
  _FwdIt max_element(_FwdIt _First, _FwdIt _Last)
  { <font color="#003399"><i>// find largest element, using operator&lt;</i></font>
  _FwdIt _Found = _First;
  <b>if</b> (_First != _Last)
    <b>for</b> (; ++_First != _Last; )
      <b>if</b> (*_Found &lt; *_First)
        _Found = _First;
  <b>return</b> (_Found);
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION max_element WITH PRED</i></font>
<b>template</b>&lt;<b>class</b> _FwdIt,
  <b>class</b> _Pr&gt; <b>inline</b>
  _FwdIt max_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
  { <font color="#003399"><i>// find largest element, using _Pred</i></font>
  _FwdIt _Found = _First;
  <b>if</b> (_First != _Last)
    <b>for</b> (; ++_First != _Last; )
      <b>if</b> (_Pred(*_Found, *_First))
        _Found = _First;
  <b>return</b> (_Found);
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION min_element</i></font>
<b>template</b>&lt;<b>class</b> _FwdIt&gt; <b>inline</b>
  _FwdIt min_element(_FwdIt _First, _FwdIt _Last)
  { <font color="#003399"><i>// find smallest element, using operator&lt;</i></font>
  _FwdIt _Found = _First;
  <b>if</b> (_First != _Last)
    <b>for</b> (; ++_First != _Last; )
      <b>if</b> (*_First &lt; *_Found)
        _Found = _First;
  <b>return</b> (_Found);
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION min_element WITH PRED</i></font>
<b>template</b>&lt;<b>class</b> _FwdIt,
  <b>class</b> _Pr&gt; <b>inline</b>
  _FwdIt min_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
  { <font color="#003399"><i>// find smallest element, using _Pred</i></font>
  _FwdIt _Found = _First;
  <b>if</b> (_First != _Last)
    <b>for</b> (; ++_First != _Last; )
      <b>if</b> (_Pred(*_First, *_Found))
        _Found = _First;
  <b>return</b> (_Found);
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION next_permutation</i></font>
<b>template</b>&lt;<b>class</b> _BidIt&gt; <b>inline</b>
  <b>bool</b> next_permutation(_BidIt _First, _BidIt _Last)
  { <font color="#003399"><i>// permute and test for pure ascending, using operator&lt;</i></font>
  _BidIt _Next = _Last;
  <b>if</b> (_First == _Last || _First == --_Next)
    <b>return</b> (<b>false</b>);

  <b>for</b> (; ; )
    { <font color="#003399"><i>// find rightmost element smaller than successor</i></font>
    _BidIt _Next1 = _Next;
    <b>if</b> (*--_Next &lt; *_Next1)
      { <font color="#003399"><i>// swap with rightmost element that's smaller, flip suffix</i></font>
      _BidIt _Mid = _Last;
      <b>for</b> (; !(*_Next &lt; *--_Mid); )
        ;
      std::iter_swap(_Next, _Mid);
      std::reverse(_Next1, _Last);
      <b>return</b> (true);
      }

    <b>if</b> (_Next == _First)
      { <font color="#003399"><i>// pure descending, flip all</i></font>
      std::reverse(_First, _Last);
      <b>return</b> (<b>false</b>);
      }
    }
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION next_permutation WITH PRED</i></font>
<b>template</b>&lt;<b>class</b> _BidIt,
  <b>class</b> _Pr&gt; <b>inline</b>
  <b>bool</b> next_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
  { <font color="#003399"><i>// permute and test for pure ascending, using _Pred</i></font>
  _BidIt _Next = _Last;
  <b>if</b> (_First == _Last || _First == --_Next)
    <b>return</b> (<b>false</b>);

  <b>for</b> (; ; )
    { <font color="#003399"><i>// find rightmost element smaller than successor</i></font>
    _BidIt _Next1 = _Next;
    <b>if</b> (_Pred(*--_Next, *_Next1))
      { <font color="#003399"><i>// swap with rightmost element that's smaller, flip suffix</i></font>
      _BidIt _Mid = _Last;
      <b>for</b> (; !_Pred(*_Next, *--_Mid); )
        ;
      std::iter_swap(_Next, _Mid);
      std::reverse(_Next1, _Last);
      <b>return</b> (true);
      }

    <b>if</b> (_Next == _First)
      { <font color="#003399"><i>// pure descending, flip all</i></font>
      std::reverse(_First, _Last);
      <b>return</b> (<b>false</b>);
      }
    }
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION prev_permutation</i></font>
<b>template</b>&lt;<b>class</b> _BidIt&gt; <b>inline</b>
  <b>bool</b> prev_permutation(_BidIt _First, _BidIt _Last)
  { <font color="#003399"><i>// reverse permute and test for pure descending, using operator&lt;</i></font>
  _BidIt _Next = _Last;
  <b>if</b> (_First == _Last || _First == --_Next)
    <b>return</b> (<b>false</b>);
  <b>for</b> (; ; )
    { <font color="#003399"><i>// find rightmost element not smaller than successor</i></font>
    _BidIt _Next1 = _Next;
    <b>if</b> (!(*--_Next &lt; *_Next1))
      { <font color="#003399"><i>// swap with rightmost element that's not smaller, flip suffix</i></font>
      _BidIt _Mid = _Last;
      <b>for</b> (; *_Next &lt; *--_Mid; )
        ;
      std::iter_swap(_Next, _Mid);
      std::reverse(_Next1, _Last);
      <b>return</b> (true);
      }

    <b>if</b> (_Next == _First)
      { <font color="#003399"><i>// pure ascending, flip all</i></font>
      std::reverse(_First, _Last);
      <b>return</b> (<b>false</b>);
      }
    }
  }

    <font color="#003399"><i>// TEMPLATE FUNCTION prev_permutation WITH PRED</i></font>
<b>template</b>&lt;<b>class</b> _BidIt,
  <b>class</b> _Pr&gt; <b>inline</b>
  <b>bool</b> prev_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
  { <font color="#003399"><i>// reverse permute and test for pure descending, using _Pred</i></font>
  _BidIt _Next = _Last;
  <b>if</b> (_First == _Last || _First == --_Next)
    <b>return</b> (<b>false</b>);

  <b>for</b> (; ; )
    { <font color="#003399"><i>// find rightmost element not smaller than successor</i></font>
    _BidIt _Next1 = _Next;
    <b>if</b> (!_Pred(*--_Next, *_Next1))
      { <font color="#003399"><i>// swap with rightmost element that's not smaller, flip suffix</i></font>
      _BidIt _Mid = _Last;
      <b>for</b> (; _Pred(*_Next, *--_Mid); )
        ;
      std::iter_swap(_Next, _Mid);
      std::reverse(_Next1, _Last);
      <b>return</b> (true);
      }

    <b>if</b> (_Next == _First)
      { <font color="#003399"><i>// pure ascending, flip all</i></font>
      std::reverse(_First, _Last);
      <b>return</b> (<b>false</b>);
      }
    }
  }
_STD_END

<b>pragma</b> <b>warning</b>(<b>default</b>: 4244)

<b>pragma</b> <b>warning</b>(pop)
<b>pragma</b> pack(pop)

<b>endif</b> <font color="#003399"><i>/* _ALGORITHM_ */</i></font>

<font color="#003399"><i>/*
 * Copyright (c) 1992-2002 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */</i></font>

<font color="#003399"><i>/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * &quot;as is&quot; without express or implied warranty.
 V3.13:0009 */</i></font>

</code></pre>


</body>
</html>

