<html>
<head>
<link rel="stylesheet" type="text/css" href="new.css">
<title>Function Templates</title>
</head>

<body>  
<center><h1>Function Templates</h1></center>


<!-- ************************************************************************************************ -->
<!-- ************************************************************************************************ -->
<p class="SectionHeader">Overloaded Functions (review)
</p>
Recall this problem from our discussion of functions in C++:

<blockquote>
<table border=0 cellspacing=5 cellpadding=0>
<tr><th></th><th></th></tr>
<tr valign="top">
<td>
<pre>
<b>int</b> cube(<b>int</b> n)
{
  <b>return</b> n * n * n;
}
</pre>
</td>
<td>
<blockquote><pre>
<b>int</b> i = 8;
<b>long</b> l = 50L;
<b>float</b> f = 2.5F;
<b>double</b> d = 3.14;
</pre></blockquote>
</td>
</tr></table>
</blockquote>

Output:
<blockquote><pre>
std::cout &lt;&lt; cube(i) &lt;&lt; std::endl; <font color="#003399"><i>// Works fine: 512</i></font>
std::cout &lt;&lt; cube(l) &lt;&lt; std::endl; <font color="#003399"><i>// May or may not work: 125000</i></font>
std::cout &lt;&lt; cube(f) &lt;&lt; std::endl; <font color="#003399"><i>// Not quite what we want: 8</i></font>
std::cout &lt;&lt; cube(d) &lt;&lt; std::endl; <font color="#003399"><i>// Not quite what we want: 27</i></font>
</pre></blockquote>

First attempt, "old skool" fix in C:

<blockquote>
<table border=0 cellspacing=5 cellpadding=0>
<tr><th></th><th></th></tr>
<tr valign="top">
<td>
<pre>
<b>int</b> cube_int(<b>int</b> n)
{
  <b>return</b> n * n * n;
}

<b>float</b> cube_float(<b>float</b> n)
{
  <b>return</b> n * n * n;
}
</pre>
</td>
<td>
<blockquote><pre>
<b>double</b> cube_double(<b>double</b> n)
{
  <b>return</b> n * n * n;
}

<b>long</b> cube_long(<b>long</b> n)
{
  <b>return</b> n * n * n;
}
</pre></blockquote>
</td>
</tr></table>
</blockquote>

It will work as expected:

<blockquote><pre>
std::cout &lt;&lt; cube_int(i) &lt;&lt; std::endl;    <font color="#003399"><i>// Works fine: 512</i></font>
std::cout &lt;&lt; cube_long(l) &lt;&lt; std::endl;   <font color="#003399"><i>// Works fine: 125000</i></font>
std::cout &lt;&lt; cube_float(f) &lt;&lt; std::endl;  <font color="#003399"><i>// Works fine: 15.625</i></font>
std::cout &lt;&lt; cube_double(d) &lt;&lt; std::endl; <font color="#003399"><i>// Works fine: 30.9591</i></font>
</pre></blockquote>

This quickly becomes tedious and unmanageable as we write other functions to handle other
types such as <b>unsigned int, unsigned long, char</b>, as well as user-defined types that might come along.
<p>


<p>
<hr width="90%">
<p>

Then we discovered we could "fix" the problem by <i>overloading</i> the function:
<p>

Overloaded functions:
<p>
	
<table border=0 cellspacing=5 cellpadding=5>
<tr><th></th><th></th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b>int</b> cube(<b>int</b> val)
{
 <b>return</b> val * val * val;
}
</pre></blockquote>
</td>
<td>
<blockquote><pre>
<b>long</b> cube(<b>long</b> val)
{
 <b>return</b> val * val * val;
}
</pre></blockquote>
</td>
</tr></table>

<table border=0 cellspacing=5 cellpadding=5>
<tr><th></th><th></th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b>float</b> cube(<b>float</b> val)
{
 <b>return</b> val * val * val;
}
</pre></blockquote>
</td>
<td>
<blockquote><pre>
<b>double</b> cube(<b>double</b> val)
{
 <b>return</b> val * val * val;
}
</pre></blockquote>
</td>
</tr></table>


Client usage:
<p>

<blockquote><pre>
<b>int</b> i = cube(2);           <font color="#003399"><i>// cube(int), i is 8</i></font>
<b>long</b> l = cube(100L);       <font color="#003399"><i>// cube(long), l is 1000000L</i></font>
<b>float</b> f = cube(2.5f);      <font color="#003399"><i>// cube(float), f is 15.625f</i></font>
<b>double</b> d = cube(2.34e25);  <font color="#003399"><i>// cube(double), d is 1.2812904e+76</i></font>
</pre></blockquote>


Notes:

<ul>
<li>Because the compiler can distinguish among the various parameter types, it knows which function to call.
<li>This makes it very convenient for the users: they just need to know about the <b>cube</b> function.
<li>However, this is inconvenient on the programmer who must maintain many "similar" versions of the <b>cube</b> function.</li>
<ul>
  <li>In this case, the function bodies aren't just similar, they are <i>exactly the same</i>.</li>
  <li>There's got to be a better way.</li>
</ul>
<li>It would be nice if we could specify one function that would be use for all different types.
<li>Fundamentally, we want to <i>reuse the algorithm</i>.
<ul>
<li>Instead of <i>code re-use</i>, we'd like some form of <i>algorithm</i> re-use. (Apply the same algorithm to different types.)
</ul>
<li>We can do that and the solution is <i>function templates</i>.
</ul>


<!-- ************************************************************************************************ -->
<!-- ************************************************************************************************ -->
<p class="SectionHeader">Function Templates 
</p>

Introduction:

<ul>
<li>A function template is a generic way of describing a function.
<li>You define a function in terms of a generic type instead of a specific type.
<li>This kind of programming is often referred to as <i>generic programming</i>.
<li>Templates are also called <i>parameterized types</i> because you kind of "pass a parameter" to the template
at compile time and the compiler generates the appropriate code.
</ul>


This is our new <b>cube</b> function using a template: (two new keywords are introduced here)

<blockquote><pre>
<b><font color="blue">template</font></b> &lt;<b><font color="blue">typename</font></b> T&gt; T cube(T value)
{
  <b>return</b> value * value * value;
}
</pre></blockquote>

<ul>
<li>The keyword <b>template</b> indicates that the function is a <i>template</i> function.
<li>In between the angle brackets <tt>&lt; &gt;</tt> we put in the "parameter" name using the <b>typename</b> keyword.
<li>The rest of the function is the same except that the types that were specified before (<tt><b>int, float</b></tt>, etc.)
are now replaced with the name of our parameter, in this case, T.
<li>We can use any name we want as the name of our parameter, just as with ordinary parameters. 
<ul>
  <li>The uppercase letter 'T' is a common name for the type name and it's OK (actually, preferable) to name it as such.</li>
  <li>Kind of like using the variable name <i>i</i> inside of a for loop. <i>Everyone</i> knows what it's used for.</li>
</ul>
<!--
<li>Also, the old-school keyword <b>class</b> can be used in place of the <b>typename</b> keyword. (It
should be supported by all compilers for backward compatibility.)</li>
-->
  <li>Note that template types can be user-defined types as well as built-in types.</li>
</ul>

Often, the function template is written with the <b>template</b> and <b>typename</b> keywords on a separate line above so
as to keep the function "clean" looking:

<blockquote><pre>
<b>template</b> &lt;<b>typename</b> T&gt; 
T cube(T value)
{
  <b>return</b> value * value * value;
}
</pre></blockquote>

Other notes:
<ul>
<li>The template above does <i>not</i> generate any code in the program. 
  (Kind of like how a <tt><b>struct</b></tt> or <tt><b>class</b></tt> definition doesn't until you create/instantiate one.)
<li>Code is only generated when the <b>cube</b> function is <i>actually needed</i>. (Called from some code.)
<li>This automatic code generation by the compiler is called <i>implicit template instantiation</i>.
<li>If we never call <b>cube(...)</b>, no code is generated for the function and the function doesn't exist in the executable program.
<li>However, if we do this in our program:
<blockquote><pre>
<b>int</b> i = cube(2);         
</pre></blockquote>
then code similar to this is generated for us (<i>by the compiler at compile time</i>):
<blockquote><pre>
<b>int</b> cube(<b>int</b> value)
{
  <b>return</b> value * value * value;
}
</pre></blockquote>
<li>If we do this in our program:
<blockquote><pre>
<b>int</b> i = cube(2);         
<b>long</b> l = cube(100L);     
<b>float</b> f = cube(2.5f);    
<b>double</b> d = cube(2.34e25);
</pre></blockquote>
then code similar to this is generated for us:

<p>
<table><tr><td>
<blockquote><pre>
<b>int</b> cube(<b>int</b> value)
{
  <b>return</b> value * value * value;
}

<b>long</b> cube(<b>long</b> value)
{
  <b>return</b> value * value * value;
}
</pre></blockquote>
</td>
<td>
<blockquote><pre>
<b>float</b> cube(<b>float</b> value)
{
  <b>return</b> value * value * value;
}

<b>double</b> cube(<b>double</b> value)
{
  <b>return</b> value * value * value;
}
</pre></blockquote>
</td>
</tr></table>
</ul>
Details:

<ul>
<li>A template is a way of describing to the compiler <i>how</i> to generate functions (if and when they
are needed).

<li>You need to make sure that the compiler knows about your template functions <i>before</i> you
call them. This requires you to define them before using them, much like anything else.

<li>The resulting generated executable program is not any smaller using templated functions.</li>
<ul>
  <li>In fact, the program is likely to be larger.</li>
  <li>The compiler generates (expands) all of the functions and these will be placed into the program.</li>
</ul>
<li>The compiler is just "writing" the functions for you, based on the "template"
you've given it.
<li>All of the work is done implicitly, and the generation of code by the compiler is
known as <i>implicit instantiation</i>. (As opposed to <i>explicit</i> instantiation. More 
on that later.)
</ul>

<!--
This is very different from class templates where the user <i>must</i> specify the
type of class to instantiate. We'll see that sometimes the compile can't deduce all of the types for
a function template.
-->
<p>

<!-- ************************************************************************************************ -->
<!-- ************************************************************************************************ -->
<p class="SectionHeader">Automatic Type Deduction
</p>

Note that often the compiler can deduce the types of the arguments (and hence, the type of <b>T</b>) from
the parameters. However, sometimes the compiler can't figure it out and generates an error (see below).
<p>
Let's modify the templated <b>cube</b> function to see what types are actually being passed in:

<blockquote><pre>
<b>#include</b> &lt;typeinfo&gt; <font color="#003399"><i>// typeid</i></font>

<b>template</b> &lt;<b>typename</b> T&gt; 
T cube(T value)
{
  std::cout &lt;&lt; <font color="#9933CC">&quot;cube&lt;&quot;</font> &lt;&lt; <b>typeid</b>(T).name() &lt;&lt; <font color="#9933CC">&quot;&gt;&quot;</font> &lt;&lt; std::endl;
  <b>return</b> value * value * value; 
}
</pre></blockquote>

<a href="../../docs/OperatorPrecedence-CPP.html">Operator precedence chart for C++</a>
<p>
Sample code:

<blockquote><pre>
<b>void</b> f2()
{
    <font color="#003399"><i>// Compiler deduction</i></font>
              <font color="#003399"><i>//  Microsoft       Borland        GNU/Clang</i></font>
  cube(2);    <font color="#003399"><i>// cube&lt;int&gt;      cube&lt;int&gt;      cube&lt;i&gt;</i></font>
  cube(2.0f); <font color="#003399"><i>// cube&lt;float&gt;    cube&lt;float&gt;    cube&lt;f&gt;</i></font>
  cube(2.0);  <font color="#003399"><i>// cube&lt;double&gt;   cube&lt;double&gt;   cube&lt;d&gt;</i></font>
  cube(<font color="#9933CC">'A'</font>);  <font color="#003399"><i>// cube&lt;char&gt;     cube&lt;char&gt;     cube&lt;c&gt;</i></font>

    <font color="#003399"><i>// Explicit call</i></font>
                   <font color="#003399"><i>//  Microsoft       Borland        GNU/Clang</i></font>
  cube&lt;<b>int</b>&gt;(2);    <font color="#003399"><i>// cube&lt;int&gt;      cube&lt;int&gt;      cube&lt;i&gt;</i></font>
  cube&lt;<b>double</b>&gt;(2); <font color="#003399"><i>// cube&lt;double&gt;   cube&lt;double&gt;   cube&lt;d&gt;</i></font>
  cube&lt;<b>int</b>&gt;(2.1);  <font color="#003399"><i>// cube&lt;int&gt;      cube&lt;int&gt;      cube&lt;i&gt;     (warning)</i></font>
}
</pre></blockquote>

As you can see, the actual string that is printed out is dependent on the compiler.
<p>
Of course, you can always cast the parameter to force a particular call:

<blockquote><pre>
  <font color="#003399"><i>// Casting will force it as well</i></font>
                              <font color="#003399"><i>//  Microsoft       Borland        GNU/Clang</i></font>
cube(<b>static_cast</b>&lt;<b>int</b>&gt;(2));    <font color="#003399"><i>// cube&lt;int&gt;      cube&lt;int&gt;      cube&lt;i&gt;</i></font>
cube(<b>static_cast</b>&lt;<b>double</b>&gt;(2)); <font color="#003399"><i>// cube&lt;double&gt;   cube&lt;double&gt;   cube&lt;d&gt;</i></font>
cube(<b>static_cast</b>&lt;<b>int</b>&gt;(2.1));  <font color="#003399"><i>// cube&lt;int&gt;      cube&lt;int&gt;      cube&lt;i&gt;   (no warning)</i></font>
</pre></blockquote>




<blockquote><pre>
</pre></blockquote>


<!-- ************************************************************************************************ -->
<!-- ************************************************************************************************ -->
<p class="SectionHeader">User-Defined Types in Template Functions
</p>


Templates only provide some of the necessary functionality. 
<p>
<ul>
<li>The idea behind a function template is that <i>any sensible</i> type should be able to be used.
<li>The programmer still must ensure that the generated code is valid.
<li>Most of the seemingly unintelligible errors generated from templates have nothing
to do with the functions themselves.
</ul>

<p>
Suppose we wanted to <b>cube</b> a StopWatch object:

<blockquote><pre>
StopWatch sw1(4);    <font color="#003399"><i>// Create a StopWatch set to 4 seconds</i></font>
StopWatch sw2;       <font color="#003399"><i>// Create a StopWatch set to 0 seconds</i></font>
sw2 = cube(sw1);     <font color="#003399"><i>// Cube the first StopWatch and assign to second</i></font>
cout &lt;&lt; sw2 &lt;&lt; endl; <font color="#003399"><i>// ???</i></font>
</pre></blockquote>

Will this compile? If so, what will it print out? To understand what's going on, look at what the compiler
is generating:

<blockquote><pre>
StopWatch cube(StopWatch value)
{
  <b>return</b> value * value * value;
}
</pre></blockquote>

<br><br>
Will this <b>cube</b> function compile? Why or why not? 
<p>
<br>
The answer is: it depends.
<p>
<!--<a href="StopWatch-1.h.html">StopWatch-1.h</a><br>-->
<a href="StopWatch-1.cpp.html">StopWatch-1.cpp</a><br>
<p>
<br>
If there is no overloaded <tt><b>operator*</b></tt>, the compiler will generate an error message in the template function:

<blockquote><pre>
<b>template</b> &lt;<b>typename</b> T&gt; 
T cube(T value)
{
  <b>return</b> value * value * value; <font color="#003399"><i>// no match for 'operator*' in 'value * value'</i></font>
}
</pre></blockquote>

Error from g++:
<blockquote><pre>
In instantiation of 'T cube(T) [with T = StopWatch]':
       required from here
       error: no match for 'operator*' (operand types are 'StopWatch' and 'StopWatch')
       return value * value * value;
          ~~~~~~^~~~~~~
</pre></blockquote>


We need to ensure that there is an overloaded * operator that takes a StopWatch on the left and right side of the operator:

<blockquote><pre>
StopWatch StopWatch::<b>operator</b>*(<b>const</b> StopWatch &amp;sw) <b>const</b>
{
  <b>return</b> StopWatch(seconds_ * sw.seconds_);
}
</pre></blockquote>

Now, the following will compile:

<blockquote><pre>
StopWatch sw1(4);    <font color="#003399"><i>// Create a StopWatch set to 4 seconds</i></font>
StopWatch sw2;       <font color="#003399"><i>// Create a StopWatch set to 0 seconds</i></font>
sw2 = cube(sw1);     <font color="#003399"><i>// Cube the first StopWatch and assign to second</i></font>
cout &lt;&lt; sw2 &lt;&lt; endl; <font color="#003399"><i>// Displays 00:01:04 (4 * 4 * 4 = 64 seconds)</i></font>
</pre></blockquote>

Things to realize:
<ul>
<li>There was nothing wrong with the function template for <b>cube</b>.
<li>The problem was in how it was used.
<li>It is up to the user of the functions to make sure that the objects they want to use support the required functionality.
<li>About 90% of the time, this kind of problem is encountered when using templated functions.
<li>If we add back the <tt><b>typeid</b></tt> to the <b>cube</b> function, we would see this:
<blockquote><pre>
                  <font color="#003399"><i>//     Microsoft               Borland             GNU/Clang</i></font>
sw3 = cube(sw1);  <font color="#003399"><i>// cube&lt;class StopWatch&gt;   cube&lt;StopWatch&gt;   cube&lt;9StopWatch&gt;</i></font>
</pre></blockquote>

<li>It is common for templated library functions to document what operators and methods 
  must be supported in order to use them.</li>
	
</ul>



<blockquote><pre>
</pre></blockquote>

<blockquote><pre>
</pre></blockquote>

<blockquote><pre>
</pre></blockquote>


<!-- ************************************************************************************************ -->
<!-- ************************************************************************************************ -->
<p class="SectionHeader">Multiple Template Parameters
</p>


Suppose we want a generic <i>Max</i> function:

<blockquote><pre>
<b>template</b> &lt;<b>typename</b> T&gt;
T Max(T a, T b)
{
  <b>if</b> (a &gt; b)
    <b>return</b> a;
  <b>else</b>
    <b>return</b> b;
}
</pre></blockquote>

<!--
The conditional operator is merely a conditional <i>expression</i> instead of a
conditional <i>statement</i>. The above is very similar to this:
<blockquote><pre>
<b>if</b> (a &gt; b)
  <b>return</b> a;
<b>else</b>
  <b>return</b> b;
</pre></blockquote>
-->

we try to use it like this:

<blockquote><pre>
<b>int</b> i = Max(25, 10);      <font color="#003399"><i>// i = 25</i></font>
<b>double</b> d = Max(2.5, 3.1); <font color="#003399"><i>// d = 3.1</i></font>
<b>double</b> e = Max(2.5, 4);   <font color="#003399"><i>// error: no matching function for call to 'Max(double, int)'</i></font>
</pre></blockquote>

We need to specify the type of both parameters in order to mix types:
<p>

<blockquote><pre>
<b>template</b> &lt;<b>typename</b> T1, <b>typename</b> T2&gt;
T1 Max(T1 a, T2 b)
{
  <b>if</b> (a &gt; b)
    <b>return</b> a;
  <b>else</b>
    <b>return</b> b;
}
</pre></blockquote>

This leads to:

<blockquote><pre>
<b>double</b> d1 = Max(4.5, 3); <font color="#003399"><i>// d1 = 4.5 </i></font>
<b>double</b> d2 = Max(3, 4.5); <font color="#003399"><i>// d2 = 4.0 ???  (warning: converting to 'int' from 'double')</i></font>
</pre></blockquote>

If we change the return type, it will work for the above problem:
<p>

<blockquote><pre>
<b>template</b> &lt;<b>typename</b> T1, <b>typename</b> T2&gt;
<font color="blue"><b>T2</b></font> Max(T1 a, T2 b)
{
  <b>if</b> (a &gt; b)
    <b>return</b> a;
  <b>else</b>
    <b>return</b> b;
}
</pre></blockquote>

But now this is problematic:

<blockquote><pre>
<b>int</b> i = Max(3, 4.5); <font color="#003399"><i>// i = 4 ???  (warning: converting to 'int' from 'double')</i></font>
</pre></blockquote>

Finally, add a third type:

<blockquote><pre>
<b>template</b> &lt;<b>typename</b> T1, <b>typename</b> T2, <b>typename</b> T3&gt;
T1 Max(T2 a, T3 b)
{
  <b>if</b> (a &gt; b)
    <b>return</b> a;
  <b>else</b>
    <b>return</b> b;
}
</pre></blockquote>

This leads to:

<blockquote><pre>
<b>double</b> d1 = Max(3, 4.5); <font color="#003399"><i>// error: can't deduce template argument for 'T1' </i></font>
Max(3, 4.5);             <font color="#003399"><i>// may be called this way as well (ignore return value) </i></font>
</pre></blockquote>

The errors are slightly different for each compiler:

<blockquote><pre>
GNU: no matching function for call to 'Max(int, double)'
Clang: candidate template ignored: couldn't infer template argument 'T1'
Borland: Could not find a match for 'Max<T1,T2,T3>(int,double)'
Microsoft: error 'T1 Max(T2,T3)' : could not deduce template argument for 'T1' 	
</pre></blockquote>

The simple fact is that the compiler <b>cannot deduce the return type of a function</b>. The user must specify it.
<p>
Various solutions:

<blockquote><pre>
<b>double</b> d2 = Max&lt;<b>double</b>, <b>int</b>, <b>double</b>&gt;(3, 4.5); <font color="#003399"><i>// OK, all explicit</i></font>
<b>double</b> d3 = Max&lt;<b>double</b>, <b>double</b>, <b>int</b>&gt;(4.5, 3); <font color="#003399"><i>// OK, all explicit</i></font>
<b>double</b> d4 = Max&lt;<b>double</b>&gt;(3, 4.5); <font color="#003399"><i>             // Ok, first explicit, compiler deduces others</i></font>
<b>double</b> d5 = Max&lt;<b>double</b>, <b>int</b>, <b>int</b>&gt;(4.5, 3);    <font color="#003399"><i>// OK, all explicit, but truncating (possible warning)</i></font>
<b>double</b> d6 = Max&lt;<b>int</b>, <b>double</b>, <b>int</b>&gt;(4.5, 3);    <font color="#003399"><i>// OK, all explicit, but truncating (possible warning)</i></font>
</pre></blockquote>

Suppose I made this subtle change:

<!-- The T1, T2, and T3 have been switched: no default params now -->

<blockquote><pre>
<b>template</b> &lt;<b>typename</b> T1, <b>typename</b> T2, <b>typename</b> T3&gt;
<font color="blue"><b>T3</b></font> Max(T1 a, T2 b)
{
  <b>if</b> (a &gt; b)
    <b>return</b> a;
  <b>else</b>
    <b>return</b> b;
}
</pre></blockquote>

How does that affect the code above? Other calls to <tt><b>Max</b></tt>?
<p>
So, what's the best solution? There isn't one. The STL 
(<a href="http://www.cplusplus.com/reference/algorithm/max/"><tt>std::max</tt></a>) chose to disallow
mixing types so there is no problem!
<p>
Finally, in case T is a large object, it may be more desirable to use references:

<blockquote>
<table border=0 cellspacing=1 cellpadding=10>
<tr valign="top">
<td>
<pre>
<b>template</b> &lt;<b>typename</b> T&gt;
T Max(<font color="blue"><b>const</b> T&amp;</font> a, <font color="blue"><b>const</b> T&amp;</font> b)
{
  <b>if</b> (a &gt; b)
    <b>return</b> a;
  <b>else</b>
    <b>return</b> b;
}
</pre>
</td>
<td width=20></td>
<td>
<pre>
<b>template</b> &lt;<b>typename</b> T&gt; 
T cube(<font color="blue"><b>const</b> T&amp;</font> value)
{
  <b>return</b> value * value * value;
}
</pre>
</td></tr></table>
</blockquote>
Since it may be difficult to know exactly what types will be passed to the function,
using references helps avoid the cost of passing large objects by value.
<p>



<!-- ************************************************************************************************ -->
<!-- ************************************************************************************************ -->
<p class="SectionHeader">Explicit Template Specialization
</p>


Up until now, all of our templated functions have been generated from the template. (Which was
the whole point.)
<p>
What if the code generated by the compiler didn't do what we expect? 
(It can and does happen, e.g. a compiler-generated copy constructor.)
<p>
Let's create an example:


<table border=0 cellspacing=5 cellpadding=5>
<tr><th></th><th></th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b>template</b> &lt;<b>typename</b> T&gt;
<b>bool</b> equal(T a, T b)
{
  std::cout &lt;&lt; a &lt;&lt; <font color="#9933CC">&quot; and &quot;</font> &lt;&lt; b &lt;&lt; <font color="#9933CC">&quot; are &quot;</font>;

  <b>if</b> (a == b)
    std::cout &lt;&lt; <font color="#9933CC">&quot;equal\n&quot;</font>;
  <b>else</b>
    std::cout &lt;&lt; <font color="#9933CC">&quot;not equal\n&quot;</font>;

  <b>return</b> a == b;
}
</pre></blockquote>
</td>
<td>
<blockquote><pre>
<b>void</b> f4()
{
  <b>int</b> a = 5, b = 5, c = 8;
  <b>double</b> d1 = 3.14, d2 = 5.0;

  equal(a, b);     <font color="#003399"><i>// 5 and 5 are equal</i></font>
  equal(a, c);     <font color="#003399"><i>// 5 and 8 are not equal</i></font>
  equal(a, c - 3); <font color="#003399"><i>// 5 and 5 are equal</i></font>
  equal(d1, d2);   <font color="#003399"><i>// 3.14 and 5.0 are not equal</i></font>
}
</pre></blockquote>
</td>
</tr></table>

So far, so good. The function is working as expected. 
<p>
Here's a question: What functionality (behavior) must the type <i>T</i> support in 
order for the code above to work?
<p>
<!--
copy ctor
dtor
operator<<
operator==
-->
<br>
This won't work, though:

<blockquote><pre>
equal(a, d2); <!-- <font color="#003399"><i>// g++ error: no matching function for call to 'equal(int&amp;, double&amp;)'</i></font>-->
</pre></blockquote>

Error:
<blockquote><pre>
error: no matching function for call to 'equal(int, double)'
   equal(a, d2);
                         ^
note: candidate: template<class T> T equal(T, T)
 T equal(T a, T b)
   ^
note:   template argument deduction/substitution failed:
note:   deduced conflicting types for parameter 'T' ('int' and 'double')
   equal(a, d2);
</pre></blockquote>

But, we don't care about that. (How could we make this "work" if we did care?)
<!--
cast one of the parameters to the other's type
use 2 template parameters
force the type, e.g. equal<double>(a, d2) or equal<int>(a, d2). The second one will warn.
-->

<p>
How about these:

<blockquote><pre>
<b>const</b> <b>char</b> s1[] = <font color="#9933CC">&quot;One&quot;</font>;
<b>const</b> <b>char</b> s2[] = <font color="#9933CC">&quot;One&quot;</font>;
<b>const</b> <b>char</b> s3[] = <font color="#9933CC">&quot;Two&quot;</font>;

equal(s1, s2);       <font color="#003399"><i>// One and One are not equal</i></font>
equal(s1, s3);       <font color="#003399"><i>// One and Two are not equal</i></font>
equal(s1, <font color="#9933CC">&quot;One&quot;</font>);    <font color="#003399"><i>// One and One are not equal</i></font>
equal(s1, s1);       <font color="#003399"><i>// One and One are equal</i></font>
equal(<font color="#9933CC">&quot;One&quot;</font>, <font color="#9933CC">&quot;One&quot;</font>); <font color="#003399"><i>// ???</i></font>
</pre></blockquote>

<!--
By default, Borland creates two "One" strings, so it prints "not equal". The -d switches merges them:
bcc32 -w -d main.cpp StopWatch.cpp  (now prints "equal")
-->

Why are we getting "odd" results?
<p>
	


<table border=0 cellspacing=5 cellpadding=5>
<tr><th>Template</th><th>Expansion (artist's rendering)</th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b>template</b> &lt;<b>typename</b> T&gt;
<b>bool</b> equal(T a, T b)
{  
    <font color="#003399"><i>// Compare the two</i></font>
  <b>if</b> (a == b)

    <font color="#003399"><i>// other stuff</i></font>
}
</pre></blockquote>
</td>
<td>
<blockquote><pre>

<b>bool</b> equal(<b>const char *</b> a, <b>const char *</b> b)
{  
    <font color="#003399"><i>// Compare the two</i></font>
  <b>if</b> (a == b)

    <font color="#003399"><i>// other stuff</i></font>
}
</pre></blockquote>
</td>
</tr></table>

This just won't do, so we need to take matters into our own hands.
<p>
	

<blockquote><pre>
</pre></blockquote>


<ul>
<li>If you create a version of the <b>equal</b> function "manually", the compiler will use it (if it can) before generating a template function.
<li>This "manually" created version is an <i>explicit template specialization</i>.
<li>The syntax is similar to a template function, but you preface the function with empty angle brackets instead:
<blockquote><pre>
	
<b>template</b> &lt;&gt;
<b>bool</b> equal&lt;<b>const</b> <b>char</b> *&gt;(<b>const</b> <b>char</b> *a, <b>const</b> <b>char</b> *b)
{
  std::cout &lt;&lt; a &lt;&lt; <font color="#9933CC">&quot; and &quot;</font> &lt;&lt; b &lt;&lt; <font color="#9933CC">&quot; are &quot;</font>;
  <b>bool</b> same = !strcmp(a, b);

  <b>if</b> (same)
    std::cout &lt;&lt; <font color="#9933CC">&quot;equal\n&quot;</font>;
  <b>else</b>
    std::cout &lt;&lt; <font color="#9933CC">&quot;not equal\n&quot;</font>;

  <b>return</b> same;
}
</pre></blockquote>
</ul>

Now this code will do what we expect:

<blockquote><pre>
<b>const</b> <b>char</b> s1[] = <font color="#9933CC">&quot;One&quot;</font>;
<b>const</b> <b>char</b> s2[] = <font color="#9933CC">&quot;One&quot;</font>;
<b>const</b> <b>char</b> s3[] = <font color="#9933CC">&quot;Two&quot;</font>;

  <font color="#003399"><i>// With specialization for equal</i></font>
equal(s1, s2);    <font color="#003399"><i>// One and One are equal</i></font>
equal(s1, s3);    <font color="#003399"><i>// One and Two are not equal</i></font>
equal(s1, <font color="#9933CC">&quot;One&quot;</font>); <font color="#003399"><i>// One and One are equal</i></font>
equal(s1, s1);    <font color="#003399"><i>// One and One are equal</i></font>
</pre></blockquote>


Note that the type is not strictly required in the second angle brackets, since the compiler can deduce the type from
the parameters. This:

<blockquote><pre>
<b>template</b> &lt;&gt;
<b>bool</b> equal<font color="blue"><b>&lt;<b>const</b> <b>char</b> *&gt;</b></font>(<b>const</b> <b>char</b> *a, <b>const</b> <b>char</b> *b)
</pre></blockquote>

can be changed to this:

<blockquote><pre>
<b>template</b> &lt;&gt;
<b>bool</b> equal(<b>const</b> <b>char</b> *a, <b>const</b> <b>char</b> *b)
</pre></blockquote>

However, the template and empty angle brackets must remain. If they are not there,
then this function is just a regular, non-template function.

<blockquote><pre>
</pre></blockquote>


<blockquote><pre>
</pre></blockquote>


<p>
<hr width="90%">
<p>

<p>
More details:
<p>

When the compiler must choose a function, the order of choice is: (from best to worst)
<ol>
<li>Regular functions (created by programmer)
<li>Explicit specializations (created by programmer)
<li>Template generated (generated by compiler)
</ol>

However, if you need to, you can always force the compiler to choose a particular function by 
explicitly stating which function to use.
<p>

<pre class="sourcecode"><code>
<font color="#003399"><i>// template function</i></font>
<b>template</b> &lt;<b>typename</b> T&gt; 
T cube(T value)
{
  std::cout &lt;&lt; <font color="#9933CC">&quot;Cubing a &quot;</font> &lt;&lt; <b>typeid</b>(T).name() &lt;&lt; <font color="#9933CC">&quot; (template): &quot;</font> &lt;&lt; value &lt;&lt; std::endl;
  <b>return</b> value * value * value;
}

<font color="#003399"><i>// explicit specialization cube&lt;int&gt;</i></font>
<b>template</b> &lt;&gt; 
<b>int</b> cube&lt;<b>int</b>&gt;(<b>int</b> value)
{
  std::cout &lt;&lt; <font color="#9933CC">&quot;Cubing an int (specialization): &quot;</font> &lt;&lt; value &lt;&lt; std::endl;
  <b>return</b> value * value * value;
}

<font color="#003399"><i>// regular function (non-template)</i></font>
<b>int</b> cube(<b>int</b> value)
{
  std::cout &lt;&lt; <font color="#9933CC">&quot;Cubing an int (regular): &quot;</font> &lt;&lt; value &lt;&lt; std::endl;
  <b>return</b> value * value * value;
}

<b>int</b> main()
{
  cube(5);           <font color="#003399"><i>// 1. regular</i></font>
  cube&lt;<b>double</b>&gt;(10L); <font color="#003399"><i>// 2. template, first instantion</i></font>
  cube(2.5F);        <font color="#003399"><i>// 3. template, first instantion</i></font>
  cube&lt;<b>int</b>&gt;(2.5);    <font color="#003399"><i>// 4. specialization</i></font>
  cube&lt;<b>char</b>&gt;(5);     <font color="#003399"><i>// 5. template, first instantion</i></font>
  cube(<font color="#9933CC">'A'</font>);         <font color="#003399"><i>// 6. template, no instantion (uses previous instantiation from #5)</i></font>
  <b>return</b> 0;
}
</code></pre>

<b>Output:</b> (from Microsoft's/Borland's compiler)
<blockquote><pre>
Cubing an int (regular): 5
Cubing a double (template): 10
Cubing a float (template): 2.5
Cubing an int (specialization): 2
Cubing a char (template): ???         <font color="#003399"><i>&lt;--- Why ???</i></font>
Cubing a char (template): A
</pre></blockquote>

<p>
Also note that you cannot create an explicit specialization for a function <i>after</i> an
implicit instantiation for that same function has been generated. For example, if we had this
code <i>before</i> the explicit specialization for the <tt>cube</tt> function taking an <tt><b>int</b></tt>:

<blockquote><pre>
</pre></blockquote>

<blockquote><pre>
<b>void</b> foo()
{
    <font color="#003399"><i>// implicitly instantiates cube for integers</i></font>
  <b>int</b> i = cube&lt;<b>int</b>&gt;(25); 
}
</pre></blockquote>

The explicit specialization following this will generate a compiler error along these lines:

<blockquote><pre>
specialization of T cube(T) [with T = int] after instantiation (GNU)
Template instance 'int cube<int>(int)' is already instantiated (Borland)
explicit specialization; 'T cube<int>(T)' has already been instantiated (Microsoft)
</pre></blockquote>


<p>
<hr width=80%>
<p>

Another example revisited. Given the templated <i>Max</i> function below (only one type specified):

<blockquote><pre>
<b>template</b> &lt;<b>typename</b> T&gt;
T Max(T a, T b)
{
  <b>if</b> (a &gt; b)
    <b>return</b> a;
  <b>else</b>
    <b>return</b> b;
}
</pre></blockquote>

What is printed here?

<blockquote><pre>
<b>int</b> main()
{
  cout &lt;&lt; Max(5, 2) &lt;&lt; endl;
  cout &lt;&lt; Max(4.5, 3.14) &lt;&lt; endl;
  cout &lt;&lt; Max(<font color="#9933CC">'A'</font>, <font color="#9933CC">'a'</font>) &lt;&lt; endl;
  cout &lt;&lt; Max(<font color="#9933CC">&quot;banana&quot;</font>, <font color="#9933CC">&quot;apple&quot;</font>) &lt;&lt; endl;
  <b>return</b> 0;
}
</pre></blockquote>

<b>Output:</b>

<blockquote><pre>
5
4.5
a
apple
</pre></blockquote>

The fix:

<blockquote><pre>
<font color="#003399"><i>// Explicit specialization for <b>const char *</b></i></font>
<font color="#003399"><i>// to sort lexicographically</b></i></font>
<b>template</b> &lt;&gt; 
<b>const</b> <b>char</b>* Max&lt;<b>const char *</b>&gt;(<b>const</b> <b>char</b> *a, <b>const</b> <b>char</b> *b)
{
  <b>if</b> (strcmp(a, b) >= 0)
    <b>return</b> a;
  <b>else</b>
    <b>return</b> b;
}
</pre></blockquote>

<!--
  <b>return</b> strcmp(a, b) &gt;= 0 ? a : b;
-->
<tt><b></b></tt>
<blockquote><pre>
</pre></blockquote>

<tt><b></b></tt>


<!-- ************************************************************************************************ -->
<!-- ************************************************************************************************ -->
<p class="SectionHeader">Overloaded Template Functions
</p>

Suppose we have this "universal" swap function:

<!--
<ul>
<li>Just as with overloaded functions, the compiler has elaborate rules to determine which version of a function to call or to generate.
<li>This process is called <i>overload resolution</i>.
<li>If you create a version of the function "manually", the compiler will use it (if it can) before generating a template function.
<li>This "manually" created version is <i>explicit template specialization</i>.
<li>The syntax is similar to a regular function except you preface the function with empty angle brackets:
-->


<blockquote><pre>
<b>template</b> &lt;<b>typename</b> T&gt;
<b>void</b> Swap(T &amp;a, T &amp;b)
{
  T temp = a;
  a = b;
  b = temp;
}
</pre></blockquote>

and a trivial use case:

<blockquote><pre>
<b>int</b> i = 10, j = 20;
<b>double</b> d = 3.14, e = 2.71;

Swap(i, j); <font color="#003399"><i>// i=20, j=10</i></font>
Swap(d, e); <font color="#003399"><i>// d=2.71, e=3.14</i></font>
</pre></blockquote>

What is the result of this "Swap"? 
<p>

<blockquote><pre>
<b>int</b> a[] = {1, 3, 5, 7,  9, 11};
<b>int</b> b[] = {2, 4, 6, 8, 10, 12};
Swap(a, b); <font color="#003399"><i>// ???</i></font>
</pre></blockquote>

<ul>
<li>Will this compile? 
<li>If so, what is actually swapped?
</ul>

<p>
To get an idea of what's going on, look at what the instantiated function might look like:
<p>

<blockquote><pre>
<b>void</b> Swap(<b>int</b> a[6], <b>int</b> b[6])
{
  <b>int</b> temp[6] = a; <font color="#003399"><i>// error: initializing an array with array</i></font>
  a = b;           <font color="#003399"><i>// error: assigning an array</i></font>
  b = temp;        <font color="#003399"><i>// error: assigning an array</i></font>
}
</pre></blockquote>

This produces errors because <tt><b>T</b></tt> instantiates to <tt><b>int</b>[6]</tt>: 
<p>
<b>g++</b>:

<!--
driver.cpp: In function 'void Swap(T&, T&) [with T = int[6]]':
driver.cpp:266:   instantiated from here
driver.cpp:146: error: invalid initializer
driver.cpp:147: error: ISO C++ forbids assignment of arrays
driver.cpp:148: error: ISO C++ forbids assignment of arrays

<b>Borland</b>:
Error E2034 driver.cpp 146: Cannot convert 'int *' to 'int[6]' in function void Swap<int[6]>(int ( &)[6],int ( &)[6])
Error E2277 driver.cpp 147: Lvalue required in function void Swap<int[6]>(int ( &)[6],int ( &)[6])
Error E2277 driver.cpp 148: Lvalue required in function void Swap<int[6]>(int ( &)[6],int ( &)[6])
-->

<blockquote><pre>
In instantiation of 'void Swap(T&, T&) [with T = int [6]]':
   required from here
error: array must be initialized with a brace-enclosed initializer
   T temp = a;
            ^
error: invalid array assignment
   a = b;
     ^
error: invalid array assignment
   b = temp;
     ^
</pre></blockquote>

<b>Microsoft</b>:
<blockquote><pre>
error C2075: 'temp' : array initialization needs curly braces
  see reference to function template instantiation 'void Swap<int[6]>(T (&),T (&))' being compiled
  with
  [
    T=int [6]
  ]
error C2106: '=' : left operand must be l-value
error C2106: '=' : left operand must be l-value
</pre></blockquote>

We need a function that can deal with arrays, so we overload the template:
<p>

<table><tr valign="top">
<td>
<blockquote><pre>
  <font color="#003399"><i>// original template function</i></font>
<b>template</b> &lt;<b>typename</b> T&gt;
<b>void</b> Swap(T &amp;a, T &amp;b)
{
  T temp = a;
  a = b;
  b = temp;
}
</pre></blockquote>
</td>
<td width=0></td>
<td>
<blockquote><pre>
  <font color="#003399"><i>// overloaded template function</i></font>
<b>template</b> &lt;<b>typename</b> T&gt;
<b>void</b> Swap(T &amp;a, T &amp;b, <b>int</b> size)
{
  <b>for</b> (<b>int</b> i = 0; i &lt; size; i++)
  {
    T temp = a[i];
    a[i] = b[i];
    b[i] = temp;
  }
}
</pre></blockquote>
</td>
</tr></table>

<b>Reminder:</b> This is overloading because the function name is the same, but the
parameters are different. This enables the compiler to call the correct one.
<p>
Use:
<p>

<blockquote><pre>
<b>int</b> a[] = {1, 3, 5, 7,  9, 11};
<b>int</b> b[] = {2, 4, 6, 8, 10, 12};
<b>int</b> size = <b>sizeof</b>(a) / <b>sizeof</b>(*a);

Swap(a, b, size); <font color="#003399"><i>// calls Swap(T &amp;, T &amp;, T) [with T = int]</i></font>

Display(a, size); <font color="#003399"><i>// 2, 4, 6, 8, 10, 12</i></font>
Display(b, size); <font color="#003399"><i>// 1, 3, 5, 7, 9, 11</i></font>
</pre></blockquote>

<ul>
<!--
<li>To overload, we changed the number of parameters.
-->
</ul>

In this example above, to handle C++ arrays, we need to specify the size as the third parameter.
<p>
Of course, we could have leveraged the original <i>Swap</i> function:

<blockquote><pre>
  <font color="#003399"><i>// Using the original Swap function</i></font>
<b>template</b> &lt;<b>typename</b> T&gt;
<b>void</b> Swap(T &amp;a, T &amp;b, <b>int</b> size)
{
  <b>for</b> (<b>int</b> i = 0; i &lt; size; i++)
    Swap(a[i], b[i]);
}
</pre></blockquote>

Because the two <i>Swap</i> functions have different parameters, the compiler doesn't
get confused when one function calls the other.

<!-- ************************************************************************************************ -->
<!-- ************************************************************************************************ -->
<p class="SectionHeader">Implicit vs. Explicit Instantiations
</p>


<table border=0 cellspacing=5 cellpadding=5>
<tr><th>main1.cpp</th><th>foobar1.cpp</th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b>int</b> foobar(<b>int</b> a);

<b>int</b> main()
{
  <b>int</b> x = foobar(5);

  <b>return</b> x;
}
</pre></blockquote>
</td>
<td>
<blockquote><pre>
<b>int</b> foobar(<b>int</b> a)
{
  <b>return</b> a;
}
</pre></blockquote>
</td>
</tr></table>

Compiling and linking commands:

<blockquote><pre>
g++ -c main1.cpp 
g++ -c foobar1.cpp
g++ main1.o foobar1.o
</pre></blockquote>


<p>
<hr width="80%">
<p>
	
<blockquote><pre>
</pre></blockquote>

<table border=0 cellspacing=5 cellpadding=5>
<tr><th>main2.cpp</th><th>foobar2.cpp</th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b>template</b> &lt;<b>typename</b> T&gt; T foobar(T a);

<b>int</b> main()
{
  <b>int</b> x = foobar(5);

  <b>return</b> x;
}
</pre></blockquote>
</td>
<td>
<blockquote><pre>
<b>template</b> &lt;<b>typename</b> T&gt; 
T foobar(T a)
{
  <b>return</b> a;
}
</pre></blockquote>
</td>
</tr></table>


Compiling and linking commands:

<blockquote><pre>
g++ -c main2.cpp 
g++ -c foobar2.cpp
g++ main2.o foobar2.o
</pre></blockquote>

Message:

<blockquote><pre>
main2.o:main2.cpp:(.text+0x32): undefined reference to `int foobar<int>(int)'
collect2: ld returned 1 exit status
</pre></blockquote>


<blockquote><pre>
</pre></blockquote>

<blockquote><pre>
</pre></blockquote>

Force the compiler (put this at the end of <i>foobar.cpp</i>):

<blockquote><pre>
<font color="#003399"><i>// explicit instantiation</i></font>
<b>template</b> <b>int</b> foobar&lt;<b>int</b>&gt;(<b>int</b>);
</pre></blockquote>

The fundamental problem is that the compiler needs to know how to instantiate the <i>foobar</i>
function. This means the templated function <b>MUST</b> be in the same compilation unit (i.e. file)
as the code that is calling it.
<p>
Pros and Cons of function templates.
<p>
Pros:
<ul>
  <li>The programmer only needs to write one function and the compiler will generate the rest.</li>
</ul>

Cons:
<ul>
  <li>The compiler needs to see the templated function so it can generate the function.</li>
  <ul>
    <li>This means that any function template you want to call must be in the same file as the calling function.</li>
  </ul>
  <li>Significant use of templates can impact the compiler's performance as it must generate code before compiling it.</li>
  <li>The compiler must instantiate the function template in every file that calls it!</li>
  <ul>
    <li>Compare this to non-template functions where there is exactly one copy of the function in the entire program.</li>
    <li>The compiler does some voodoo and black magic to ensure that all of these instantiated functions don't confuse the linker. (Remember the ODR rule?)</li>
  </ul>
  <li>The compiler only does partial type-checking when it sees a function template.</li>
  <ul>
    <li>It will do the rest of the type-checking later when the function template is actually instantiated.</li>
    <li>This means errors won't get noticed until sometime in the future.</li>
  </ul>
</ul>

Look at this completely bogus function (with line numbers):

<blockquote><pre>
47  <b>template</b> &lt;<b>typename</b> T&gt;
48  <b>void</b> BadSwap(T &amp;a, T &amp;b, <b>int</b> size)
49  {
50    <b>for</b> (<b>int</b> i = 0; i &lt; size; i++)
51    {
52      T temp(2, <font color="#9933CC">&quot;two&quot;</font>);
53      b[i] = temp ^ a;
54      a.foo(<font color="#9933CC">&quot;hello&quot;</font>);
55      b.bar(1, 2, 3.15);
56  
57      <b>if</b> (a % b &lt; a / b)
58        a = <font color="#9933CC">&quot;bye&quot;</font> + 7;
59    }
60  }
</pre></blockquote>

What are the requirements for <i>T</i>?
<p>

When the compiler first sees this template, it checks <i>"what ever it can"</i>. In
this example above, the compiler doesn't say anything. It can't. It has no idea
what the type of <i>T</i> is yet.
<p>

 Later, when
some other code calls it, the compiler will know what <i>T</i> is:

<blockquote><pre>
<font color="#003399"><i>// assume <b>a</b> and <b>b</b> are integer arrays as above </i></font>  
BadSwap(a, b, size);
</pre></blockquote>

This is what happens:

<blockquote><pre>
main3.cpp: In instantiation of 'void BadSwap(T&amp;, T&amp;, int) [with T = int [6]]':
main3.cpp:80:21:   required from here
main3.cpp:52:7: error: expression list treated as compound expression in initializer [-fpermissive]
     T temp(2, "two");
       ^~~~
main3.cpp:52:7: error: array must be initialized with a brace-enclosed initializer
main3.cpp:53:17: error: invalid operands of types 'int [6]' and 'int [6]' to binary 'operator^'
     b[i] = temp ^ a;
            ~~~~~^~~
main3.cpp:54:7: error: request for member 'foo' in 'a', which is of non-class type 'int [6]'
     a.foo("hello");
     ~~^~~
main3.cpp:55:7: error: request for member 'bar' in 'b', which is of non-class type 'int [6]'
     b.bar(1, 2, 3.15);
     ~~^~~
main3.cpp:57:11: error: invalid operands of types 'int [6]' and 'int [6]' to binary 'operator%'
     if (a % b &lt; a / b)
         ~~^~~
main3.cpp:57:19: error: invalid operands of types 'int [6]' and 'int [6]' to binary 'operator/'
     if (a % b &lt; a / b)
                 ~~^~~
main3.cpp:58:9: error: incompatible types in assignment of 'const char*' to 'int [6]'
       a = "bye" + 7;
       ~~^~~~~~~~~~~
</pre></blockquote>


Now, look at this equally bad version:

<blockquote><pre>
62  <b>template</b> &lt;<b>typename</b> T&gt;
63  <b>void</b> BadSwap2(T &amp;a, T &amp;b, <b>int</b> size)
64  {
65    <b>for</b> (<b>int</b> i = 0; i &lt; siz; i++)  <font color="#003399"><i>// ???</i></font>  
66    {
67      T temp(2, <font color="#9933CC">&quot;two&quot;</font>);
68      b[i] = temp ^ a;
69      a.foo(<font color="#9933CC">'hello'</font>);              <font color="#003399"><i>// ???</i></font>  
70      b.bar(1, , 3.15);            <font color="#003399"><i>// ???</i></font>  
71
72     <b>if</b> (a % b &lt; a / b)
73       a = <font color="#9933CC">&quot;bye&quot;</font> * 7;              <font color="#003399"><i>// ???</i></font>  
74   }
75   <b>retrun</b>;                         <font color="#003399"><i>// ???</i></font>  
76  }
</pre></blockquote>

This is what the compiler says when it first encounters it (before it has been instantiated):

<blockquote><pre>
main3.cpp:69:11: warning: character constant too long for its type
     a.foo('hello');
           ^~~~~~~
main3.cpp: In function 'void BadSwap2(T&, T&, int)':
main3.cpp:65:23: error: 'siz' was not declared in this scope
   for (int i = 0; i < siz; i++)
                       ^~~
main3.cpp:65:23: note: suggested alternative: 'size'
   for (int i = 0; i < siz; i++)
                       ^~~
                       size
main3.cpp:70:14: error: expected primary-expression before ',' token
     b.bar(1, , 3.15);
              ^
main3.cpp:73:17: error: invalid operands of types 'const char [4]' and 'int' to binary 'operator*'
       a = "bye" * 7;
           ~~~~~~^~~
main3.cpp:75:3: error: 'retrun' was not declared in this scope
   retrun;
   ^~~~~~
main3.cpp:75:3: note: suggested alternative: 'setbuf'
   retrun;
   ^~~~~~
   setbuf
</pre></blockquote>



Still, even with all of these cons, function templates abound in the STL, are extremely useful
and common, and are used by many C++ programmers every day.





<blockquote><pre>
</pre></blockquote>

<blockquote><pre>
</pre></blockquote>


<blockquote><pre>
</pre></blockquote>



</body>
</html>


<blockquote><pre>
</pre></blockquote>


<tt><b></b></tt>
<tt><b></b></tt>
<tt><b></b></tt>

<blockquote>
<table border=0 cellspacing=5 cellpadding=0>
<tr><th></th><th></th><th></th></tr>
<tr valign="top">
<td>
<blockquote><pre>
</pre></blockquote>
</td>
<td>
<blockquote><pre>
</pre></blockquote>
</td>
<td>
<blockquote><pre>
</pre></blockquote>
</td>
</tr></table>
</blockquote>

<tt><b></b></tt>

<blockquote>
<table border=0 cellspacing=5 cellpadding=5>
<tr><th></th><th></th></tr>
<tr valign="top">
<td>
<blockquote><pre>
</pre></blockquote>
</td>
<td>
<blockquote><pre>
</pre></blockquote>
</td>
</tr></table>
</blockquote>

<blockquote><pre>
</pre></blockquote>


