<html>
<head>
<link rel="stylesheet" type="text/css" href="new.css">
<title>Processes</title>

</head>

<body>  

<center><h1>
Processes
</h1></center>

<!--
*****************************************************************************************
*****************************************************************************************
*****************************************************************************************
-->
<p class="sectionheader">
Overview
</p>

<b>Terminology</b>

<ul>
	<li><b>Program</b> - code that can be executed.</li>
	<ul>
	<li>A program is a <i>passive</i> entity and generally exists as a file on the disk.</li>
</ul>
  <li><b>Process</b> - a program (either user mode or kernel mode) that is being executed.</li>
  <ul>
  	<li>A process	is an <i>active</i> entity and usually resides in memory.</li>
  </ul>
  <li><b>Process state</b> - Each process has information associated with it such as opened files,
  	registers in use, memory allocated, duration of execution, etc.</li>
  <li><b>Process states</b> - new, ready, running, blocked, terminated.</li>
  <li><b>Thread</b> - A subprocess or lightweight process. A process contains one or more threads.</li>
  <li><b>CPU burst</b> - A period of uninterrupted CPU activity.</li>
  <li><b>I/O burst</b> - A period of waiting for I/O to complete.</li>
  <li><b>Single tasking OS</b> - An OS that has one process in memory at once.</li>
  <li><b>Multi-tasking OS</b> - An OS that has more than one process in memory at the same time.</li>
  <li><b>Parallelism</b> - The ability to execute more than one process at the same time. Must have
  	multiple CPUs or multiple cores.</li>
  <li><b>Pseudo-parallelism</b> - The ability for a single-CPU/single-core machine to give the 
  illusion of executing more than one process/thread simultaneously.</li>
  <p>
  <a NAME=PARALLELISM>
	<li>Diagrams showing parallelism vs. pseudo-parallelism</li>
	<ul>
	  <li>The <font color="red"><b>RED LINE</b></font> represents the time to switch between processes:</li>
	</ul>
  
<blockquote>
<table border=0 cellspacing=0 cellpadding=0>
<tr valign="top"><th>No parallelism</th><th></th><th>Pseudo-parallelism</tr>
<tr valign="top">
<td>
<img src="NoParallelism.png">
</td>
<td width=30></td>
<td>
<img src="PseudoParallelism.png">
</td>
</tr></table>
</blockquote>

<blockquote>
<table border=0 cellspacing=0 cellpadding=0>
<tr valign="top"><th>Pseudo-parallelism (detail)</th></tr>
<tr valign="top">
<td>
<img src="PseudoParallelism-2.png">
</td>
</tr></table>
</blockquote>
<p>
</a>	

<blockquote>
<table border=0 cellspacing=0 cellpadding=0>
<tr valign="top" align="left"><th>Parallelism</th></tr>
<tr valign="top">
<td>
<img src="Parallelism.png">
</td>
</tr></table>
</blockquote>
<p>


How long does it take for each process to finish? How about all processes?

  
</ul>


<br />
	
<b>Process States</b>
<p>
There are several states in which a process can be. They are mutually-exclusive, so a process can
only be in exactly one of these states at any given time:

<ul>
	<li><b>New (Created)</b> - The process is being created. (A process is essentially a data structure.)</li>
  <li><b>Ready</b> - The process is in the ready (runnable) queue and is waiting to run on the CPU. (Short-lived or long-lived, depending on system load.)</li>
	<li><b>Running</b> - The process is actively using the CPU and other resources. (Generally very short-lived.)</li>
	<li><b>Blocked</b> - The process is currently waiting (paused) for some I/O to complete or an event 
		to happen. (Generally long-lived.)</li>
	<li><b>Terminated</b> - The process has been terminated, either because it has finished its task or 
		because	the system (or user) has terminated it. (Could be short-lived or very long-lived.)</li>
</ul>


<blockquote>
<img src="ProcessStates-1.png">
</blockquote>

<b>State Transitions</b>
<p>
<ol>
	<li><b>(Admitted)</b> The process has been created and is now being put into the ready/runnable queue.</li>
	<li><b>(Dispatched)</b> The OS has selected a process to run and is executing it on the CPU.</li>
	<li><b>(Timeout)</b> The process has used up its allotted time slice and is put back in the queue for later execution.</li>
	<ul>
		<li>The process may still have time remaining in its time slice, but a higher-priority process has bumped it.</li>
	</ul>
	<li><b>(Need I/O or event to happen</b>) The process has requested I/O or has requested to wait until a future event.</li>
	<li><b>(I/O done or event occurred)</b> The I/O has completed or event has occurred that the process was waiting on.
		The process gets put back in the queue.</li>
	<li><b>(Ending)</b> The process has completed its task or the system has terminated the process.</li>
</ol>

<p>
Utilities like <span id=wpurl><a class=wplabel>ps</a></span><a class=wplink href="http://en.wikipedia.org/wiki/Ps_(Unix)">ps</a>, 
<a href="http://man7.org/linux/man-pages/man1/pstree.1.html">pstree</a>, 
<a href="http://man7.org/linux/man-pages/man1/top.1.html">top</a>, <a href="http://htop.sourceforge.net/">htop</a> (on Linux, with GUIs
<a href="http://userbase.kde.org/KSysGuard">ksysguard</a>, <a href="http://help.gnome.org/users/gnome-system-monitor/">gnome-system-monitor</a>) and 
<span id=wpurl><a class=wplabel>Task Manager</a></span><a class=wplink href="http://en.wikipedia.org/wiki/Windows_Task_Manager">Task Manager</a> and 
<a href="http://technet.microsoft.com/en-us/sysinternals/bb896653">Process Explorer</a> (on Windows) can give you lots of detailed information
about all of the processes on a computer.
<p>
	
From the <a href="http://man7.org/linux/man-pages/man1/ps.1.html">ps man page</a> on Linux:
<blockquote><pre>
<b>PROCESS STATE CODES</b>

 Here are the different values that the s, stat and state output specifiers (header "STAT" or "S") will 
 display to describe the state of a process.
       D    Uninterruptible sleep (usually IO)
       R    Running or runnable (on run queue)
       S    Interruptible sleep (waiting for an event to complete)
       T    Stopped, either by a job control signal or because it is being traced.
       W    paging (not valid since the 2.6.xx kernel)
       X    dead (should never be seen)
       Z    Defunct ("zombie") process, terminated but not reaped by its parent.

       For BSD formats and when the stat keyword is used, additional characters may be displayed:
       <    high-priority (not nice to other users)
       N    low-priority (nice to other users)
       L    has pages locked into memory (for real-time and custom IO)
       s    is a session leader
       l    is multi-threaded (using CLONE_THREAD, like NPTL pthreads do)
       +    is in the foreground process group
</pre></blockquote>

<a href="ps-output1.txt">Sample output</a> running: <tt>ps aux</tt> in a virtual machine.
Try running <tt>ps -o pid,comm,stat,psr,time</tt> in a console.

<p><hr width="90%"><p>

<b>Process Control Block (PCB)</b>
<p>
Each process has a block of memory (typically a C struct) that contains all of the relevant information
about a process. The PCB can contain a massive amount of information. Some of the info includes:
<ul>
	<li><b>Process state</b> - Created, Ready, Running, Blocked, Terminated.</li>
	<li><b>Program counter</b> - Where to resume the process when it is running again.</li>
	<li><b>CPU registers</b> - (including instruction pointer) Must remember these to reload later.</li>
	<li><b>Open files</b> - Any files or other I/O that are opened are listed in the PCB.</li>
	<li><b>Scheduling info</b>  - Priority, time elapsed, etc.</li>
	<li>Lots of other stuff...</li>
</ul>

<p>
<a href="task_struct-linux.html">Linux task_struct</a>
<p>


<p>
The PCBs are kept on a linked-list structure that represents a queue for various devices (CPU, disk, etc.)


<blockquote>
<table border=0>
	<tr><td><img src="Figure3-6-ready-queue.png"></td></tr>
	<tr><td align="right"><span class="attrib">Operating System Concepts - 8th Edition Silberschatz, Galvin, Gagne &copy;2009&nbsp;&nbsp;</span></td></tr>
</table>
</blockquote>


<!--
*****************************************************************************************
*****************************************************************************************
*****************************************************************************************
-->
<p class="sectionheader">
Process Scheduling
</p>

<ul>
	<li>The OS must schedule processes (jobs) for execution</li>
	<ul>
		<li>User processes</li>
		<li>System processes</li>
	</ul>
	<li>Scheduling constraints</li>
	<ul>
		<li>Waiting time: jobs should be started quickly when they're ready</li>
		<li>CPU utilization: keep the CPU busy</li>
		<li>Response time: jobs should provide feedback quickly</li>
		<li>Turnaround time: jobs should to be completed in a timely manner</li>
		<li>Prioritization: certain tasks might be more important than others</li>
	</ul>
</ul>

<b>Types of Scheduling</b>

<ul>
	<li>Queueing (<i>non-preemptive</i> scheduling)</li>
	<ul>
		<li>Jobs are placed on a queue for sequential execution.</li>
		<li>Two type of queues used</li>
		<ul>
			<li>First In, First Out (FIFO) queue</li>
			<li>Shortest Job First (SJF) queue</li>
		</ul>
		<li>Used for batch jobs (such as printing).</li>
	</ul>
	<li><span id=wpurl><a class=wplabel>Round-Robin</a></span><a class=wplink href="http://en.wikipedia.org/wiki/Round-robin_scheduling">Round-Robin</a> 
		(<i><span id=wpurl><a class=wplabel>preemptive</a></span><a class=wplink href="http://en.wikipedia.org/wiki/Non-preemptive_multitasking#Preemptive_multitasking.2Ftime-sharing">preemptive</a></i> scheduling).</li>
	<ul>
		<li>Each process is given a (short, a few milliseconds) time slice.</li>
		<li>A process executes only for that time slice.</li>
		<li>After the time slice is over, the next process gets a turn.</li>
	</ul>
	<li>We will look at scheduling algorithms in more detail later.</li>
</ul>

<!--
http://msdn.microsoft.com/en-us/library/ms685100(v=vs.85).aspx
-->

<b>Context Switching</b>
<ul>
<li>A <span id=wpurl><a class=wplabel>context switch</a></span><a class=wplink href="http://en.wikipedia.org/wiki/Context_switch">context switch</a> is when the OS switches between processes.</li>
<li>In round robin scheduling, the OS must switch often between processes.
(<a href="Processes-1.html#PARALLELISM">Overhead</a>)</li>
<ul>
	<li>Process's information is read in from its PCB</li>
	<li>Timer is reset</li>
	<li>Execution of that process (re)starts</li>
	<li>If process terminates before timer expires:</li>
	<ul>
		<li>Remove the PCB from the list of scheduled jobs</li>
	</ul>
	<li>Otherwise:</li>
	<ul>
		<li>After a process's time slice is up (timer expires), the current process's information is saved in a PCB</li>
		<li>Process is put back into the ready queue</li>
	</ul>
	<li>Go to next process in list</li>
	<li>Repeat ad infinitum	</li>
</ul>
</ul>

<!--
*****************************************************************************************
*****************************************************************************************
*****************************************************************************************
-->
<p class="sectionheader">
Process Creation
</p>

<b>Process Creation</b>

<ul>
<li>To execute a program:</li>
	<ul>
		<li>A PCB is created</li>
		<li>A unique process ID (PID) is assigned</li>
		<li>A process priority is assigned</li>
		<li><b>Optional:</b> New program is loaded from disk to memory</li>
		<ul>
			<li>May just continue to run the same program in new process.</li>
		</ul>
		<li>Process placed in the run queue</li>
	</ul>
	<li>An existing process creates a new process</li>
	<ul>
		<li>Parent: existing process</li>
		<li>Child: newly-created process</li>
	</ul>
<li>A child process can also create one or more processes (the child becomes the parent of these new processes)</li>
<ul>
	<li>Technically, all processes except the <b>init</b> process are child processes.</li>
</ul>
</ul>

<b>The POSIX fork Function</b>
<ul>
	<li>The <span id=wpurl><a class=wplabel>fork</a></span><a class=wplink href="http://en.wikipedia.org/wiki/Fork_(operating_system)">fork</a> function splits the flow of execution into two paths.</li>
	<ul>
		<li>Parent process</li>
		<li>Child process</li>
	</ul>
	<li>The return value from the function depends on the process.</li>
	<ul>
		<li>0, if the process is the child process</li>
		<li>PID of the child, if the process is the parent process</li>
		<li>-1, on failure (<b>ALWAYS</b> be prepared to deal with this situation.)</li>
	</ul>
	<li>The child must call the exit system call (either directly or indirectly) when it finishes 
		execution.</li>
	<li>The parent typically uses a wait function to wait until the child terminates.</li>

<p>
<b><tt>fork</tt> Example</b> (<tt>fork.c</tt>)

<pre class="sourcecode"><code><font color="990099">#include &lt;stdio.h&gt;    /* printf              */</font>
<font color="990099">#include &lt;stdlib.h&gt;   /* exit                */</font>
<font color="990099">#include &lt;unistd.h&gt;   /* fork, getpid, sleep */</font>
<font color="990099">#include &lt;sys/wait.h&gt; /* wait                */</font>

<b>int</b> main(<b>void</b>) 
{
  <b>int</b> i, pid;
  pid = <font color="blue"><b><a href="http://man7.org/linux/man-pages/man2/getpid.2.html">getpid</a></b></font>();</b></font>
  printf(<font color="#9933CC">&quot;parent pid = %d&#92;n&quot;</font>, pid);
  
  pid = <font color="blue"><b><a href="http://man7.org/linux/man-pages/man2/fork.2.html">fork</a></b>()</font>;
  <b>if</b> (pid == 0) <font color="#003399"><i>/* child process is always 0 */</i></font>
  {
    <b>for</b> (i = 0; i &lt; 10; i++) 
    {
      printf(<font color="#9933CC">&quot;child process: %d&#92;n&quot;</font>,i);
      sleep(1); 
    }
    printf(<font color="#9933CC">&quot;child exiting&#92;n&quot;</font>);
    exit(0);
  }
  <b>else</b> <font color="#003399"><i>/* parent process is non-zero (child's pid) */</i></font>
  { 
    printf(<font color="#9933CC">&quot;child pid = %d&#92;n&quot;</font>, pid);
    printf(<font color="#9933CC">&quot;waiting for child&#92;n&quot;</font>);
    <font color="blue"><b><a href="http://man7.org/linux/man-pages/man2/wait.2.html">wait</a></b></font>(NULL)</b></font>;
    printf(<font color="#9933CC">&quot;child terminated&#92;n&quot;</font>); 
  }
  printf(<font color="#9933CC">&quot;parent exiting&#92;n&quot;</font>);
  
  <b>return</b> 0;
}
</code></pre>
<p>
Running the program 3 times. The child's output is in <font color="red">red</font>:

<blockquote>
<table border=0 cellpadding=0 cellspacing=5>
<tr align="left"><th>Output 1</th><th></th><th>Output 2</th><th></th><th>Output 3</th></tr>
<tr valign="top">
<td>
<pre>
parent pid = 464
child pid = 3688
<font color="red">child process: 0</font>
waiting for child
<font color="red">child process: 1
child process: 2
child process: 3
child process: 4
child process: 5
child process: 6
child process: 7
child process: 8
child process: 9
child exiting</font>
child terminated
parent exiting
</pre>
</td>
<td width=40></td>
<td>
<pre>
parent pid = 3936
child pid = 2756
waiting for child
<font color="red">child process: 0
child process: 1
child process: 2
child process: 3
child process: 4
child process: 5
child process: 6
child process: 7
child process: 8
child process: 9
child exiting</font>
child terminated
parent exiting	
</pre>
</td>
<td width=40></td>
<td>
<pre>
parent pid = 2180
child pid = 212
waiting for child
<font color="red">child process: 0
child process: 1
child process: 2
child process: 3
child process: 4
child process: 5
child process: 6
child process: 7
child process: 8
child process: 9
child exiting</font>
child terminated
parent exiting
</pre>
</td>
</tr></table>
</blockquote>
<p>

<p class="technote">
<b>In normal, production code (read: homework assignments), you will want to handle failures
(which are not uncommon):</b>
</p>

<pre class="sourcecode"><code>
pid = fork();
<b>if</b> (pid == 0) <font color="#003399"><i>/* child process is always 0 */</i></font>
{
  <font color="#003399"><i>/* do child stuff */</i></font>
}
<b>else</b> <b>if</b> (pid &gt; 0) <font color="#003399"><i>/* parent process is non-zero (child's pid) */</i></font>
{
  <font color="#003399"><i>/* do parent stuff */</i></font>
}
<b>else</b> <font color="#003399"><i>/* fork failed, pid is -1 */</i></font>
{
  <font color="#003399"><i>/* handle error */</i></font>
}
</code></pre>

<li>It's important to realize that nothing is shared between the parent and child after the <tt><b>fork</b></tt> call: (<tt>fork3.c</tt>)


<pre class="sourcecode"><code>
<b>#include</b> &lt;stdio.h&gt;    <font color="#003399"><i>/* printf              */</i></font>
<b>#include</b> &lt;stdlib.h&gt;   <font color="#003399"><i>/* exit                */</i></font>
<b>#include</b> &lt;string.h&gt;   <font color="#003399"><i>/* strcpy              */</i></font>
<b>#include</b> &lt;unistd.h&gt;   <font color="#003399"><i>/* fork, getpid, sleep */</i></font>
<b>#include</b> &lt;sys/wait.h&gt; <font color="#003399"><i>/* wait                */</i></font>

<b>int</b> main(<b>void</b>) 
{
  <b>int</b> pid;
  <b>char</b> buffer[100] = <font color="#9933CC">&quot;Shared data&quot;</font>;

  pid = getpid();
  printf(<font color="#9933CC">&quot;parent: pid = %d\n&quot;</font>, pid);
  
  pid = fork();
  
  <b>if</b> (pid == 0) <font color="#003399"><i>/* child process is always 0 */</i></font>
  {
    printf(<font color="#9933CC">&quot;child: buffer is %s\n&quot;</font>, buffer); 
    strcpy(buffer, <font color="#9933CC">&quot;Child data&quot;</font>);
    printf(<font color="#9933CC">&quot;child: buffer is %s\n&quot;</font>, buffer);
    printf(<font color="#9933CC">&quot;child: child exiting\n&quot;</font>);
    exit(0);
  }
  <b>else</b> <font color="#003399"><i>/* parent process is non-zero (child's pid) */</i></font>
  { 
    sleep(1);
    printf(<font color="#9933CC">&quot;parent: child pid = %d\n&quot;</font>, pid);
    printf(<font color="#9933CC">&quot;parent: waiting for child\n&quot;</font>);
    wait(NULL);
    printf(<font color="#9933CC">&quot;parent: child terminated\n&quot;</font>); 
    printf(<font color="#9933CC">&quot;parent: buffer is %s\n&quot;</font>, buffer); 
  }
  printf(<font color="#9933CC">&quot;parent: parent exiting\n&quot;</font>);
  
  <b>return</b> 0;
}
</code></pre>

<blockquote>
<b>Output:</b>
<pre>parent: pid = 1396
<font color="red">child: buffer is Shared data
child: buffer is Child data
child: child exiting</font>
parent: child pid = 936
parent: waiting for child
parent: child terminated
parent: buffer is Shared data
parent: parent exiting
</pre>
</blockquote>

<li>Retrieving the exit code from the child: (<tt>fork-status.c</tt>)</li>

<pre class="sourcecode"><code><b>#include</b> &lt;stdio.h&gt;    <font color="#003399"><i>/* printf         */</i></font>
<b>#include</b> &lt;stdlib.h&gt;   <font color="#003399"><i>/* exit           */</i></font>
<b>#include</b> &lt;unistd.h&gt;   <font color="#003399"><i>/* fork, getpid   */</i></font>
<b>#include</b> &lt;sys/wait.h&gt; <font color="#003399"><i>/* wait           */</i></font>

<b>int</b> main(<b>void</b>) 
{
  <b>int</b> pid;
  
  pid = <a href="http://man7.org/linux/man-pages/man2/fork.2.html">fork</a>();
  
  <b>if</b> (pid == 0) <font color="#003399"><i>/* child */</i></font>
  {
    exit(123);  <font color="#003399"><i>/* same as <b>return</b> 123; */</i></font>
  }
  <b>else</b> <font color="#003399"><i>/* parent */</i></font>
  { 
    <b>int</b> status;

    <a href="http://man7.org/linux/man-pages/man2/wait.2.html">wait</a>(&amp;status);
    
    <b>if</b> (WIFEXITED(status))
    {
      <b>int</b> code = WEXITSTATUS(status); <font color="#003399"><i>/* extract low 8 bits */</i></font>
      printf(<font color="#9933CC">&quot;child terminated with value %i\n&quot;</font>, code); 
    }
  }
  
  <b>return</b> 0;
}
</code></pre>

<blockquote>
<b>Output:</b>
<pre>
child terminated with value 123
</pre>
</blockquote>
Note that the only values you can return to the parent this way are 0 to 255 (an <tt>unsigned char</tt>)
and you must use the macro <tt>WIFEXITED</tt> to check first.
<p>

<li>Abnormal child exit: (<tt>fork-status2.c</tt>) Don't compile with optimizations.</li>


<pre class="sourcecode"><code><font color="#003399"><i>/* DO NOT compile with optimizations enabled! */</i></font>

<font color="990099">#include &lt;stdio.h&gt;    /* printf, stdout */</font>
<font color="990099">#include &lt;stdlib.h&gt;   /* exit           */</font>
<font color="990099">#include &lt;unistd.h&gt;   /* fork, getpid   */</font>
<font color="990099">#include &lt;sys/wait.h&gt; /* wait           */</font>

<b>int</b> main(<b>void</b>)
{
  <b>int</b> pid;

  pid = fork();
  <b>if</b> (pid == 0) <font color="#003399"><i>/* child */</i></font>
  {
    <b>int</b> x; <!-- <font color="#003399"><i>/* Unused if comments are left in below (optimized away in any case) */</i></font>-->
    printf(<font color="#9933CC">&quot;child pid: %i&#92;n&quot;</font>, getpid());
    
    sleep(10); <font color="#003399"><i>/* give user a chance to send a signal    */</i></font>

      <font color="#003399"><i>/* Uncomment one of these to see what happens */</i></font>
    <font color="#003399"><i>//x = 3 / pid;           /* SIGFPE, divide by zero                 */</i></font>
    <font color="#003399"><i>//abort();               /* SIGABRT, abort the program             */</i></font>
    <font color="#003399"><i>//x = *(int *)0xFFFFFFF; /* SIGSEGV, dereference arbitrary address */</i></font>

    exit(123); <font color="#003399"><i>/* normal exit, code retrieved by parent */</i></font>
  }
  <b>else</b> <font color="#003399"><i>/* parent */</i></font>
  {
    <b>int</b> exit_code;
    <b>int</b> status;

    wait(&amp;status);
    printf(<font color="#9933CC">&quot;child terminated with value %08X, %i&#92;n&quot;</font>, status, status); <font color="#003399"><i>/* raw value */</i></font>

    exit_code = WEXITSTATUS(status); <font color="#003399"><i>/* extract exit code */</i></font>

    <b>if</b> (WIFEXITED(status)) <font color="#003399"><i>/* normal exit */</i></font>
      printf(<font color="#9933CC">&quot;child terminated normally with exit code %i&#92;n&quot;</font>, exit_code);
    <b>else</b> <font color="#003399"><i>/* abnormal exit */</i></font>
      printf(<font color="#9933CC">&quot;child terminated abnormally, code: %i&#92;n&quot;</font>, exit_code);
  }

  <b>return</b> 0;
}
</code></pre>

<b>Output: (normal exit)</b>
<blockquote><pre>
child pid: 1328
child terminated with value 0000<font color="blue"><b>7B</b></font>00, 31488
child terminated normally with exit code 123
</pre></blockquote>

<b>Output: (divide by zero)</b>
<blockquote><pre>
child pid: 1535
child terminated with value 00000008, 8
child terminated abnormally, code: 0
</pre></blockquote>


This value is the 
<a href="https://www.gnu.org/software/libc/manual/html_node/Program-Error-Signals.html">signal that was sent</a>
 to the application:

<a name="SIGNALS">
<blockquote><pre>
 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
 6) SIGABRT	 7) SIGBUS	 <b>8) SIGFPE</b>	 9) SIGKILL	10) SIGUSR1
11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
63) SIGRTMAX-1	64) SIGRTMAX	
</pre></blockquote>
</a>

Send some other signal to the child while it's sleeping and see the result.
<p>
Why does it say <i>Don't compile with optimizations</i>?

<!--
Since x isn't used anywhere, the optimizer just removes it so there is no div by zero
or segfault. (The abort will still fire.)
-->
<p>

<blockquote><pre>
</pre></blockquote>

<blockquote><pre>
</pre></blockquote>

<blockquote><pre>
</pre></blockquote>

<blockquote><pre>
</pre></blockquote>

<blockquote><pre>
</pre></blockquote>



<li>Waiting for multiple children #1: (<tt>fork-multiwait.c</tt>)</li>

<pre class="sourcecode"><code><font color="990099">#include &lt;stdio.h&gt;    /* printf              */</font>
<font color="990099">#include &lt;stdlib.h&gt;   /* exit                */</font>
<font color="990099">#include &lt;unistd.h&gt;   /* fork, getpid, sleep */</font>
<font color="990099">#include &lt;sys/wait.h&gt; /* wait, waitpid       */</font>

<font color="#003399"><i>/* Doesn't return */</i></font>
<b>void</b> dochild(<b>int</b> count)
{
  <b>int</b> pid = getpid();
  
  printf(<font color="#9933CC">&quot;[%i] child process\n&quot;</font>, pid);
  sleep(count); 
  printf(<font color="#9933CC">&quot;[%i] child exiting\n&quot;</font>, pid);
  
  exit(count * 10);
}

<b>int</b> main(<b>void</b>) 
{
  <b>int</b> i, cpid[3];
  <b>int</b> ppid = getpid();
  printf(<font color="#9933CC">&quot;parent pid = %d\n&quot;</font>, ppid);
  
  cpid[0] = fork();
  <b>if</b> (cpid[0] == 0) <font color="#003399"><i>/* child process is always 0 */</i></font>
    dochild(1);

  cpid[1] = fork();
  <b>if</b> (cpid[1] == 0) <font color="#003399"><i>/* child process is always 0 */</i></font>
    dochild(2);

  cpid[2] = fork();
  <b>if</b> (cpid[2] == 0) <font color="#003399"><i>/* child process is always 0 */</i></font>
    dochild(3);
  
  <font color="#003399"><i>/* parent process is non-zero (child's pid) */</i></font>
  
  printf(<font color="#9933CC">&quot;waiting for children\n&quot;</font>);
  <b>for</b> (i = 0; i &lt; 3; i++)
  {
    <b>int</b> status;
    printf(<font color="#9933CC">&quot;waiting for child pid: %d\n&quot;</font>, cpid[i]);
    <font color="blue"><b><a href="http://man7.org/linux/man-pages/man2/waitpid.2.html">waitpid</a></b></font>(cpid[i], &amp;status, 0);
    <b>if</b> (WIFEXITED(status))
      printf(<font color="#9933CC">&quot;[%i] child ended normally: %i\n&quot;</font>, cpid[i], WEXITSTATUS(status));
    <b>else</b>
      printf(<font color="#9933CC">&quot;[%i] child ended abnormally\n&quot;</font>, cpid[i]);
  }
  printf(<font color="#9933CC">&quot;children terminated\n&quot;</font>); 
  
  printf(<font color="#9933CC">&quot;parent exiting\n&quot;</font>);
  <b>return</b> 0;
}
</code></pre>

<blockquote>
<table border=0 cellpadding=0 cellspacing=5>
<tr align="left"><th>Output 1</th><th></th><th>Output 2</th><th></th><th>Output 3</th></tr>
<tr valign="top">
<td>
<pre>
parent pid = 1736
<font color="red">[2496] child process
[3640] child process
[2176] child process</font>
waiting for children
waiting for child pid: 2496
<font color="red">[2496] child exiting
[2496] child ended normally: 10</font>
waiting for child pid: 3640
<font color="red">[3640] child exiting
[3640] child ended normally: 20</font>
waiting for child pid: 2176
<font color="red">[2176] child exiting
[2176] child ended normally: 30</font>
children terminated
parent exiting
</pre>
</td>
<td width=40></td>
<td>
<pre>
parent pid = 3364
<font color="red">[1308] child process
[2240] child process</font>
waiting for children
waiting for child pid: 1308
<font color="red">[2364] child process
[1308] child exiting
[1308] child ended normally: 10</font>
waiting for child pid: 2240
<font color="red">[2240] child exiting
[2240] child ended normally: 20</font>
waiting for child pid: 2364
<font color="red">[2364] child exiting
[2364] child ended normally: 30</font>
children terminated
parent exiting
</pre>
</td>
<td width=40></td>
<td>
<pre>
parent pid = 3188
<font color="red">[2420] child process
[3620] child process</font>
waiting for children
<font color="red">[2084] child process</font>
waiting for child pid: 2420
<font color="red">[2420] child exiting
[2420] child ended normally: 10</font>
waiting for child pid: 3620
<font color="red">[3620] child exiting
[3620] child ended normally: 20</font>
waiting for child pid: 2084
<font color="red">[2084] child exiting
[2084] child ended normally: 30</font>
children terminated
parent exiting
</pre>
</td>
</tr></table>
</blockquote>
<p>

<li>There are a few things about the above program that need to be discussed.</li>
<ol>
	<li>The parent is blocked until the first child (<tt>cpid[0]</tt>) finishes.</li>
	<li>What if the other children finish first?</li>
	<ul>
		<li>Call with -1 to wait on <i>any</i> child, not a particular one.</li>
		<li>Returns the pid of the child that finished.</li>
	</ul>
	<li>What if the parent needs to do other work in parallel with the children?</li>
	<li>Add this code to <i>dochild</i> (before <i>exit</i>) to see what happens:
		<blockquote><pre>
<b>if</b> (count == 3)
  abort();</pre></blockquote>

  <li>The scheduler decides when to run the child. Default is to run the parent first. <!-- (<a href="http://lxr.linux.no/#linux+v3.9.8/kernel/sched/fair.c#L5733">source code</a>):-->
  	<blockquote><pre>
cat /proc/sys/kernel/sched_child_runs_first</pre></blockquote>
  	Setting it to a non-zero value will tell the scheduler to favor the child over the parent.
  </li>
</ol>

<p>
<li>Waiting for multiple children #2: (<tt>fork-multiwait2.c</tt>)</li>

  <blockquote>
  <p class="technote">
  	Use this technique if the parent process has <i>other work to do</i> 
  	while the children are working. <b>If the parent has nothing to do
  	(but wait for the children), DO NOT UNDER ANY CIRCUMSTANCES use this technique.</b> There are various
  	ways to wait for multiple children, this just demonstrates one way.
  </p>
  </blockquote>

<pre class="sourcecode"><code><font color="990099">#include &lt;stdio.h&gt;    /* printf              */</font>
<font color="990099">#include &lt;stdlib.h&gt;   /* exit                */</font>
<font color="990099">#include &lt;unistd.h&gt;   /* fork, getpid, sleep */</font>
<font color="990099">#include &lt;sys/wait.h&gt; /* wait, waitpid       */</font>

<font color="#003399"><i>/* Doesn't return */</i></font>
<b>void</b> dochild(<b>int</b> count)
{
  <b>int</b> pid = getpid();
  
  printf(<font color="#9933CC">&quot;[%i] child process\n&quot;</font>, pid);
  sleep(count);
  printf(<font color="#9933CC">&quot;[%i] child exiting\n&quot;</font>, pid);
  
  exit(count * 10);
}

<b>int</b> main(<b>void</b>) 
{
  <font color="990099">#define COUNT 3</font>
  <b>int</b> running = COUNT;
  <b>int</b> i, cpid[COUNT], terminated[COUNT] = {0};
  <b>int</b> ppid = getpid();
  printf(<font color="#9933CC">&quot;parent pid = %d\n&quot;</font>, ppid);
  
  <b>for</b> (i = 0; i &lt; COUNT; i++)
  {
    cpid[i] = fork();
    <b>if</b> (cpid[i] == 0) <font color="#003399"><i>/* child process is always 0 */</i></font>
      dochild(i);
  }
 
  <font color="#003399"><i>/* parent process is non-zero (child's pid) */</i></font>
  printf(<font color="#9933CC">&quot;waiting for children\n&quot;</font>);
  <b>while</b> (running)
  {
    <b>for</b> (i = 0; i &lt; COUNT; i++)
    {
      <b>int</b> status;
      <font color="#003399"><i>/*printf(&quot;waiting for child pid: %d\n&quot;, cpid[i]);*/</i></font>

      <font color="#003399"><i>/* If the parent has work to do while waiting, do it here...*/</i></font>
      
      <b>if</b> (!terminated[i])
      {
        <font color="#003399"><i>/*printf(&quot;child pid: %d not terminated\n&quot;, cpid[i]);*/</i></font>
        <b>if</b> (waitpid(cpid[i], &amp;status, <font color="red"><b>WNOHANG</b></font>))
        {
          <b>if</b> (WIFEXITED(status))
          {
            printf(<font color="#9933CC">&quot;[%i] child ended normally: %i\n&quot;</font>, cpid[i], WEXITSTATUS(status));
            running--;
            terminated[i] = 1;
          }
        }
      }
    }
  }
  printf(<font color="#9933CC">&quot;children terminated\n&quot;</font>); 
  printf(<font color="#9933CC">&quot;parent exiting\n&quot;</font>);
  <b>return</b> 0;
}
</code></pre>


<blockquote>
<table border=0 cellpadding=0 cellspacing=5>
<tr align="left"><th>Output 1</th><th></th><th>Output 2</th><th></th><th>Output 3</th></tr>
<tr valign="top">
<td>
<pre>
parent pid = 1132
<font color="red">[928] child process
[2456] child process
[928] child exiting</font>
waiting for children
[928] child ended normally: 0
<font color="red">[3628] child process
[2456] child exiting</font>
[2456] child ended normally: 10
<font color="red">[3628] child exiting</font>
[3628] child ended normally: 20
children terminated
parent exiting
</pre>
</td>
<td width=40></td>
<td>
<pre>
parent pid = 3956
<font color="red">[3940] child process
[3940] child exiting
[3564] child process</font>
waiting for children
<font color="red">[2764] child process</font>[3940] child ended normally: 0

<font color="red">[3564] child exiting</font>
[3564] child ended normally: 10
<font color="red">[2764] child exiting</font>
[2764] child ended normally: 20
children terminated
parent exiting
</pre>
</td>
<td width=40></td>
<td>
<pre>
parent pid = 948
<font color="red">[1100] child process
[2440] child process
[1100] child exiting</font>
waiting for children<font color="red">[1684] child process</font>

[1100] child ended normally: 0
<font color="red">[2440] child exiting</font>
[2440] child ended normally: 10
<font color="red">[1684] child exiting</font>
[1684] child ended normally: 20
children terminated
parent exiting
</pre>
</td>
</tr></table>
</blockquote>
<p>

<li>Another <a href="fork-multiwait3.html">example</a>. </li>
<p>

</ul>

  <blockquote>
  <p class="technote">
  	<b>DO NOT</b> use the technique above (<tt>WNOHANG</tt>) for any assignments in the class
  	unless specifically instructed to do so.
  	<b>Doing so will cause you to lose significant points (most likely a 0 on the assignment,
  		plus, Mead will KICK YOUR ASS</b>). I'm only showing this 
  	technique so that, in the future (outside of this class),
  	you may find that you need this capability. Doing this when the parent has nothing 
  	to do will effectively disable one of the cores on your CPU and slow down the
  	entire system.
  </p>
  </blockquote>


<!--
*****************************************************************************************
*****************************************************************************************
*****************************************************************************************
-->
<p class="sectionheader">
Forking, Buffering, and Redirection
</p>

You may recall that, for efficiency reasons, data written to <i>stdout</i> (e.g. via <i>printf</i>),
is <i>buffered</i>. This means that instead of <i>printf</i> writing each byte individually to the
output, entire lines are written at once. This can be a significant performance improvement.
<p>
There are two major types of buffering: line buffering and full buffering. <i>stdout</i> is
line-buffered, which means that when a newline is encountered, all of the bytes up to and including
the newline are then written to
<i>stdout</i>. The implications of this are, for example, if you were writing output using
<i>printf</i> and your program crashed before <i>printf</i> encountered the newline, some
bytes may never have made it to the screen.
<p>
This behavior may lead to some surprises when a parent and child process are both writing
buffered output to <i>stdout</i>. Some examples will demonstrate.
<p>
Here is a very simple example. (<tt>fork-redirect.c</tt>)

<pre class="sourcecode"><code><font color="990099">#include &lt;stdio.h&gt;    /* printf       */</font>
<font color="990099">#include &lt;stdlib.h&gt;   /* exit         */</font>
<font color="990099">#include &lt;unistd.h&gt;   /* fork, getpid */</font>
<font color="990099">#include &lt;sys/wait.h&gt; /* wait         */</font>

<b>int</b> main(<b>void</b>) 
{
  <b>int</b> pid; 

    <font color="#003399"><i>/* The text will be sent to the output when the newline is encountered. */</i></font>
  printf(<font color="#9933CC">&quot;This should only print once. (%i)&#92;n&quot;</font>, getpid());

  pid = fork();
  <b>if</b>(pid == 0)
  {
    printf(<font color="#9933CC">&quot;This is the child (pid: %i).&#92;n&quot;</font>, getpid());
    exit(123);
  }
  <b>else</b> <b>if</b> (pid &gt; 0)
  { 
    wait(NULL);
    printf(<font color="#9933CC">&quot;This is the parent (pid: %i).&#92;n&quot;</font>, getpid());
  }
  <b>else</b>
    printf(<font color="#9933CC">&quot;Fork failed.&#92;n&quot;</font>);
  
  <b>return</b> 0;
}
</code></pre>

This is the output (as expected):
<blockquote><pre>
This should only print once. (9206)
This is the child (pid: 9207).
This is the parent (pid: 9206).
</pre></blockquote>

<!--
<blockquote>
<p class="technote">
It is entirely possible that the parent's output was seen before the child's output, as the
order is undetermined. However, what is expected is that the first line printed before the
<i>fork</i> call should only be printed once, as seen above.
</p>
</blockquote>
-->

Now, let's remove the newline from the first print statement and see what the output looks like.
We're changing this:

<blockquote><pre>
  <font color="#003399"><i>/* The text will be sent to the output when the newline is encountered. */</i></font>
printf(<font color="#9933CC">&quot;This should only print once. (%i)&#92;n&quot;</font>, getpid());
</pre></blockquote>

to this:

<blockquote><pre>
  <font color="#003399"><i>/* There is no newline, so the text won't be sent until the buffer is full. */</i></font>
printf(<font color="#9933CC">&quot;This should only print once. (%i)&quot;</font>, getpid());
</pre></blockquote>

Running the program now shows this output:

<blockquote><pre>
This should only print once. (9436)This is the child (pid: 9437).
This should only print once. (9436)This is the parent (pid: 9436).
</pre></blockquote>

The first thing to notice is that there is no newline after the first line prints. This is
expected, of course, since we removed it. However, you'll notice that the first line is now printed
twice. One line is printed in the parent and the other is printed in the child.
<p>
Why is that?
<p>
This is the result of line-buffered output:
<ol>
	<li>The parent process sends the text to <i>printf</i> without a newline. (The text is buffered.)</li>
	<li>The text is NOT sent to <i>stdout</i> because a newline hasn't been seen 
		(and the buffer is not full).</li>
	<li>The <i>fork</i> call is made which duplicates the entire process.</li>
		<ul>
			<li>This means that the output buffer is duplicated in the child, 
				including the current contents of the buffer.</li>
			</li>
		</ul>
	<li>The <i>printf</i> call is made in the child, which includes a newline.</li>
	<ul>
		<li>The newline causes the entire buffer to be flushed sending all of the text
			(first <i>printf</i> and child <i>printf</i>) to the output.</li>
		</li>
	</ul>
	<li>The <i>printf</i> call is made in the parent, which includes a newline.</li>
	<ul>
		<li>The newline causes the entire buffer to be flushed sending all of the text
			(first <i>printf</i> and parent <i>printf</i>) to the output.</li>
		</li>
	</ul>
</ol>

The result is that the first line is seen twice. Steps 4 and 5 could
be swapped if you have a situation where the parent code happened 
to run before the child code did.
<p>
So, how do we "fix" that?
<p>
One solution is to make sure to flush the buffer before calling <i>fork</i>. This ensures
that the contents are sent to the output before creating the child process. Placing this
code after the first <i>printf</i> and before the <i>fork</i>:

<blockquote><pre>
fflush(stdout);
</pre></blockquote>

Now, we see this as the output:

<blockquote><pre>
This should only print once. (9817)This is the child (pid: 9818).
This is the parent (pid: 9817).
</pre></blockquote>

There is still no newline after the first line (expected), but the line is only sent
once to the output.
<p>
Another solution is to turn off buffering for <i>stdout</i> using <i>setvbuf</i>:

<blockquote><pre>
<b>int</b> setvbuf (FILE *stream, <b>char</b> *buf, <b>int</b> mode, size_t size);
</pre></blockquote>


Add this line of code before calling <i>printf</i>:

<blockquote><pre>
<a href="http://man7.org/linux/man-pages/man3/setvbuf.3p.html">setvbuf</a>(stdout, NULL, _IONBF, 0);
</pre></blockquote>

The third parameter is the intesting one and can be one of three:

<ul>
  <li><tt>_IOFBF</tt> - causes input/output to be fully buffered</li>
  <li><tt>_IOLBF</tt> - causes input/output to be line buffered</li>
  <li><tt>_IONBF</tt> - causes input/output to be unbuffered (<i>buf</i> and <i>size</i> are ignored)</li>
</ul>

See the man page (linked above) for more details. Now, when we run the program, the line
is only printed once. Keep in mind that disabling buffering <i>may</i> have a negative
impact on the performance. However, when printing to the screen, this is usually not a problem.
<p>
The example above shows how this "problem" is the result of not printing a new line. However,
there is still a problem when you do print the newline. It occurs when you redirect the output
to a file.
<p>
Suppose we put the newline back into the <i>printf</i> statement:
<blockquote><pre>
  <font color="#003399"><i>/* The text will be sent to the output when the newline is encountered. */</i></font>
printf(<font color="#9933CC">&quot;This should only print once. (%i)<b><big>&#92;n&quot;</big></b></font>, getpid());
</pre></blockquote>

We saw that this no longer caused the text to be printed twice (once in the parent and once in the child).
However, if you were to run the program and redirect the output to file:

<blockquote><pre>
./fork-redirect > out.txt
</pre></blockquote>

this is what you would see in the file:

<blockquote><pre>
This should only print once. (18897)
This is the child (pid: 18899).
This should only print once. (18897)
This is the parent (pid: 18897).
</pre></blockquote>

We're back to the same problem we had without the newline. So, why is this?
<p>
It turns out that, when you redirect <i>stdout</i>, the OS (or shell) is setting up a pipe.
(Much like the pipes you've been using at the command line). Instead of being line-buffered, 
the pipe is fully-buffered, which means that the output is only sent to <i>stdout</i> when the buffer
is full. It doesn't matter if there are newlines in the text or not.
<p>
The solution is the same as before. Either you can flush the buffer before the fork, or you can
set <i>stdout</i> back to line-buffered (or even no buffering). Either of these will do the trick:


<blockquote><pre>
<a href="http://man7.org/linux/man-pages/man3/setvbuf.3p.html">setvbuf</a>(stdout, NULL, <font color="blue"><b>_IOLBF</b></font>, 0); <font color="#003399"><i>/* line-buffered */</i></font>
</pre></blockquote>

or

<blockquote><pre>
<a href="http://man7.org/linux/man-pages/man3/setvbuf.3p.html">setvbuf</a>(stdout, NULL, <font color="blue"><b>_IONBF</b></font>, 0); <font color="#003399"><i>/* no buffering */</i></font>
</pre></blockquote>

<p class="technote">
The recommended approach is to just use <i>fflush</i> when you need to make sure the buffer is
sent to the output. It's easier to use and understand (most students and beginners have never heard
of <i>setvbuf</i>). It's also more efficient because it only affects the last <i>printf</i> statement,
not every <i>printf</i> statement.
</p>

<blockquote><pre>
</pre></blockquote>

<blockquote><pre>
</pre></blockquote>

<blockquote><pre>
</pre></blockquote>

<blockquote><pre>
</pre></blockquote>


<!--
*****************************************************************************************
*****************************************************************************************
*****************************************************************************************
-->
<p class="sectionheader">
The <tt>exec</tt> Function
</p>
<ul>
	<li>Isn't forking an entire process expensive? In a word, no.</li>
	<li>Usually, the child process will replace itself by calling one of the 
		<a href="http://man7.org/linux/man-pages/man3/exec.3.html">exec</a> functions.</li>
	<ul>
		<li>These functions are just wrappers around the 
			<a href="http://man7.org/linux/man-pages/man2/execve.2.html">execve</a> function:</li>

<blockquote><pre>
<b>int</b> execl(<b>const</b> <b>char</b> *path, <b>const</b> <b>char</b> *arg, ...);
<b>int</b> execlp(<b>const</b> <b>char</b> *file, <b>const</b> <b>char</b> *arg, ...);
<b>int</b> execle(<b>const</b> <b>char</b> *path, <b>const</b> <b>char</b> *arg, ...);
<b>int</b> execv(<b>const</b> <b>char</b> *path, <b>char</b> *<b>const</b> argv[]);
<b>int</b> execvp(<b>const</b> <b>char</b> *file, <b>char</b> *<b>const</b> argv[]);
<b>int</b> execvpe(<b>const</b> <b>char</b> *file, <b>char</b> *<b>const</b> argv[], <b>char</b> *<b>const</b> envp[]);
</pre></blockquote>
	</ul>

	<li>This function will load and execute another file from the disk.</li>
	<li>There are several different versions of this function. (We may have looked at some of them in CS120)</i>
	<li><a href="../../mg/getopt/index.html">Command line arguments</a>	from getopt notes</li>
	<li><a href="../CS120/RuntimeEnvironment.html">Command line arguments</a>	from CS120 notes</li>
	<li>Example: (<tt>exec.c</tt>, assumes that <i>geany</i> is installed in <tt>/usr/bin</tt>)</li>
	
<pre class="sourcecode"><code><b>#include</b> &lt;stdio.h&gt;    <font color="#003399"><i>/* printf         */</i></font>
<b>#include</b> &lt;stdlib.h&gt;   <font color="#003399"><i>/* exit           */</i></font>
<b>#include</b> &lt;unistd.h&gt;   <font color="#003399"><i>/* fork, getpid   */</i></font>
<b>#include</b> &lt;sys/wait.h&gt; <font color="#003399"><i>/* wait           */</i></font>

<b>int</b> main(<b>void</b>) 
{
  <b>int</b> pid;
  
  pid = fork();
  
  <b>if</b> (pid == 0) <font color="#003399"><i>/* child */</i></font>
  {
    printf(<font color="#9933CC">&quot;child: executing a program...\n&quot;</font>);
    <a href="http://man7.org/linux/man-pages/man3/exec.3.html">execl</a>(<font color="#9933CC">&quot;/usr/bin/geany&quot;</font>, <font color="#9933CC">&quot;geany&quot;</font>, NULL);
    printf(<font color="#9933CC">&quot;child: if you see this, the exec failed\n&quot;</font>);
    perror(<font color="#9933CC">&quot;geany&quot;</font>);
    
    exit(10); <font color="#003399"><i>/* arbitrary exit code */</i></font>
  }
  <b>else</b> <font color="#003399"><i>/* parent */</i></font>
  { 
    <b>int</b> code, status;
    
    printf(<font color="#9933CC">&quot;parent: waiting for child to terminate\n&quot;</font>);
    <a href="http://man7.org/linux/man-pages/man2/wait.2.html">wait</a>(&amp;status);
    
    code = WEXITSTATUS(status);
    printf(<font color="#9933CC">&quot;parent: child terminated with value %i\n&quot;</font>, code); 
  }
  
  <b>return</b> 0;
}
</code></pre>	
	
<blockquote>
<b>Output:</b>
<pre>
parent: waiting for child to terminate
child: executing a program...
parent: child terminated with value 0
</pre>
</blockquote>

Changing <b><tt>/usr/bin/geany</tt></b> to <b><tt>/usr/bin/foobar</tt></b>:

<blockquote>
<b>Output:</b>
<pre>
parent: waiting for child to terminate
child: executing a program...
child: if you see this, the exec failed
parent: child terminated with value 10
</pre>
</blockquote>

<li><a href="fork-process-1.jpg">Diagram</a> of the fork/exec process from
<a href="http://man7.org/tlpi/">The Linux Programming Interface</a> book.</li>
<p>
<li>To get more information on why <b>exec</b> failed, call <a href="http://man7.org/linux/man-pages/man3/perror.3.html">perror</a>.
<blockquote><pre>
perror("foobar");
</pre></blockquote>
prints out:
<blockquote><pre>
foobar: No such file or directory
</pre></blockquote>

<li>Another <a href="exec2.html">example</a> showing both the list and vector
	versions of <i>exec</i>.</li>
<p>

<li>You may be interested in the 'p' versions as they will search the path for the executable file.</li>
<ul>
	<li>However, realize that this can be a security issue. It's safer to always specify
		the absolute path.</li>
</ul>
<li>See <a href="http://man7.org/linux/man-pages/man3/exec.3.html">execve man page</a> for more information on this family of functions.</li>
<li>Also, see <a href="../CS120/RuntimeEnvironment.html#EXEC">exec</a> functions
	from the CS120 lectures.</li>


<li>Real World<sup>&trade;</sup> use of forking: A <a href="watchdog.cpp.html">watchdog</a>	program.</li>


</ul>




<!--
*****************************************************************************************
*****************************************************************************************
*****************************************************************************************
-->
<p class="sectionheader">
Process Termination
</p>

<ul>
	<li>When a process terminates, it has to return all the resources to the operating system:</li>
	<ul>
		<li>physical and virtual memory is returned (not memory allocated with <b><a href="http://man7.org/linux/man-pages/man2/shmget.2.html">shmget</a></b>)</li>
		<li>open files are closed</li>
		<li>I/O buffers are freed</li>
		<li>All other resources are deallocated by the operating system</li>
	</ul>
	<li>The process terminates either voluntarily or involuntarily.</li>
	<li>When one of the following conditions exists, the process terminates:</li>
	<ul>
		<li>Normal exit (voluntary)</li>
		<li>Error exit (voluntary)</li>
		<li>Fatal error (involuntary)</li>
		<li>Killed by another process (involuntary)</li>
	</ul>
</ul>

Voluntary exits:
<ul>
	<li>Normal exits:</li>
	<ul>
		<li>A process terminates when it finishes executing its final statement and asks the operating system to delete it. (Example: A process finished all of its work.)</li>
		<li>A normal exit in Unix is implemented via the <b><a href="http://man7.org/linux/man-pages/man3/exit.3.html">exit</a></b> call. (If you don't call <tt>exit</tt>, it will be called for you.)</li>
		<blockquote>
			<p class="technote">
				After <tt>exit()</tt>, the exit status must be transmitted to the parent process. There are three cases. If the parent has set SA_NOCLDWAIT, 
				or has set the SIGCHLD handler to SIG_IGN, the status is discarded. If the parent was waiting on the child it is notified of the exit status. 
				In both cases the exiting process dies immediately. <b>If the parent has not indicated that it is not interested in the exit status, but is not 
				waiting, the exiting process turns into a "zombie" process</b> (which is nothing but a container for the single byte representing the exit status) 
				so that the parent can learn the exit status when it later calls one of the <tt>wait()</tt> functions.
			</p>
		</blockquote>
		<li>In Windows a normal exit is via the <b><a href="http://msdn.microsoft.com/en-us/library/ms682658(VS.85).aspx">ExitProcess</a></b> call. (If you don't call <tt>ExitProcess</tt>, it will be called for you.)</li>
	</ul>
	<li>Error exits:</li>
	<ul>
		<li>When a process discovers a fatal error forcing the process to terminate.
		<li>For example, the process running the compiler might exit when it discovers that a source file is missing.</li>
	</ul>
</ul>

Involuntary exits:
<ul>
	<li>When the running process causes an error due to a program bug, the process is terminated:</li>
	<ul>
		<li>The process has exceeded the usage of the allocated resources.</li>
		<li>The process executes an illegal instruction.</li>
		<li>The process is referencing a nonexistent memory or illegal memory.</li>
		<li>Dividing by zero.</li>
		<li>Etc...</li>
	</ul>
	<li>When a process, (usually a parent process) decides to terminate or kill a running process:</li>
	<ul>
		<li>The task assigned to the process is no longer required.</li>
		<li>Other processes are exiting, and the operating system does not allow the process without the existence of other processes.</li>
		<li>Operating system is shutting down and needs to terminate all running processes.</li>
		<li>A process is taking too long (stress test) and is terminate by the parent (driver).</li>
<blockquote><pre>
/home/mmead/bin/wd 4000 4000 valgrind $(VALGRIND_OPTIONS) 2>> diff.txt ./$(PRG) | /home/mmead/bin/throttle 3000 -we > /dev/null
</pre></blockquote>
<li>The <a href="watchdog.cpp.html">watchdog</a> program.</li>
	</ul>
</ul>


<!--
*****************************************************************************************
*****************************************************************************************
*****************************************************************************************
-->
<p class="sectionheader">
Interprocess Communication (IPC)
</p>

We're going to look at 3 methods of interprocess communication:
<ol>
	<li>Shared memory</li>
	<ul>
		<li>Processes have access to a common block of memory</li>
		<li>Processes can read and write to the shared memory</li>
		<li>Very fast, but there may be synchronization issues (e.g. two process writing at the same time)</li>
	</ul>
	<li>Message passing</li>
	<ul>
		<li>Information passed between processes via the kernel</li>
		<li>Requires a message protocol</li>
		<li>Safer, but slower (the kernel synchronizes access)</li>
	</ul>
	<li>POSIX pipes</li>
	<ul>
		<li>Two processes can communicate using read and write functions.</li>
		<li>Simple. It is just as if they were reading/writing stdin/stdout.</li>
	</ul>
</ol>


<a name="SHAREDMEM">
<b>1. Shared memory</b>
</a>
<ul>
	<li>Allows for a block of memory to be shared between multiple processes</li>
	<li><tt><b><a href="http://man7.org/linux/man-pages/man2/shmget.2.html">shmget</a></b></tt> is used to create (or retrieve if already created) a block of memory</li>
	<ul>
		<li>Returns an identifier for the block</li>
	</ul>
	<li><tt><b><a href="http://man7.org/linux/man-pages/man2/shmat.2.html">shmat</a></b></tt> attaches the memory to the process</li>
	<ul>
		<li>Returns the address of the memory block</li>
	</ul>
	<li><tt><b><a href="http://man7.org/linux/man-pages/man2/shmdt.2.html">shmdt</a></b></tt> detaches the memory from the process</li>
	<li><tt><b><a href="http://man7.org/linux/man-pages/man2/shmctl.2.html">shmctl</a></b></tt> is used to delete the memory block</li>
	<li>All of these functions return -1 if an error occurs.</li>
	<ul>
		<li>Make sure you check the return values to detect any errors.</li>
	</ul>
	<p>
	<li>Shared memory example: (<tt>shared.c</tt>)</li>

<blockquote>
<p class="technote">
In order to keep these examples simple and understandable, most error handling has been removed. In a real-world
program (like the homework assignments), failing to check the return values of these IPC functions can result
in a lot of debugging because something failed. Also, failing to check the return values will cause you to receive
a lower grade on your assignments.
</p>
</blockquote>

<pre class="sourcecode"><code><b>#include</b> &lt;stdio.h&gt;    <font color="#003399"><i>/* printf                       */</i></font>
<b>#include</b> &lt;stdlib.h&gt;   <font color="#003399"><i>/* exit                         */</i></font>
<b>#include</b> &lt;string.h&gt;   <font color="#003399"><i>/* strcpy                       */</i></font>
<b>#include</b> &lt;unistd.h&gt;   <font color="#003399"><i>/* sleep, fork                  */</i></font>
<b>#include</b> &lt;sys/shm.h&gt;  <font color="#003399"><i>/* shmget, shmat, shmdt, shmctl */</i></font>
<b>#include</b> &lt;sys/wait.h&gt; <font color="#003399"><i>/* wait                         */</i></font>

<b>int</b> main(<b>void</b>) 
{
  <b>int</b> pid;
  <b>int</b> shmid;       <font color="#003399"><i>/* return value from fork/shmget */</i></font>
  <b>char</b> *buffer;    <font color="#003399"><i>/* shared buffer                 */</i></font>
  key_t key = 123; <font color="#003399"><i>/* arbitrary key (0x7b)          */</i></font>
  
  shmid = <a href="http://man7.org/linux/man-pages/man2/shmget.2.html">shmget</a>(key, 1024, 0600 | IPC_CREAT);
  buffer = (<b>char</b> *) <a href="http://man7.org/linux/man-pages/man2/shmat.2.html">shmat</a>(shmid, NULL, 0);
  strcpy(buffer,<font color="#9933CC">&quot;&quot;</font>);
  
  pid = <a href="http://man7.org/linux/man-pages/man2/fork.2.html">fork</a>();
  
  <b>if</b> (pid == 0) <font color="#003399"><i>/* child */</i></font>
  {
    printf(<font color="#9933CC">&quot;child: putting message in buffer\n&quot;</font>);
    strcpy(buffer, <font color="#9933CC">&quot;There's a fine line between clever and stupid.&quot;</font>);
    <a href="http://man7.org/linux/man-pages/man2/shmdt.2.html">shmdt</a>(buffer); <font color="#003399"><i>/* detach memory from child process */</i></font>

    printf(<font color="#9933CC">&quot;child: sleeping for 5 seconds...\n&quot;</font>);
    sleep(5);    
    printf(<font color="#9933CC">&quot;child: exiting\n&quot;</font>);
    exit(0); 
  }
  <b>else</b> <font color="#003399"><i>/* parent */</i></font>
  {
    printf(<font color="#9933CC">&quot;parent: waiting for child to exit...\n&quot;</font>);
    wait(NULL);
    printf(<font color="#9933CC">&quot;parent: message from child is %s\n&quot;</font>, buffer);
      
    <a href="http://man7.org/linux/man-pages/man2/shmdt.2.html">shmdt</a>(buffer);              <font color="#003399"><i>/* detach memory from parent process */</i></font>
    <a href="http://man7.org/linux/man-pages/man2/shmctl.2.html">shmctl</a>(shmid, IPC_RMID, 0); <font color="#003399"><i>/* delete memory block               */</i></font>
    
    printf(<font color="#9933CC">&quot;parent: exiting\n&quot;</font>);
  }
  
  <b>return</b> 0;
}
</code></pre>

<blockquote>
<b>Output:</b>
<pre>parent: waiting for child to exit...
child: putting message in buffer
child: sleeping for 5 seconds...
child: exiting
parent: message from child is There's a fine line between clever and stupid.
parent: exiting
</pre>
</blockquote>



	<li>Header file <tt>sys/shm.h</tt> needed for shared memory functions.</li>
	<li>Shared memory has file-style permissions.</li>
	<ul>
		<li>user/group/other, 3 bits each (9 bits total).</li>
		<li><tt>6 = 110 (binary) = rw-</tt>&nbsp;&nbsp; so &nbsp;&nbsp;<tt>600 = rw-------</tt></li>
	</ul>
	<li>Each process must know the id of the shared memory block.</li>
	<li>Use the command <a href="http://man7.org/linux/man-pages/man1/ipcs.1.html">ipcs</a> 
		to see shared memory in use.</li>
	<ul>
		<li>Run it with the <tt>-l</tt> option (that's a lowercase 'L') to see system defaults.</li>
	</ul>

	<li>Use the command <a href="http://man7.org/linux/man-pages/man1/ipcrm.1.html">ipcrm</a> 
		to delete shared memory.</li>
		<blockquote>
			<p class="technote">
				<b>Note:</b> If your program doesn't release the shared memory (e.g. due to it crashing),
				you must remove it manually or subsequent attempts to create the shared memory
				may fail.
			</p>
		</blockquote>
		This is especially true if you create the memory exclusively:
		<blockquote><pre>shmid = shmget(key, 1024, 0600 | IPC_CREAT | IPC_EXCL);</pre></blockquote>
		In any event, make sure you are checking the return value from <i>shmget</i> so that
		if the call fails, you won't waste time wondering why your program is not working.
<p>
	<li>If you want to guarantee that your key isn't already in use, you can provide <b>IPC_PRIVATE</b>
		as the key:
		<blockquote><pre>shmid = shmget(IPC_PRIVATE, 1024, 0600);</pre></blockquote>		
		which impiles  <b><tt>IPC_CREAT</tt></b> and <b><tt>IPC_EXCL</tt></b>. You 
		can also generate (almost) unique keys using
		<a href="http://man7.org/linux/man-pages/man3/ftok.3.html">ftok</a>.
<p>
	<!--
	<li>Under native Unix-based systems, this works right out of the box. Under Windows with Cygwin, you need to run the
		<a href="http://www.cygwin.com/cygwin-ug-net/using-cygserver.html">Cygserver</a>.
	-->
	<li>This example also shows how to create shared memory between processes using the Win32 API.
		It's only sharing a single integer between the processes.
		<blockquote>
	This code is the <a href="wmutex-parent.c.html">parent</a> process and this code is 
for the <a href="wmutex-child.c.html">child</a> processes.
</blockquote>
<p>

</ul>

<a name="MSGQUEUE">
<b>Message queues</b>
</a>
<ul>
	
	<li>Allows for passing messages between processes</li>
	<li><tt><b><a href="http://man7.org/linux/man-pages/man2/msgget.2.html">msgget</a></b></tt> creates (or retrieves an existing) message queue</li>
	<ul>	
		<li>Returns an identifier for the queue</li>
	</ul>
	<li><tt><b><a href="http://man7.org/linux/man-pages/man2/msgsnd.2.html">msgsnd</a></b></tt> posts a message to the queue</li>
	<li><tt><b><a href="http://man7.org/linux/man-pages/man2/msgrcv.2.html">msgrcv</a></b></tt> retrieves (and removes) a message from the queue</li>
	<li><tt><b><a href="http://man7.org/linux/man-pages/man2/msgctl.2.html">msgctl</a></b></tt> is used to delete the message queue</li>
	<li>All of these functions return -1 if an error occurred.</li>
	<li>Technically, these are not POSIX message queues, they are System V message queues.</li>
	<ul>
		<li>Sys V message queues have been around Forever<sup>&trade;</sup> and are implemented just about everywhere.</li>
		<li>POSIX queues are newer and are not as ubiquitous yet.</li>
		<li>The interfaces and capabilities are similar, but POSIX queues have more features.</li>
	</ul>
	<li>Message queue memory example: (<tt>msg.c</tt>)</li>

<pre class="sourcecode"><code><b>#include</b> &lt;stdio.h&gt;    <font color="#003399"><i>/* printf                         */</i></font>
<b>#include</b> &lt;stdlib.h&gt;   <font color="#003399"><i>/* exit                           */</i></font>
<b>#include</b> &lt;string.h&gt;   <font color="#003399"><i>/* strcpy                         */</i></font>
<b>#include</b> &lt;unistd.h&gt;   <font color="#003399"><i>/* fork                           */</i></font>
<b>#include</b> &lt;sys/msg.h&gt;  <font color="#003399"><i>/* msgget, msgsnd, msgrcv, msgctl */</i></font>
<b>#include</b> &lt;sys/wait.h&gt; <font color="#003399"><i>/* wait                           */</i></font>

<b>#define</b> BUFSIZE 1024
<b>#define</b> MSG_STRUCT 1

<font color="#003399"><i>/* Our user-defined structure */</i></font>
<b>typedef</b> <b>struct</b> 
{
  <b>long</b> <b>int</b> type;        <font color="#003399"><i>/* must be long int */</i></font>
  <b>char</b> buffer[BUFSIZE]; <font color="#003399"><i>/* can be anything  */</i></font>
}msg_struct;

<b>int</b> main(<b>void</b>) 
{
  <b>int</b> pid;
  <b>int</b> queue_id;    <font color="#003399"><i>/* shared id     */</i></font>
  msg_struct msg;  <font color="#003399"><i>/* our message   */</i></font>
  key_t key = 123; <font color="#003399"><i>/* arbitrary key */</i></font>
  
  queue_id = <a href="http://man7.org/linux/man-pages/man2/msgget.2.html">msgget</a>(key, 0600 | IPC_CREAT);
  pid = fork();
  
  <b>if</b> (pid == 0) <font color="#003399"><i>/* child */</i></font>
  {
    printf(<font color="#9933CC">&quot;child: sending messages\n&quot;</font>);
    msg.type = MSG_STRUCT;
    strcpy(msg.buffer, <font color="#9933CC">&quot;This is message number one...&quot;</font>);
    <a href="http://man7.org/linux/man-pages/man2/msgsnd.2.html">msgsnd</a>(queue_id, &amp;msg, BUFSIZE, 0);
    sleep(5);    
    strcpy(msg.buffer, <font color="#9933CC">&quot;This is message number two...&quot;</font>);
    <a href="http://man7.org/linux/man-pages/man2/msgsnd.2.html">msgsnd</a>(queue_id, &amp;msg, BUFSIZE, 0);
    sleep(5);    
    
    printf(<font color="#9933CC">&quot;child: exiting\n&quot;</font>);
    exit(0); 
  }
  <b>else</b> <font color="#003399"><i>/* parent */</i></font>
  {
    <font color="#003399"><i>/*sleep(2);*/</i></font> 
    printf(<font color="#9933CC">&quot;parent: waiting on child\n&quot;</font>);
    wait(NULL);
    
    printf(<font color="#9933CC">&quot;parent: receiving messages\n&quot;</font>);
    <b>while</b> (<a href="http://man7.org/linux/man-pages/man2/msgrcv.2.html">msgrcv</a>(queue_id, &amp;msg, BUFSIZE, 0, IPC_NOWAIT) != -1) 
    {
      <b>if</b> (msg.type == MSG_STRUCT)
        printf(<font color="#9933CC">&quot;message: %s\n&quot;</font>, msg.buffer);
      <b>else</b>
        printf(<font color="#9933CC">&quot;unknown message\n&quot;</font>); 
    }
    <a href="http://man7.org/linux/man-pages/man2/msgctl.2.html">msgctl</a>(queue_id, IPC_RMID, NULL); 
    printf(<font color="#9933CC">&quot;parent: exiting\n&quot;</font>);
  }
  
  <b>return</b> 0;
}
</code></pre>


<blockquote>
<b>Output:</b>
<pre>parent: waiting on child
child: sending messages
child: exiting
parent: receiving messages
message: This is message number one...
message: This is message number two...
parent: exiting
</pre>
</blockquote>


<li>A more real-world example without using parent-child processes:</li>
<p>
<b>Shared data:</b> (in a header file, <tt>client-server-msg.h</tt>)

<blockquote><pre>
<b>#define</b> BUFSIZE      1024
<b>#define</b> MSG_STRUCT      1 
<b>#define</b> MSG_QUIT        2 
<b>#define</b> SHARED_KEY  12345 <font color="#003399"><i>/* 0x3039 */</i></font>

<b>typedef</b> <b>struct</b> 
{
  <b>long</b> <b>int</b> type;        <font color="#003399"><i>/* must be long int */</i></font>
  <b>char</b> buffer[BUFSIZE]; <font color="#003399"><i>/* can be anything  */</i></font>
}msg_struct;
</pre></blockquote>

<b>Process #1 code (Sending process, <tt>msg-client.c</tt>)</b>

<!--
<font color="#003399"><i>/**************************************************************
 remark:
   For this to run properly under Cygwin, the Cygwin
   server ('cygserver') must be running in the background.
   See:
   http://www.cygwin.com/cygwin-ug-net/using-cygserver.html
**************************************************************/</i></font>
-->

<pre class="sourcecode"><code>
<b>#include</b> &lt;stdio.h&gt;   <font color="#003399"><i>/* printf, sprintf        */</i></font>
<b>#include</b> &lt;unistd.h&gt;  <font color="#003399"><i>/* sleep                  */</i></font>
<b>#include</b> &lt;sys/msg.h&gt; <font color="#003399"><i>/* msgget, msgsnd, msgctl */</i></font>

<b>#include</b> <font color="#9933CC">&quot;client-server-msg.h&quot;</font> <font color="#003399"><i>/* shared data */</i></font>

<b>int</b> main(<b>void</b>) 
{
  <b>int</b> i;
  key_t key = SHARED_KEY;
  msg_struct msg;
  <b>int</b> queue_id = msgget(key, 0600 | IPC_CREAT);
  
  msg.type = MSG_STRUCT;
  
  <b>for</b> (i = 0; i &lt; 10; i++) 
  {
    printf(<font color="#9933CC">&quot;client writing: %i\n&quot;</font>, i);
    sprintf(msg.buffer, <font color="#9933CC">&quot;Hello %i&quot;</font>, i);
    msgsnd(queue_id, &amp;msg, BUFSIZE, 0);
    sleep(1);
  }
  
  printf(<font color="#9933CC">&quot;client writing end message\n&quot;</font>);
  msg.type = MSG_QUIT;
  msgsnd(queue_id, &amp;msg, BUFSIZE, 0);
  
  <b>return</b> 0;
}
</code></pre>

<b>Process #2 code (Receiving process, <tt>msg-server.c</tt>)</b>

<!--
<font color="#003399"><i>/**************************************************************
 remark:
   For this to run properly under Cygwin, the Cygwin
   server ('cygserver') must be running in the background.
   See:
   http://www.cygwin.com/cygwin-ug-net/using-cygserver.html
**************************************************************/</i></font>
-->

<pre class="sourcecode"><code>
<b>#include</b> &lt;stdio.h&gt;    <font color="#003399"><i>/* printf                 */</i></font>
<b>#include</b> &lt;sys/msg.h&gt;  <font color="#003399"><i>/* msgget, msgrcv, msgctl */</i></font>

<b>#include</b> <font color="#9933CC">&quot;client-server-msg.h&quot;</font> <font color="#003399"><i>/* shared data */</i></font>

<b>int</b> main(<b>void</b>) 
{
  msg_struct msg;
  key_t key = SHARED_KEY;
  <b>int</b> queue_id = msgget(key, 0600 | IPC_CREAT);
  <b>int</b> done = 0;
  
  <b>while</b>(!done) 
  {
      <font color="#003399"><i>/* If no message is waiting, msgrcv returns -1 */</i></font>
    <b>while</b> (msgrcv(queue_id, &amp;msg, BUFSIZE, 0, 0 <font color="#003399"><i>/*IPC_NOWAIT*/</i></font>) != -1) 
    {
      <b>if</b> (msg.type == MSG_STRUCT)
        printf(<font color="#9933CC">&quot;message: %s\n&quot;</font>, msg.buffer);
      <b>else</b> <b>if</b> ( msg.type == MSG_QUIT ) <font color="#003399"><i>/* Remove if you want the server */</i></font>
      {                                <font color="#003399"><i>/*   to run indefinitely         */</i></font>
        done = 1;                      
        <b>break</b>;
      }
      <b>else</b>                      
        printf(<font color="#9933CC">&quot;unknown message\n&quot;</font>);
    }
  }
  printf(<font color="#9933CC">&quot;server shutting down\n&quot;</font>);
  msgctl(queue_id, IPC_RMID, NULL);
  
  <b>return</b> 0;
}
</code></pre>

<blockquote><pre>
</pre></blockquote>

<blockquote>
<table border=0 cellpadding=0 cellspacing=5>
<tr align="left"><th>Sending process</th><th></th><th>Receiving process</th></tr>
<tr valign="top">
<td>
<pre>
client writing: 0
client writing: 1
client writing: 2
client writing: 3
client writing: 4
client writing: 5
client writing: 6
client writing: 7
client writing: 8
client writing: 9
client writing end message
</pre>
</td>
<td width=40></td>
<td>
<pre>
message: Hello 0
message: Hello 1
message: Hello 2
message: Hello 3
message: Hello 4
message: Hello 5
message: Hello 6
message: Hello 7
message: Hello 8
message: Hello 9
server shutting down
</pre>
</td>
</tr></table>
</blockquote>
<p>


<blockquote><pre>
</pre></blockquote>

<li>Header file <tt>sys/msg.h</tt> must be included.</li>
<li>Each process must know the key value of the queue. In the example it's 12345 (0x3039)</li>
<li>Queue has file-style permissions.</li>
<li><tt><b>msgrcv</b></tt> has two modes:</li>
<ul>
	<li><tt>IPC_NOWAIT</tt>: returns -1 if there are no messages on the queue (non-blocking)</li>
	<li>not <tt>IPC_NOWAIT</tt>: blocks until there is a message on the queue</li>
	<li>Like the <i>wait</i> function, if the process that is receiving the message has
		nothing else to do, it should just block, otherwise it could waste cycles
		on the CPU core.</li>
</ul>

<li>Messages can have different structures</li>
<li>A message structure must have a <tt><b>long int</b></tt> as its first field (used for the message type identifier)</li>
<li>Message size (specified in <tt><b>msgsnd</b></tt> and <tt><b>msgrcv</b></tt>) is the message structure size <i><u>without</u></i> the long int identifier</li>
<li>Use the command <a href="http://man7.org/linux/man-pages/man1/ipcs.1.html">ipcs</a> to see message queues in use.</li>
<ul>
	<li>Run it with the <tt>-l</tt> option (that's a lowercase 'L') to see system defaults.</li>
	<li>See also <tt>/proc/sys/kernel/msg*</tt></li>
	<li>To monitor the queues:&nbsp;&nbsp; <tt> watch -n.5 ipcs -q</tt></li>
	<li>To remove a queue, use <a href="http://man7.org/linux/man-pages/man1/ipcrm.1.html">ipcrm</a>:
		&nbsp;&nbsp;&nbsp;<tt>ipcrm -q &lt;msqid&gt;</tt>
</ul>
<!--
	<li>Under native Unix-based systems, this works right out of the box. Under Windows with Cygwin, you need to run the
		<a href="http://www.cygwin.com/cygwin-ug-net/using-cygserver.html">Cygserver</a>.-->
</ul>


<p>
<hr width="90%">
<p>

<a name="PIPES">
<b>POSIX pipes</b>
</a>
<ul>
	<li>A pipe is a stream of communication between two processes.</li>
<li>These commmands from the terminal:

<blockquote><pre>
ls | wc
</pre></blockquote>

can be pictured like this (from <a href="http://man7.org/tlpi/">The Linux Programming Interface</a> book)</li>
<blockquote>
<img src="pipe1.png">
</blockquote>


	<li>You can think of it as a virtual file stream shared between two processes.</li>
	<li>A process can read and/or write to a pipe.</li>
	<li>Two processes can communicate via a pipe without even knowing it.</li>
	<ul>
		<li>This forms the backbone of Unix-like environments.</li>
	</ul>
	<li>The <tt><b>pipe</b></tt> function returns two descriptors (integers) in the (out) parameter</li>
	<ul>
		<li>Read descriptor - for reading from the pipe</li>
		<li>Write descriptor - for writing to the pipe</li>
		<li>From <a href="http://man7.org/tlpi/">The Linux Programming Interface</a> book:</li>
<blockquote>
<img src="pipe2.png">
</blockquote>
	</ul>


	<li>Both processes must know the descriptors.</li>
	<li><tt><b>read</b></tt> and <tt><b>write</b></tt> are used with the pipe.</li>
	<ul>
		<li>This makes communication trivial as each process is just reading and writing files.</li>
		</ul>

		<li>From <a href="http://man7.org/tlpi/">The Linux Programming Interface</a> book:</li>
<blockquote>
<img src="pipe3.png">
</blockquote>

	<li><tt><b>pipe</b></tt> example: (<tt>pipe1.c</tt>)</li>


<blockquote><pre>
</pre></blockquote>

<blockquote><pre>
</pre></blockquote>



<pre class="sourcecode"><code>
<font color="990099">#include &lt;stdio.h&gt;    /* printf, fgets                  */</font>
<font color="990099">#include &lt;stdlib.h&gt;   /* exit                           */</font>
<font color="990099">#include &lt;string.h&gt;   /* strlen                         */</font>
<font color="990099">#include &lt;unistd.h&gt;   /* fork, pipe, read, write, close */</font>
<font color="990099">#include &lt;sys/wait.h&gt; /* wait                           */</font>

<b>int</b> main(<b>void</b>) 
{
  <b>int</b> pid;
  <b>char</b> buffer[1024];
  <b>int</b> fd[2];
  
  <a href="http://man7.org/linux/man-pages/man2/pipe.2.html">pipe</a>(fd); <font color="#003399"><i>/* fd[0] is for read, fd[1] is for write */</i></font>
  
  pid = fork();
  
  <b>if</b> (pid == 0) <font color="#003399"><i>/* child */</i></font>
  {
    <b>int</b> count;
    close(fd[0]); <font color="#003399"><i>/* close unused end (read), child will write */</i></font>
    
      <font color="#003399"><i>/* prompt user for input */</i></font>
    printf(<font color="#9933CC">&quot;input: &quot;</font>);
    fgets(buffer, <b>sizeof</b>(buffer), stdin);
    printf(<font color="#9933CC">&quot;child: message is %s&quot;</font>, buffer);
    
      <font color="#003399"><i>/* write to the pipe (include NUL terminator!) */</i></font>
    count = write(fd[1], buffer, strlen(buffer) + 1);
    printf(<font color="#9933CC">&quot;child: wrote %i bytes\n&quot;</font>, count);
    
    exit(0); 
  }
  <b>else</b> <font color="#003399"><i>/* parent */</i></font>
  {
    <b>int</b> count;
    close(fd[1]); <font color="#003399"><i>/* close unused end (write), parent will read */</i></font>
    
      <font color="#003399"><i>/* read from the pipe */</i></font>
    count = read(fd[0], buffer, <b>sizeof</b>(buffer));
    printf(<font color="#9933CC">&quot;parent: message is %s&quot;</font>, buffer);
    printf(<font color="#9933CC">&quot;parent: read %i bytes\n&quot;</font>, count);
    
    wait(NULL);   <font color="#003399"><i>/* reap the child */</i></font>
  }
  
  <b>return</b> 0;
}
</code></pre>

<blockquote>

<b>Output:</b> (User types 22 characters)
<pre>input: <font color="red"><b>This is from teh user!</b></font>
child: message is This is from teh user!
child: wrote 24 bytes
parent: message is This is from teh user!
parent: read 24 bytes</pre>

<b>Output:</b>
<pre>input: <font color="red"><b>12345</b></font>
child: message is 12345
child: wrote 7 bytes
parent: message is 12345
parent: read 7 bytes</pre>
</blockquote>

<!--
<pre class="sourcecode"><code>
  1 <font color="990099">#include &lt;stdio.h&gt;  /* fprintf, fgets           */</font>
  2 <font color="990099">#include &lt;stdlib.h&gt; /* exit                     */</font>
  3 <font color="990099">#include &lt;string.h&gt; /* strlen                   */</font>
  4 <font color="990099">#include &lt;unistd.h&gt; /* pipe, read, write, close */</font>
  5 
  6 <b>int</b> main(<b>void</b>) 
  7 {
  8   <b>int</b> pid;
  9   <b>char</b> buffer[1024];
 10   <b>int</b> fd[2];
 11   
 12   pipe(fd);
 13   pid = fork();
 14   
 15   <b>if</b> (pid == 0) <font color="#003399"><i>/* child */</i></font>
 16   {
 17     close(fd[0]); <font color="#003399"><i>/* close unused end */</i></font>
 18     
 19     printf(<font color="#9933CC">&quot;input: &quot;</font>);
 20     fgets(buffer, <b>sizeof</b>(buffer), stdin);
 21     write(fd[1], buffer, strlen(buffer) + 1);
 22     
 23     exit(0); 
 24   }
 25   <b>else</b> <font color="#003399"><i>/* parent */</i></font>
 26   {
 27     close(fd[1]); <font color="#003399"><i>/* close unused end  */</i></font>
 28     wait(NULL);   <font color="#003399"><i>/* Important to wait */</i></font>
 29     
 30     read(fd[0], buffer, <b>sizeof</b>(buffer));
 31     printf(<font color="#9933CC">&quot;message: %s&quot;</font>, buffer);
 32   }
 33   
 34   <b>return</b> 0;
 35 }
</code></pre>
-->

</ul>



<ul>
	<li>The <tt>unistd.h</tt> (POSIX) header file needs to be included for the <tt>pipe, read,</tt> and <tt>write</tt> functions.</li>
	<li>The <tt>pipe</tt> function fills in the descriptor array.</li>
	<ul>
		<li><tt>descriptor[0]</tt> is for reading from the pipe</li>
		<li><tt>descriptor[1]</tt> is for writing to the pipe</li>
	</ul>
	<li>An ordinary (anonymous) pipe cannot be accessed from outside the process that created it.</li>
	<ul>
		<li>A parent will create a pipe, then fork so the child can access it.</li>
		<li>Child processes inherit all open files (pipes are a special kind of file) from the parent.</li>
		<ul>
			<li>These will persist across calls to the <i>exec</i> functions (can be disabled).</li>
		</ul>
		<li>Once the processes end, the pipes no longer exist.</li>
		<li>Ordinary pipes can only be used with processes on the same machine.</li>
	</ul>
	<li><span id=wpurl><a class=wplabel>Named pipes</a></span><a class=wplink href="http://en.wikipedia.org/wiki/Named_pipe">Named pipes</a> are more powerful than ordinary (or anonymous) pipes.</li>
	<ul>
		<li>They can be used by several processes at once.</li>
		<li>They don't require a parent-child relationship.</li>
		<li>They exist independently of the process that created them.</li>
		<ul>
			<li>Much like how files created on the disk by a process exist after the process ends.</li>
		</ul>
		<li>See <a href="http://man7.org/linux/man-pages/man3/mkfifo.3.html">mkfifo</a> on Unix-based systems and 
			<a href="http://msdn.microsoft.com/en-us/library/aa365150(VS.85).aspx">CreateNamedPipe</a> on Windows</li>
	</ul>
			
</ul>

<p><hr width="90%"><p>

<b>Self check:</b> Programming Problem 3.18 from the suggested textbook.

<blockquote><i>
"Design a program using ordinary pipes in which one process sends a string message
to a second process, and the second process reverses the case of each character in
the message and sends it back to the first process. For example, if the first process
sends the message</i> <tt>Hi There</tt>, <i>the second process will return</i> <tt>hI tHERE</tt>.
<i>This will require using two pipes, one for sending the original message from the
first to the second process, and the other for sending the modified message from
the second back to the first process."
</i></blockquote>

<!--
Here is a function that will do the actual reversal:

<blockquote><pre>
<b>void</b> revcase(<b>char</b> *buffer)
{
  <b>int</b> i;
  <b>int</b> len = strlen(buffer);
  <b>for</b> (i = 0; i &lt; len; i++)
  {
    <b>if</b> (isupper(buffer[i]))
      buffer[i] = tolower(buffer[i]);
    <b>else</b> <b>if</b> (islower(buffer[i]))
      buffer[i] = toupper(buffer[i]);
  }
}
</pre></blockquote>
-->

<pre class="sourcecode"><code>
<font color="990099">#include &lt;stdio.h&gt;    /* printf, fgets            */</font>
<font color="990099">#include &lt;stdlib.h&gt;   /* exit                     */</font>
<font color="990099">#include &lt;string.h&gt;   /* strlen                   */</font>
<font color="990099">#include &lt;ctype.h&gt;    /* isalpha, toupper         */</font>
<font color="990099">#include &lt;unistd.h&gt;   /* pipe, read, write, close */</font>
<font color="990099">#include &lt;sys/wait.h&gt; /* wait                     */</font>

<b>void</b> revcase(<b>char</b> *buffer)
{
  <b>int</b> i;
  <b>int</b> len = strlen(buffer);
  <b>for</b> (i = 0; i &lt; len; i++)
  {
    <b>if</b> (isupper(buffer[i]))
      buffer[i] = tolower(buffer[i]);
    <b>else</b> <b>if</b> (islower(buffer[i]))
      buffer[i] = toupper(buffer[i]);
  }
}

<b>int</b> main(<b>void</b>) 
{
  <b>int</b> pid;

  <font color="#003399"><i>/* setup stuff */</i></font>
  
  pid = fork();
  
  <b>if</b> (pid == 0) <font color="#003399"><i>/* child */</i></font>
  {
  
    <font color="#003399"><i>/* DO STUFF */</i></font>  
  
    exit(0); 
  }
  <b>else</b> <font color="#003399"><i>/* parent */</i></font>
  {
    <font color="#003399"><i>/* DO STUFF */</i></font>
      
    wait(NULL);  
  }
  
  <b>return</b> 0;
}

</code></pre>


<!--
*****************************************************************************************
*****************************************************************************************
*****************************************************************************************
-->
<p class="sectionheader">
Using popen for pipes
</p>


If you just need to setup a pipe between two processes, there is a function called
<a href="http://man7.org/linux/man-pages/man3/popen.3p.html">popen</a> which makes things easier. It basically performs the 
<i>fork</i>, <i>exec</i>, and <i>pipe</i> stuff for you. Since many programs just need this
kind of behavior, it can be a real convenience.
<p>

This sample code simply prints out the strings: <i>one two three four five six seven</i> to the 
screen (<i>stdout</i>): (<tt>popen0.c</tt>)



<pre class="sourcecode"><code><font color="990099">#include &lt;stdio.h&gt; /* printf */</font>

<b>int</b> main(<b>void</b>)
{
  <b>int</b> i;
  <b>char</b> *array[] = {<font color="#9933CC">&quot;one&quot;</font>, <font color="#9933CC">&quot;two&quot;</font>, <font color="#9933CC">&quot;three&quot;</font>, <font color="#9933CC">&quot;four&quot;</font>, <font color="#9933CC">&quot;five&quot;</font>, <font color="#9933CC">&quot;six&quot;</font>, <font color="#9933CC">&quot;seven&quot;</font>};
  <b>int</b> size = <b>sizeof</b>(array) / <b>sizeof</b>(*array);

    <font color="#003399"><i>/* Print to stdout */</i></font>
  <b>for</b>(i = 0; i &lt; size; i++) 
    printf(<font color="#9933CC">&quot;%s&#92;n&quot;</font>, array[i]);

  <b>return</b> 0;
}
</code></pre>

<b>Output:</b>
<blockquote><pre>
one
two
three
four
five
six
seven
</pre></blockquote>

If we wanted the output sorted, we would pipe the output to the
standard <i>sort</i> program that is available on all
POSIX systems using the pipe symbol:

<blockquote><pre>
./popen0 | sort
</pre></blockquote>

<b>Output:</b>
<blockquote><pre>
five
four
one
seven
six
three
two
</pre></blockquote>

But, suppose we wanted to sort the data <i>within</i> our program and not require the user
to have to do the piping on the command line? That's where the <i>popen</i> function comes
in handy.
<p>

This example shows how you can use the <i>sort</i> program to sort your data from within your program. So, instead of using <i>printf</i> to
print to <i>stdout</i>, we're using <i>fprintf</i> to print to the <i>sort</i> program!  (<tt>popen1.c</tt>)

<pre class="sourcecode"><code><font color="#003399"><i>/* compile with -D_BSD_SOURCE if using -ansi */</i></font>

<font color="990099">#include &lt;stdio.h&gt; /* fprintf, popen, pclose, perror */</font>

<b>int</b> main(<b>void</b>)
{
  <b>int</b> i;
  FILE *pfp;
  <b>char</b> *array[] = {<font color="#9933CC">&quot;one&quot;</font>, <font color="#9933CC">&quot;two&quot;</font>, <font color="#9933CC">&quot;three&quot;</font>, <font color="#9933CC">&quot;four&quot;</font>, <font color="#9933CC">&quot;five&quot;</font>, <font color="#9933CC">&quot;six&quot;</font>, <font color="#9933CC">&quot;seven&quot;</font>};
  <b>int</b> size = <b>sizeof</b>(array) / <b>sizeof</b>(*array);

    <font color="#003399"><i>/* Create write-only pipe (i.e. open <b>program</b> for writing) */</i></font>
  pfp = popen(<font color="#9933CC">&quot;sort&quot;</font>, <font color="#9933CC">&quot;w&quot;</font>);
  <b>if</b> (!pfp)
  {
    perror(<font color="#9933CC">&quot;popen&quot;</font>);
    <b>return</b> 1;
  }

    <font color="#003399"><i>/* Print to pipe (write to <b>sort program</b>) */</i></font>
  <b>for</b>(i = 0; i &lt; size; i++) 
    fprintf(pfp, <font color="#9933CC">&quot;%s&#92;n&quot;</font>, array[i]);

    <font color="#003399"><i>/* Close the pipe */</i></font>
  pclose(pfp);

  <b>return</b> 0;
}
</code></pre>

<blockquote><pre>
</pre></blockquote>

<blockquote><pre>
</pre></blockquote>

<blockquote><pre>
</pre></blockquote>



<b>Output:</b>
<p>
<blockquote><pre>
five
four
one
seven
six
three
two
</pre></blockquote>

<blockquote>
<li>Diagram from <a href="http://man7.org/tlpi/">The Linux Programming Interface</a> book:</li>
<blockquote>
<img src="popen1.png">
</blockquote>
</blockquote>

<p>
<hr width=95%>
<p>

This example shows how you can setup a pipe within your C program just as if you
were using the command line: (<tt>popen2.c</tt>) This is equivalent to the command line:
&nbsp;&nbsp;&nbsp;<tt>ls /usr/bin | sort -r</tt>

<pre class="sourcecode"><code><font color="#003399"><i>/* compile with -D_BSD_SOURCE if using -ansi */</i></font>

<font color="990099">#include &lt;stdio.h&gt;</font> <font color="#003399"><i>/* popen, perror, fprintf, pclose, fgets */</i></font>

<font color="990099">#define BUFSIZE 100</font>

<b>int</b> main(<b>void</b>)
{
  FILE *inpipe, *outpipe;
  <b>char</b> buffer[BUFSIZE];

    <font color="#003399"><i>/* read pipe from ls (i.e. open <b>ls program</b> for reading) */</i></font>
  inpipe = popen(<font color="#9933CC">&quot;ls /usr/bin&quot;</font>, <font color="#9933CC">&quot;r&quot;</font>);
  <b>if</b> (!inpipe)
  {
    perror(<font color="#9933CC">&quot;popen read:&quot;</font>);
    <b>return</b> 1;
  }

    <font color="#003399"><i>/* write pipe to sort (i.e. open <b>sort program</b> for writing) */</i></font>
  outpipe = popen(<font color="#9933CC">&quot;sort -r&quot;</font>, <font color="#9933CC">&quot;w&quot;</font>);
  <b>if</b> (!outpipe)
  {
    perror(<font color="#9933CC">&quot;popen write:&quot;</font>);
    <b>return</b> 2;
  }

    <font color="#003399"><i>/* read from ls and write to sort (reversed) */</i></font>
    <font color="#003399"><i>/* it's this: ls /usr/bin | sort -r          */</i></font>
  <b>while</b>(fgets(buffer, BUFSIZE, inpipe))
    fprintf(outpipe, <font color="#9933CC">&quot;%s&quot;</font>, buffer);

    <font color="#003399"><i>/* clean up */</i></font>
  pclose(inpipe);
  pclose(outpipe);

  <b>return</b> 0;
}
</code></pre>

Partial output:
<blockquote><pre>
zxpdf
zsoelim
zsh
zrun
zlib-flate
zjsdecode
zipsplit
zipnote
zipinfo
zipgrep
zipdetails
zipcloak
zip
zim
.
.
.
aainfo
aaflip
aafire
a5toa4
a5booklet
a2ping
a2p
7zr
7za
7z
2to3-3.4
2to3-2.7
2to3
[
</pre></blockquote>

On my system there are over 4,000 lines!
<p>

Capturing output from the compiler: (<tt>popen3.c</tt>)
<p>

<pre class="sourcecode"><code><font color="#003399"><i>/* compile with -D_BSD_SOURCE if using -ansi */</i></font>

<font color="990099">#include &lt;stdio.h&gt;</font> <font color="#003399"><i>/* popen, perror, printf, pclose, fgets */</i></font>

<font color="990099">#define BUFSIZE 100</font>

<b>int</b> main(<b>void</b>)
{
  FILE *inpipe;
  <b>char</b> buffer[BUFSIZE];

    <font color="#003399"><i>/* read pipe from gcc */</i></font>
  inpipe = popen(<font color="#9933CC">&quot;gcc foo.c&quot;</font>, <font color="#9933CC">&quot;r&quot;</font>);
  <b>if</b> (!inpipe)
  {
    perror(<font color="#9933CC">&quot;popen read:&quot;</font>);
    <b>return</b> 1;
  }

    <font color="#003399"><i>/* Read from compiler and output to screen */</i></font>
  <b>while</b>(fgets(buffer, BUFSIZE, inpipe))
    printf(<font color="#9933CC">&quot;%s&quot;</font>, buffer);

    <font color="#003399"><i>/* clean up */</i></font>
  pclose(inpipe);

  <b>return</b> 0;
}
</code></pre>

This is <tt>foo.c</tt>:

<blockquote><pre>
<b>int</b> main(<b>void</b>)
{
  <b>return</b>; <font color="#003399"><i>/* Missing return value */</i></font>
}
</pre></blockquote>

Output:
<blockquote><pre>
foo.c: In function 'main':
foo.c:3:3: warning: 'return' with no value, in function returning non-void
   return;
   ^
</pre></blockquote>

With this knowledge, you can now you can start writing your own IDE (e.g. Visual Studio)!
<p>
<a href="win-popen.html">Create your own IDE</a> on Windows with child processes
and pipes.

<p class="sectionheader">
Win32 Process Creation
</p>

<ul>
	<li>Creates a child process (doesn't <tt>fork</tt> like Unix-based systems).</li>
	<li>Uses an existing <i>program</i> as child process (much like <tt>exec</tt>).</li>
	<li>Non-blocking: parent code continues to execute after child process is created.</li>
	<li>Parent uses <tt><a href="http://msdn.microsoft.com/en-us/library/ms687032(v=vs.85).aspx">WaitForSingleObject</a></tt> to wait for one child</li>
	<li><tt><a href="http://msdn.microsoft.com/en-us/library/ms687025(v=vs.85).aspx">WaitForMultipleObjects</a></tt> used by parent to wait for multiple children</li>
	<li>Win32 lacks a <tt>fork</tt> function, but Cygwin implements one (by way of voodoo and black magic, and it's inefficient).</li>
</ul>

<b>CreateProcess Example</b> (<tt>CreateProcess.cpp</tt>)

<pre class="sourcecode"><code><font color="990099">#include &lt;iostream&gt;</font>
<font color="990099">#include &lt;windows.h&gt;</font>

<b>int</b> main(<b>void</b>) 
{
  <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms686331%28v=vs.85%29.aspx">STARTUPINFO</a> start_info;
  <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684873%28v=vs.85%29.aspx">PROCESS _INFORMATION</a> proc_info;
  
  DWORD pid = GetCurrentProcessId();
  std::cout &lt;&lt; <font color="#9933CC">&quot;parent pid = &quot;</font> &lt;&lt; pid &lt;&lt; std::endl;

    <font color="#003399"><i>// allocate memory and set to 0</i></font>
  ZeroMemory(&amp;start_info, <b>sizeof</b>(STARTUPINFO));
  ZeroMemory(&amp;proc_info, <b>sizeof</b>(PROCESS_INFORMATION));
  
  std::cout &lt;&lt; <font color="#9933CC">&quot;creating child process&quot;</font> &lt;&lt; std::endl;
  <b>const</b> <b>char</b> *program = <font color="#9933CC">&quot;c:&#92;&#92;windows&#92;&#92;system32&#92;&#92;notepad.exe&quot;</font>;
  BOOL err = <a href="http://msdn.microsoft.com/en-us/library/ms682425(v=vs.85).aspx">CreateProcess</a>(program,     <font color="#003399"><i>// program to run</i></font>
                           0,           <font color="#003399"><i>// command line</i></font>
                           0,           <font color="#003399"><i>// security attributes</i></font>
                           0,           <font color="#003399"><i>// thread attributes</i></font>
                           FALSE,       <font color="#003399"><i>// don't inherit handles</i></font>
                           0,           <font color="#003399"><i>// creation flags (none)</i></font>
                           0,           <font color="#003399"><i>// use parent's environment</i></font>
                           0,           <font color="#003399"><i>// use parent's directory</i></font>
                           &amp;start_info, <font color="#003399"><i>// start up info</i></font>
                           &amp;proc_info   <font color="#003399"><i>// process info</i></font>
                          );
  
  <b>if</b> (!err)
  {
    std::cout &lt;&lt; <font color="#9933CC">&quot;Error creating process&quot;</font> &lt;&lt; std::endl;
    <b>return</b> -1;
  }

  std::cout &lt;&lt; <font color="#9933CC">&quot;waiting for child to terminate&quot;</font> &lt;&lt; std::endl;
  <a href="http://msdn.microsoft.com/en-us/library/ms687032(v=vs.85).aspx">WaitForSingleObject</a>(proc_info.hProcess, INFINITE);
  std::cout &lt;&lt; <font color="#9933CC">&quot;parent terminating&quot;</font> &lt;&lt; std::endl;

  <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms724211%28v=vs.85%29.aspx">CloseHandle</a>(proc_info.hProcess);
  CloseHandle(proc_info.hThread);

  <b>return</b> 0;
}
</code></pre>

<b>Creating Multiple Processes Example</b>

<pre class="sourcecode"><code><font color="990099">#include &lt;stdio.h&gt;</font>
<font color="990099">#include &lt;windows.h&gt;</font>

<b>int</b> main(<b>void</b>) 
{
  <b>const</b> <b>int</b> COUNT = 2;

  HANDLE proc[COUNT], thread[COUNT];
  <b>const</b> <b>char</b> *programs[] = {<font color="#9933CC">&quot;c:&#92;&#92;windows&#92;&#92;system32&#92;&#92;notepad.exe&quot;</font>,
                             <font color="#9933CC">&quot;c:&#92;&#92;windows&#92;&#92;system32&#92;&#92;mspaint.exe&quot;</font>,
                            };

  <b>for</b> (<b>int</b> i = 0; i &lt; COUNT; ++i) 
  {
    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    ZeroMemory(&amp;si, <b>sizeof</b>(si));
    ZeroMemory(&amp;pi, <b>sizeof</b>(pi));

    CreateProcess(programs[i], 0, 0, 0, <b>FALSE</b>, 0, 0, 0, &amp;si, &amp;pi);

    proc[i] = pi.hProcess;
    thread[i] = pi.hThread;
  }

  WaitForMultipleObjects(COUNT, proc, <b>TRUE</b>, INFINITE);

  <b>for</b> (<b>int</b> i = 0; i &lt; COUNT; ++i) 
  {
    printf(<font color="#9933CC">&quot;Process: %i, Thread: %i ended.&#92;n&quot;</font>, proc[i], thread[i]);
    CloseHandle(proc[i]);
    CloseHandle(thread[i]);
  }
  <b>return</b> 0;
}
</code></pre>


</body>
</html>

  
  
<blockquote><pre>
</pre></blockquote>


<blockquote><pre>
</pre></blockquote>

<blockquote>
<table border=0 cellspacing=5 cellpadding=0>
<tr><th></th><th></th><th></th></tr>
<tr valign="top">
<td>
<blockquote><pre>
</pre></blockquote>
</td>
<td>
<blockquote><pre>
</pre></blockquote>
</td>
<td>
<blockquote><pre>
</pre></blockquote>
</td>
</tr></table>
</blockquote>

<tt><b></b></tt>

<blockquote>
<table border=0 cellspacing=5 cellpadding=5>
<tr><th></th><th></th></tr>
<tr valign="top">
<td>
<blockquote><pre>
</pre></blockquote>
</td>
<td>
<blockquote><pre>
</pre></blockquote>
</td>
</tr></table>
</blockquote>

<blockquote><pre>
</pre></blockquote>

<blockquote><pre>
</pre></blockquote>

<blockquote><pre>
</pre></blockquote>

<!--
	<span class="attrib">Operating System Concepts - 8th Edition Silberschatz, Galvin, Gagne &copy;2009</span>
	
<table border=0>
	<tr><td></td></tr>
	<tr><td align="right"><span class="attrib">Operating System Concepts - 8th Edition Silberschatz, Galvin, Gagne &copy;2009&nbsp;&nbsp;</span></td></tr>
</table>

<blockquote>
<table border=0 cellspacing=0 cellpadding=2>
	<tr><td><img src="ComputerComponents-1.png"></td></tr>
	<tr><td align="right"><span class="attrib">Operating System Concepts - 8th Edition Silberschatz, Galvin, Gagne &copy;2009&nbsp;&nbsp;</span></td></tr>
</table>
</blockquote>
	
-->
